<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-74.99705309342698 -7.395887697909075 4069.861183597212 3052.395887697909" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-74.99705309342698" y="-7.395887697909075" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">✕</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED:EQI9Pgouj2wN78W5jcqFfxQPFWEC/VmoZryYRt5WaWEdo3zUsJgZAP/sSGBUkLriKElIDnfRg01/x3j6ysXk1V/Kdva4g24qskRu0jGUPfgcsO0LQksJQ7ha5v6PWYQXIXQT8D8wWhRAO/R9IuvbcLoQnw5tItcwZG/KWZbnfhliOz+OsmPTOTH17v7ZRyQB5I53C11hyBSuDAMoCYbn8KmCnMrYnq/T2e729y415SQ2RiTEo3H9JSt49EQ3NX5wLlvPji8LYMOskSbCDAxxSrD4jkV+MJ9S6urb6FlW9HedAeIAqa0+WfwVjdbP131SLshQezS0y2oeexKgiHncewidxPwxgRb1yn9r8Vz03Hv3zYtSeQwd0V+SywGpLguJa2w9YvSvUTgZDaBGnfMnMFwpSsh/p5hQOqlw40+pseXmRaa6uKqrFnLdppwi6hC82yHDnxB6rlWpn2C895C8b1UaFp+t3yN1KCImL5aU8a3LGqtJUAS2g99FREBQagcx3S3JAC8D/W+2n3Yo+h8xM7g6qb3lGTFqhYXuY0hfbYUHfSNCtqDcyJsnAHt/5n1pDYBFt257ukmFESTt6smTePsdysanRMy3DWBFRx0gn0i2vowlFmi7QRQgR9hdI4O/0SXHrKavm/dTynDF+nKKEd5nSl/USWsFm+5FRpirf2QznOQRfmzrny+woL0oXLR74R01KsSuV7qkJtx5V5jVGIJ912EXcZ9ouMv0mmxDJrgCTHC+nuF/t3LRSLBoRLKvoFNS/11Okz64+zTqVGy7lTt/2bxL2UsVtuPqerAwTe2r5wIY0r+r0VMMtqmKt9GFuzM8U5DLzzXkQHKPgUplNmgu9sSjJPHbeCSBXiVKSxm4VEgSUt3+8qZaOnCjQNAljxiU5fXyTC9wFfZDxOuHQy+LqZm4XYTOeBFbwjJWLucHGtiloEidL5RPiZi8JcScrXiAa4PJeqXwcVh2XwLAwT1ISnYyyO6nPkvjf1TTMX/5t02J1sF7b2XhI4IC/L59F0r1O/+fZwXBcsV3D1LYnZJVJqx1DgE/dEuWb5ABrmraU/Nks1vR70RbhdtZumdHsed+GazgRACUo7ZpFhJMqtrIIqt5QYTpucdkRr/vQxBDsg7cCr9VM4ZfOKuL2w3suTEinna1+OB3Nuo7Aw22wx3Og+U3G4YyHyZofbp9opuf3LQeI1bpIs8m8HVKsYTEj2JjhmUGArM34DC7nQO0xdnI3/hQf0v5vgXHZyrW7WmLg0jA7qS65Tcpo7QrxH/VR5mALL8tiZdyyeNCGDGvzy2ADVbiYLt1TWXUCEEgFKKepNZGL5x7ZWKvfgLBwnt6t1wmpjTmQbLiBdOi7dHATE9okLfcJyGHuX0L/Qj828pC+VBWd9HBz4CrrPCWIYWs0R6UNAoiXqs1kKiztvcYj0FBv6v8LTA0qPvs5hfoaekE7/lh728HbfGH0t8bRIXzzoWddW+zUA1xq/987SH1AoYoLOu3iWEQa/rw8aKSGSXHhgqF+SbL9OvUbj0Kcjk6NvyZreak8/l2lysj5aKqdvyCey0EgCITfV24wQawXhe4VdYWaaMhv/zYue/i6Tz8nYntgqgs1OWNhnIynCFMbX6g8WzigbX/V0EIUyAJC8IWmsv1E9SuMLApk4cCAxm6AC9Bxxt2eLja4vHsrIoQ2dFZpkNzJAftdfh9CDKU/5peX7SslwY6SGmCYE6LBRCnCtWVF58HOXz3loadF5RP6JekSp5rAYmcA3Ya+pXAwQ8SMqKfLVpxog1MPuiTYdXuQveXDivxxis+Iz/gDTf7Lsgv+DyQ8Qe9a16R1V9Lzt8cCeNC2JBYMUQi65yeABvUIYjkUr/1ZKTg3l1A4KZ+FxbwzztDOpPl0D4cKRx/9idm2JlVI+HJOx5JAFQN4UTF2De8/Tf3Nhv8rSSyajm+2pNzGkf/b6eon03SR5g7VxUixYbVSZrGQRSZn6cve4+0MtzyA9Hy/PlgKFeWZ4AQtlGCvyC7UwooQlXUiR+HwvUXx41vbPjGq0z+l52OXawS3fiekmSsHWXGIvF7M6CS2sh/C4X6gI9TwGtaCztcD3QYU9d+pT2znlMRzZEJcGbqteq0ylJ/ObOLXm1HD+su71aoA5G8u+J8hlCUJqngSv/YXPCUGCLQnOe0XWjwJumcWKvvZdbnylfym1KiKYeCUWFHc2u0IBMJZMFPVxJPU9wHGfRC0jbjjbucD/iShx8VBb1F/eVZ49GWdXcpL1/08NvvSaMHRqfOdAu2Rq23Bu42zpk3JTt3jKL75Q9Q5phXrTe6JZLQPeZcvE0rW1rBzIh+/cCaTLT6fYkLZ1jnUDNPAaVr1ZCI2tmYPaUWOOYmi2HykF2efZeEVh8UDNV1zsvznAblcBNVdcuWCQGHEwL7LWVsFhjkDwK/hh8mjMPMXe0iU0Hm3NyZFCn3zjNs/qJXI+Rqw7B9mOsq0C2vUcvLEvbDjeQtxjcUvTwt2pYsXeGgxnQJKU/Db/hXv2zvql63cakeVaqiAQPjkljwq2M6PcHX2wjAIRBGLMEXFALx06dyybSp/uyAg2/YD5cZYD+64t4Wtg5PzINtm9phQia0rXbZA2eWAOE3cOBV1gkDwv8G59rxwCPluZ4hwtu69cMo5QtuZmjv58OasMf6cs3PGSx0SggDGB5iuEiQNfVQWbEkj5sQVslg6ywVYdMDC0Z/CAqwY4b8GUIj14ZfOgYisK22h+fN2Lqc0+88gOphsxFDsBAajk6SjqdvqFqY0fc1RA+sZXELzAAT5zs1cwQVMczfJVKAbUiZ1mkXbpuocqxVTPQBWuD4agm8tZf5W4/gyqo8HXJwoHpUBYA6suNyoulbBV4EDnnEWjN+U+8cuaGdtJ9cwYVO4rDX8wrBKizAKznxjAujQ6kUOcBsiI5TtqTyIVouqcShGhh5vhlUYFIeoM562r6V+tFw1S10jKISkoymvKZhQwIuhyMtDjeAzr3XqHMN5xMgK9i1dfBygNGL2wZ++5bNC1rVw5j+g2asoAGqKazXcaSPv0TQrMcnzpJfPdEmYqZ2M7fv7J9pXPIwFrzNNQNsofkxh+f5wB0OBtmP2iMXYDZ0RUcRYegNa//dgOQQwK8th8iGAPw3t+rhQvu7N4Edve/jn2eMNR9NCUJU51+UjI0sM7qOHnNyIwinTblNpYZvSNF2GkiZPj4e9OViIQgbX/Kw6HVGWmX/KezvjdxZlfCHD/kIcvhsubXd9loHdvCSrQJDAJ2kDMtGpSPnM2JtloC/HPP4GT1ffZkbUGjBwBmTbx8b2NEV4e19Xds4pZhpf4WWQKNcBrXacxYYDL7BSF7fgSFUWRwxG9s6YssWn9qHsf9mpJaBtcC0wFXQKcFFaQlrNjqoxq5OEfJob6wFlqWN5umsRRItpSa8jpohyORMYIho2AcpgRo7n7ll747HwPQqccxMPxhCrDSAspShhfNG5XyhT0+7PCuIiKmnYJW1aWfc7Kxx7AOwR/Su86v21cEphhN9apI2SAU0YZwxHTCqKY3dUwfSxfdL4OZD+KCNmxAsJ0GDL4Gy+bkd87Cmp+eTuXyveJ9KgwMIQ19DxTd0SlrQT/bJcgeGp28TcCrwz5lb7EDHT5s0JJ5UV5XHBnmiuMFMC9Gd7SnASs2qVANeaUFr6zR+a5GTXeTfZfUc3fHG7CzJVjWOMLjI6rP2ko/pJGNpVA773AjBHr+YBzUWgI5TplERBmjU1WV3rp5qqAJCjxECxJgWiS5OiFBaDnjCzeIJWyOLY/0IkeC/pbAWUKJoJUsjOlZ5+Xg01Za4osCoUsCrVWMBB5KaQX9iEDdP6MlwItn40iQKskX0M1QP02f1bPiLpxKYDsJWTQzOOeSJjhKp7dDGeuTtYhMTsdHVf4CiHeQSN+UISDHVPl8ChCJn3fa2Hcw1s2OV37lAHdUK3/+DrvWNqPDYPnICOrJBP2MQLE3MJYmnZpaNBcDT81Jx6spTcrHothfi2lsUvFM5W+mysZv9ir0+3n7RWQdsra+4qq9zcx0oZpFy4wBcnSoC+NG+K5vyRB18txHDy8MI1UG9JJC1DNuAX7dtkno2cIVWK3WzF/t1ur5kj3AGoD3sDvJQCljogiCVM2wX9rxFKmf0oF7DQbz38AXxDqKltlBxOUFUlRfxNewdLPhAIemJ9d5iLlpa3vBgo9j2lAopQ1zNNE+BbHCTRiHiVditVWB89uvd/df/Hur5AhmNnZr9EifgsCnPUr9/6PAUK6e6V0J8bOzz7NOCU82r2yr3IRbL8VSH9FcEB8Se3AfJ7F10oY18yQ7mHTn4XlBad9tiQCE8XEneFfi5Eo9AgGO3aXaa4jnBJOcXUKAnvyDrWnhyC2my5RZxa4it/R1ivTSWcARmDyRwVu3Xg66TQqtuem/9NtZJZOdRZg1INHJuqOaoz6DnrY5JGpz5BE0yLQ2FC6TvoVope6N58vf2m28XVxsuXbVwwoVQ9xnDbeWOGktL6eOkw0y++VerKi0AE6o2FASoURV7Xy9Cj9q3sqQLu0/Iyi7eVwepzL7HmxEZGHDyNObwqhUOQZdIPeJnOD+PTUk+AFc1j86bX6/4Uqez0oIddExzpplz8MkQTjNI205mfOVYu0E/K3yUryKkA5ERM2lD8D88JAQHDg3PMpax/qkUDPCQigiV9hrdJs2FSIca8z6+dH41iV85z3/m/+gCDa/LnEmNrrw53QviFn1mF0oWfRa+/AJX+9QgTVBtyz//854MBCmMWyHS39uu802bSW1HuSuWBHqKyp3/X/MnJA7eCrGOmHUxBML2r4U8AqfzOXSYpJYKmK/kGhBlQn7CmsTaQhnQyFimlYYclyxdf3+qGDtG0MsLVLTKbm0aLy0BqXGz6aBQRKCUTIWsHN1pEsO1h3WPU4SEXL11QVUckX3qUTvf8moE+UuWXy82E2GZR4K9sdgV4lkG9pDeTWMBqXoEJDMpFBvn/BQ34ZlZKamnn/n0QA7cu59SeuzsJUrUnxtmbkrye0+KjX2ymZApc5Xoxn0uguaRWPnAFTLSgTn4YY9xbOLP4QMHte1ucExs40XKlSeJCLYiQFOJjTA9SW7gMb1LNaulQSt4T9RG4Jsy7+zoE+3g8tBxdXaX2LuuyHik2g/AdFdkV9IdZbhO68B4Nwd/DPIwbT81p/gPXOoi+5DM25xbgGF384jORBTwEnmk4RK0TY7kVfSm/FrBh/u94vrqkYe97Yq4KSSfltd7rX+CeTsVqPXnisfAWnNjI4TOitUwhjO98M6Kt83BPJqmQHDWv6tLHfqH9d8UruYLmgufyO+rp5TGPCV8gEUKh9Q3xg5loIbvgQCzKFQEAHGFPQ7dMZyX/piUPwcZZmf/tSswp+sXaxIp9xNW9S5fZgz3p77iIqaRWF30UfX4kL9xnM7t/xsJczr9nByc6Rk/tbxdDQyLIi+9gSCemvslUBY+c7BXx1cy5kEeeeh5bKyu2iBGcWCK2dJ7f3NNqSwuHxLqDgyDIqTU08w//1REL/tY9LH8/VCdPsrfBNtypa7bqtttXfOMXP4qrfBj85fqIoTj8eMf2A/xLEyy5DUWD7VXdhyQJP7o/dNpIh3s6MsC3KC1dVrT0b5Bd3K5h/JZ14bswC/kvKgLSvPlnBVeh5qikUO1Xkp3nZMZYaITw2nGtRyTna3O4D/0Ijn3fZ8yKySl5w2x78pekK52wosYuSSbgoevJr4scOheSwt6WiDsMFMpGm6Qe8Y9VYAcID8dKHptwN4xl1pWO+nsJSRIrMbLXsZ+U93arrLSg+EXe9YEqoyyjICJqH3rV3IQobWT/PChWz4kBIiBFTUA/jfHauoEp2e8QhuRcxxJ41PKdpkL0+MpUDfTlKYeeAg3oFEfwG9N3Z2+x+mTe9rlowgrC47nCiRrz6/B0TRUti8kk3lhzkh9dLE0VWeoveevP4uzCACiDEf8dAqynQ53Y9Pux+Rmsyd6IFUGaT02lfcoCFWqn4sudJVgtFvkNWIuIoEiFmx+dLVyqk4vo/Pq+jpvEilCfIOIqePK+tN9LACRNQMCMdAt4p0svpo/7UeisAz05vbWs2By5qL98AoXjTmOhlFJ5wwct/ibKH7qyH5Synw9Aq1cL9HfoE+Bpkgd1/avi5EHvhRdV4eBP90a74KxUscnlCmmrh1gy1BuJMlLGQd/6ObFdpD67KvM04uVbTMZi4g+gsycVzmMwv5Ze5oFi6m4LvZLpl0x4iI2GppSzN/4AaH8aYXbDvcCETdwz5zh4SatXQyXnuv579vRMqUBKZwJNyb/BPbYb1c0IdbN/i2oqdTgGVKb8z9kbZiZ0WvdBn4/v15E+RAvT/7hMEtnVJEJf/d4rGxry0J36f6S3X04G9QbgmJOXpoPcnOiB0i1YbpeFbZwQXsGhfONUshIjhoP2zA1SvaYgMk/v/kZgZJmN2jWQ9B6wDuiNwRptI/IxskfQ1910Bhx9Co2uAli4uGOj06iVJ50zT4YKgCG1cpJXO1uQ37/oWOjtezn2toUoqPWVJ+r1mMa9usagGzB8SPj07OwL4kvhTOASkvAlKBBXVgxm41kGqFS8DX6yHR+JWVLBdNY3RwL1Mzhs8LOvTq1x52jrTpboue8Yi3N1gek8AEGYuY/qo5ZRtWkTSTB5x4rT48deM3w1bFz30u4AkkM9mNzTr1qGqU28Mq90xLf5fgZs8EyH/25VntGxa18usGLUswtZbXSRCARa8582NB1ls8+M+TzpclqQ1RwY8qjnKHRHOw9T6jwVrTrULFdOtei/atPK4+1WgMlSTUh93xSL/C++yPPtBrqPS22Qz3NnA8O7WVMpXf/b1nHyP/YA5resTKl2KA7P805EsB4IQO4WRDHF2K+lu3egxshv7gh6D+2jYssx+vn/wIvQd7pthE+ZiEfJt8vkZY4xMDNhzelQUdB5hKQJQ9lADx330SX+2uSbcWxc8pCyvyhQb/fczmXPua7MSdNXgmR7Lgh3E63JXjvp9NaSo7hDDKAdG/XTJVE8Xh4jnX0rw6cYmKMbKOjoKkk6hjJuW7Od5JgPEF1qdLKiN2Iht8p2i1K5kt2CGzk9xe9furB3qAZ2DxZDOea3r9EPo9Lckl2SU6UJYgVBYzRkfn/O0EO5vdeUgDLGgSnHAKoF6Hcj1o6qMzyCiG4WHobGqlFZTagcBsrAy38H9thZ3i1Byjj2AFOBzczLdCBZokholOlXny0ZtKaZUjLjnCJ6vrSxRKLCj198BLlS0qZ0qNWP3I4HzN07u7iP3H8h6KqX3ILT7yE/yInht7Ademya1OttXe6VKplyf2KIp9fjxe8b2sun47+Jlq4MUVvCcz+TbInigYiEbDBr8uIPpmVEJHTmiqyHXkj8rbK/54TR54MGH0U6L8FdU7qCJny0NlY7uqxkiJdDofOXHGRPZdzfsKKFcVHoQ2v4Kfjoo3xgRw0td9mJQJ0EQeSBNd3PiG3O+5VfhTSWw5Q6q2pbDB+y6zgljYzM1U8rtH/9nzDqKZixLiKLJLFaEG6X2OCr7/ENjbm3ZC84ctRNPn848epvm5ZPQKcHgFiNlmq6P1x0e3RaB5CqSZ0U3KQy/6jrVbqJ1tJhJw45uRzVV/KeZ69x9HQUOeSvGBNYTu2c5OXl+UIk1Ul3JuQoobl/3kIZd1V47RZVlVI8uKLUUYWeSC3dpSpH15w3D6ZDNAyCNLaNiTfetvtYEQRf+n456evxiQrQehoIRZgyFr8w9HVcQdU02RJNazF//DHcAZicx3jrWcbBSUQ2J4VJDUEYWdec3OXsr1fV7uMov62CoVQqBK3yhQPPXvdRlPuZ0qr5N0m5wHCcurHZUBWZobPhGs1U5Sdex+tK1AMABMoZxtwzL1wEcD6JP6KY8/YJKF3ziYiqwNCDBUeX5BCL+RQ21td2zJ54YTY9/hK2K1iRrCfuZyltl90PBHMdwCPICtzm0IPrCaP3HFqd7yd16+Fw7IGpfM3/chm1KO2pia18mumNFIq3qd7+SuN1tDLaDLueiu6cNJcDY6JAkNMaCSNU81d/QVw1PB0IYp4JGrps+3TPXMN3VlsVGMZ5RQNF1fPOHMcEfhnmJQQoOCJ9z4uX9ltHu22VR8h3GsuTnycxI1PBUpzauqY1jljrwdwKJI8PnsZUFB8d3GXrPkpj+wgKL1Yrxhw+YBASJH2cUyzsma1EoUsC55WFJQ3zur8tRz3weMnk9yApb+YZoAIkxAz8ILyKXYG3UXAlGMM888+1zRSdiCtLcNk/mTp3QjWqVQ8cxK/uaxMgxVQkCx4fyZFwL4OdDEZRy1tsnW9gojiskauS+0MkYH4zBubOPZhiKLTRWL9a3cmwCjTSP4TPmD93HtX0l4oXZE4CBcwXSaQwStNo/ctQyM48EhM1pkLyXCkS9MvMt2oFuxffguoC/OTtErC6zIyrtSCdPWr4gfw07CzzhRzGmaoyfANTymlthXWzZ1RNdL0c8hejp+onWKfuY6ydroItEemXJBYvoFS0kpRCj+MkQOTx7Wnq/TBLTNyFLEl95WvQDGg6QCyOfOBuOeHCXrpiBk23yj9jxuajZA/dWiqIlyN4GhBdgalu90jQXnP2adnCIXOp7rZwV0KHXbA+B18+mJOdW0ydd1IUXRCkh7JksaPqoFdnpE4+E16or/H7WbbigQuWSEbD4mvrMNFxwQHxte4/xsC2Ih00rYiWprvoqmnqrxzHNoi8WcTyNiqqSM7+ozJ1qlBmefF3fUIKZOdRbyr5cv7UURZvb5NFMBqM70q26qjkI/KotvlGCkgyAzY82FVJy0N5P8taulyQKa+VLpcyteTSVrSDJcDmMgJmBFDCqVmh6Zu28BzmFNgHkQEJMRGLvBa7fAZCi1KmzV5dC8cef4zqfMrLnFDO+Quruf7tjVI/3EUDYzqQZrgzlFxr4LFwJp4d7l9b5hf/t87DwPkD2rRnOIi77K/XN2/9YiSHVGnXnMIde3jtcgq741IXnz7lhLXGzbiLP80qr58XVLPhsgAgE2qXRYH0YqURhESrt4TCFhry4oMSpdDIRDjJ/MpMwB1/emrqUJv1MPqW5rQhq5GWNTQCNIpsrA/0OvkA8cUimAk5us3zIxN+2MfiFtD9TckGVJma5h3Adz6dkF6kezIwD6veGzjS5mzwuZ1ckYAuCgmhUzHLkeFtZ3SXUOvmlhHEr0MDpv4Tp1Zx9da6m/RU9vPaxAe1jP9CdDDHnaKPsUx2g5WtYtdubxs0Q4NhfluPCvcV+9ZO96Bk+wfNdrIJygh9AeHq27AXT/tepmEC3c04v1BEXjYtFQwaitU7SNiMvX4LMdOGOSEA/TUp/ZmkuUzwC18jSNt7VAO09STBJVE4G3q158PbnuwfI28LmayYIhP9lMxZDcS7e/MLzB7YnkG+B/zrSSOghRmwmOrAWG4mF2igSGato50Pp3Tzi9ND5XwORm3at4gXtONJEyQpgNnROCIzb0VevTdP+wIZBVadlmvL9IqxnkgwxGZQu5oBXef8x07CeBKOin77QkuuUSh5TL5u73i2k6JfYJyVwgsuObO6xYaMN+VHFn2P063e//tzYzRXC7aZlOKhkQElKSqdFMS4fTuFnWvgaVOSjhJi0RDT3OTOc9efW/m1ODfJEQ4vsrJTesgPi4JUd1q2M/FB0EVHrkLJxWyTFPwx8AqKDg/zEXKVZTS8xCixAFIwHNWDiYPTkIKLp7s3Z0cekSGLNE9xSXpiYGnX3JwCfTZqnRL/oLv7xNvbdn3xm45S3LHq7sTZVTy8kWFlRLpK0bWAFhlj6fCJGujkCvoJS8Fl2zpgpEca2awa5vrQFkZ4WFP2X3lmG5QadOrZA+A5ry+NW2Yl8sOLtW8YCjZXyYtq1M3fe5BFfH4qalLLMP9IaLi5tPDZ3hXtFWgDGe1GWregwI/5TUq2bl25tobt/Yo2wVfJz4IPamYJDH82UGgcEhW+tW39TNU/A9lb7//e1OWgdr1CK0FyhlxgTsNFY6LtcPDc8097yV5WXPC/370qAQzy1NlBAH++kj2P7bhXX9ti7mybg4918qqd3mtS1wwFoGpa6Zjp+DQ0F+uH/8gmqfPH0mjrrrJtxzLeselqSgcerT9OnJGxh62oPLhCU9pjGlzh/Dhi9iynBz3vH4c7muGkVZR6EIpqwENF+ij88hw/qTlu1VzIx2w/DrpggNWxcEMf/4pvjT1TQhQI3cp5grhulBviKtIVUpNTzRC2MLAUnD0bKNQ/5YbVu/oyCUjCaepDIyfYkaVE1makMpyMQO7YUDgJfbggTxY7A69PCO+jC3/LBXowwbnFYiF0nnwaAw6x24ob1trV10YD6Ips2gOTSXZy5bgSNhOja1kMqUVzCh3nK1Ti3bkWlBjsJqLNS2suqMxzkJGbHmva86NowaqUsEDXhKVOxC/O4XNrvPI/Ok70qXKvL9zqMF18MMQeMvUHiHwzGFI/D+UcMR3VFLZNBXsEYqCvYF0casocCawuCJVsoJoHHC1arz5yLs3Qtfx6K/DKHCGD9ca8hwANx3CQ+9Re2IhiXclUiGLXc4wYXN0uvOT3bNVLcBNa8JvmcKyJATg4QHvyym18x1bHAHaL+dCucNugD+TRBA/MTWaOtNg9eL5CVqQ/WLtcU6lnExao0ibFO2s/JXWDspCemh8ST07lpHG7ifb62xZJfRdeAeD3Sx/q0EFuk9VwYgnEbTzXA1s1qv7JOwnOTmMchRIjmNrX+Z/9PKmpd5KHjRxoa76DX7KOud7RVhrQVLV/U1yPLpj1VcncG8WvMC53qmeX78CN52scCbvZ/91Km5IXc4DNc2ugzw1+PhkjH7VrnnjaoI12naXfGc28Ve3y202VxyWmlwZaS1u6Nu2fX9Dsw/UcstCUxCNx+gbcNH4io983+jsVif4blwnoxf7jZL4xo4jpamG+4PqXd2RWz532+Bj5h0uQsSVEIERydfWS0hnN9qZghP09BMN4T8BabNFJId1zeOS2Tz3BZztwk47CJqw7nDJiss2J1eyYPqCRTfyIVfW/FIYjTLv+WChNu5+jQHVsTsLw8KDE+iK4KLfrCbhxuaH6h4JP6AYFGLsnZkOdOlOM7H9Td2KcOhuooZZHix6snkhpOV3JZwiNVRcmCPJRlb4vUHJc+ca378ekvbK0PN+/qbKUl3etKNSUHVB30IXIfTgkt6KHg07bZ20VOflfgMby5MjQvVgoerbw3lTMU+Tcjt7Q7JpxOK/6lvr1WmqBoNUfZeQLRQyz1xFPCJZe4h6oFLJbhdgtG+ZV8RWQVG1S1v6ZIii6nURassIq9LQlJGXzFy8mYMqcMS/EPvynk8fB/b+EkiC9Hlp3nhcn6ADvBXN5ltXTrRhD5tyDuLLr3pjL/dCpNEPMB4u2FtCx+zuF4FhSYuEdlX+H8YwCfiMVrA+Ao4wgxW9VWizS4B8cHEpGvk9si2kKGLeP1BTLiILI1IW+mzpeNSl0HSoP5pC1A6zzZv1TzrZ+MAgRUvKKIdIVmBRXcHozy6tQZXHwNO5+2UzPx7rxZR7o/3ZHm/E6rpeg0qbMn2I/UkAO85GX2mTmHWudXdBv6JxPZBm6J1yQ5SMYmB9PabomrOHhvmea7y9wG9oC5rZW8udUxzPJ9dbZDG5tBcfaWIYApUMWzGc9qMUAIZgtX0SiOznHFriV8CFxaRRWcVwEmpUaFrW14eTbaxdKN3V8D1dScdABFmyNo8m3AHqc86RkO58AaKCJrLyq2pzseFavgcSza2wA590dEiQMiCmFDvIP01wGeVHD8KvwGRn0dNNbbgN7XugAFjfAc4Qa6omJ3Pjh6yU324E3xWVgfp3ZMA9/eNmAC0K5BL6SHH1xI1HzNpgK8MwU1MkjWlAGnEfBHPgov7nMtD3fmjmgzhv0XP3UeMr2DMNI0Cz6YniDNEwTLRVjW9iZpCAE2ya8ZFXpPg/g4inV0RS53RaLQCL/vZbNz3ZAMNlCSzYxz8+DcYTbLce7uzxdFcThfoc9Hr2atit+tQTnP8rdCXS4wcKswnRxJ/Z1vnY5hSfqQG9m//LVmluk8bfRV3eP1g3vs5bvLu9xoEu7rRhNsmr/s/A1HZ4vjHi/FYW7srCKe7A+VZwH4vISYElmlY1895lrWHEeLsgzeYFvQbDTXrfADTWsjxmLvGv+d9/pNUm8+LuQjo6o0qs3zWwsOhbHaNFibeXGLkWo3IH7OSGrxfdpX61ZZvxyXc2eId+4N8sbrY1/Prbq6TP5q7b7wNDPtmbz1vqKfxeKD4ikHv1l8dI9GfEeridfDXRXMq3Cp5s0vb3LbSp3xq0dmUoTGGO/MTBw3KyImcpJemaD3roxZ3W43xL4JvCwOl1QsRFEowy3jv0EkRayQh262wkEdadLrX8k324d2TyZQp5/I8RpsZMYBaOQJ76RUeIohpoJci6G2Sbh1gziyg8LCY/bkZgYssus+6GdYpMauxhWu54JOh+hW+8k69QgQOq3a8pC7z+jzKzNuATBkjjKXJ91pNbxIKzU7g2NfKaS+8ldzF8i83fTMUVSyqhaIgT8fm2KK6iW0PsesY3trtVPgq79AoAGJma5qw3IimCaQI8KfJ3cWD7rebvGjcW0o5ahNc54SjMOmwO9VBJHmV/G9zgNvzUZe8uzHd9fY0nMqp9+VtB8T44JlkwHBffuagpigTd/M0xFGDXjx0KOkA0ysdR/XEAvnJnauKyKOrRsTdWXfk2kDCPR8N/T1cjW98BcWxuCptpYOagxrEyjMWutIVWOckZ9xEmTHBLcsXRFdjGaG4Zl+9+Xyp5wmOLsMfstKwQym7RV4md0U9tKB8aHbsNtKti2DNjYOKsDkwsX3vMBRXXBsGnaorn8mijRrbIHKFjMtNA9H2O9iUkD0DWtg7c0qlu4JlI+Zi9Je8jZEHJ4KnvUTQFtMj01OBnX+PXIEe7vNxfjDqtcfInSwiZNYjOUzpCWpocVx7SxoBzjm6BCQDAJdg3+GICfEiJOwl+CHyC/qk8CG5MAjN+TO50cbFm+izm+pzYz4zWdz0LqlI/bWq4RnuTYy9KmuGLJWMILzVycig6v8KPKcRWr7ewf3wHsqs7uEubzFge6X8diqvXsbUmCWOan7EJbu3dSY/CLRAJeaOWejToeKFuuF0ufzVIybiongMKvyS7cD6lEcqtMr5FTZTVe0YI6dAsEuDrJsUgkh99bHl242xcnXFpAl8uIloYq6wR9snOhimvsMLyiNRFweoFhL/eycgp43fVKHCsw9WnNnWQXH5C87G6LL+gAmBcH4J79FGtVppJBXNQ2Mp/RXOwyE7oRypWrx6QLXUrW7lVSi8aIukcpffiMlZYrgHUQkWYu5WR/vxvj1h0Tmh9FQggD2Se5avZKGxbuYeUZWJF/Yhp01XSFldjiHK9Gr+JqhWRunI+qCa7cuSGRygsKMQ2q+InSYOfP5gCLi5CGn+fmmlX14MRZ+1OwNzlbiWG5IAHOLi4Pem+3LIjAEBLP2/x5VNwhZN8huNnJcwITa0lJ1NW+4ihsYgwBkR+RVDomk9D20YftqDdVIfRecOcGYcXMz2BCsm3ExRXferpWPHecCBCX66CF9dZtq5zuu72KUAmZ/wNqVJ+G2mzOisb1k8OWkqxVujur+MvJDvRmtcq/IaweO7pQ2rjcz+Ld9o8CE3G3slN0ZIauLgPtDJCVQwdPep9D1cVlK0VWq2L9EMvrWn5H3JDWASKw2R7biyM5uja0FDE4vmvxbBZrC6Eb5RhM1duKEvI/nT9gm5lQXRjdpTMFcqZd8Zj/cQV/b/bbJmeL7OaIZFE16J2GyxszGnji8Vi4AflXYLlXdbXgXhZt1kmESi6UKepOAjhSbaYXtxjeXP9YLM+uHsnNGaImBuOXWCsZjgfqyuHuDEqtEsTIiCL77NafPhc1iCZBu1nVrSzrTD6FSA6zTlExFTltL+aTlAr2PVeagArO1YebRLxhXnY91dgtQXmdht2bdW6oiJwxWUbWADGNMbWFDDVjJOSZAvgydNpWSjAoWD5pyHvHO5wREhFyWKSBs5Od8h4LZpXGhrQv8MzIQ1M310CDyUJnQNW12sQ2HghdnRw36IXlO2GsSYzpJD6uZU0/ozno9UHnGQUdDAkYvKZjZPN/+OCB7HXFt57lUj2CU2ZmtflmdQR5xc971qeEYuYeu4judWUikpFZeAO2wLIYIaZCb9CVq020qvBdo8yZv3eO5LVfNMjQtwYUDhfbjb/Sm6Y6KfUhU2ScOvuHCdt/eNGJ8cnIV7tK+h79YmKEgK2UoSR+Ba0wknBRN0fDaltVy5bIyaNAuYGvbuLZZvEers7st5Er15hfvNZN3dg5dGn0zsXl8vuVJcb31CVmnlG1/sRyHB/7xxK1vu2NmApqJtpquMGJBg9fEW/b108EygQiL7jYWVUI2vd9O2nU4xxMu0+CYSTnbqzQoWB0g5xIzxQIxwHoA9mdAEND9YZ5Vos468gaVV+zXC+0JKLD+7nnGUr7YqValBaQId9Az3LkaJCf5ZevhbtmO82DVlaMei/Yli3EPzUEcj35CTv4Lqw0DMdWNS7KJho6dzArGu6MQt9/XZ3PCUGsQiJTQ1NcNxzxdOXDTj993A8D4SpqbRhbeYyGYZPDiBgI2WGGHjreZgmueiYg1KUl9U05n+DjVOzjh3cxA19m2fOtHHqLZ33WpZQ5XSkaXZlkINjvaAS24aX3ka1fQu0D8ab0jkW3FDvo+fJnY7ycDV+pMWEmd1q2b3vBnepjSW/rn0lIRvexPIgTx9CQ6+wK0ZzYoF1fnZJbtA8tvkhfTMqFVkU0KY3nmZUT6KKMTeLOcgRUWhYv4H3kzPxo+cgwj+D04uNL2fMn/I8rfW+FceaTkjJiJEQgmMuSRTEOj8jdWpOBGTDaOM81HIclMiN7DfoIDwvxyBjfo2gjHe9FyUW69kpCTwmC5Xt+CDzP5aom15Td169W9gO0/w80IqpJ+xluQX43AjiIdeUgI1Df8XV5cNttK5R7yitXAvsktgMs+fQNco+HJ10l8ada1vFX4lctULEiUq3Gx8QaPh0/UGeiBhbcOjNo7nyEIvpbfDiqtFYpGxpOmnae1PHmro23vzUGYztKl9Asu47db3fhhtyue/aEabpeSGBT2HDosIPfoHO5xQqcFz1Yhwgf6M5TUTCaNCN5u4MNQCxPBEFr8enk68h63T2Qya5CzKS8bIQwQ/hLQcpuZHB8biOej0eveM+Pnv14admvnOfVdpu9rScrmg2E4BNRjZTsKrgWrQXX7E3fMVhv1t9wuXhkkJhZ+oDopkRoxJH4++TonPgg4V2l8soHUd/898S/KwOIZiWpEufajgfwPLRNXuxAyACC+sDF4rRi9lC/kaiHTNOLFte5FuwxjlpsWbOVd1qcBDv3C+nXMwzuec/tg9dV8cSgn3L4oNq6QADC9+yN30tjbLvGxIMecoU3N+Ys2L9m5mIbT7dgob9OS5+s5bNxPdVhg+AsCVtfjPwG+EsBOJebC5oRG0+ZDqkEFm8QJ7nj2scFS/ewbujhg+2Mtqa/ALi6syphWfPWuK0/OGv4Mknzt0KkwMWc6X/RbCpXYQM7TzZe/ygInQ2vq1nirHCoIfRz/o7DM7WnlxuCxuqXXH+NCOkE69kK3xN9cQ+Qnu/wVOTMcjJfaSQYWAfV9aK19E5sVRh7R/H9FxG37EORC/wWf4lbCTbdxgRSiT/Ab7t3QtIwc/baBb1V8hWYYAW4LgAIYFC5xigRAki+HruNsaNbUQisL6A2/NWhd4CkcVwemQUpoNW6shhiwXHpA+BBekLU0+dmvenc0mbZSyyaqNPqyUedY9mS0GK96piGbJPvK6ewW85hoioeUILPo4Wh72K0EiPXPUwmLLU/BqnEuWuIjWAMhGg/zhmDiraDlT9JbYC8mtfWU0rFSJmIgOaRQgixScxIU+/lUimUSbC4tc1bpXgRWx48XDrbRCwKAKfTSQr523MNj3UH73LBQuZ4Dm8CqUGv5a4E7W1Bba7tI1Vazx7EKTpNGcLxgHsKxzuPmM+fI7Gq9Hdo9mKwxBa6w3CupKzoHrba2vNCa4lsbxrg85YtB6CZUKvfcqW5vlfg3s+/DopaheMIS5SbCziC84M1xucCK81lXtQ4q5gHV5N04gWHJ+nr9BP1OE54gGLTvwMUeCl5POKcc7tvoG/SausHINQWzBLcn4DepMB0DTaWr9vYRbBAvzCRbKVymvHOYC6RUj1JDOFlu/0LU4ogBTEtij7HhaQjG1Ijv3zAZSUNu9FNQdgXYloktzy9nxjxvIYubZ1RTTBP74MA4AHYE3ebl40vV3sS0Ah9FU4oxXtIajJAKJvWZvbiq5rgtTTMfLCwL8l4pBv9Df/FEuS66AUQs7AFo0gb7VyIWEkPw7b1QSDMRIZ/3ej94/MbZwIayIXSi5EVU5xmRyR0GBFWKJdhyqXwev8oDLR+R9QMwFWIRGSaiJA6N2bphWqY9oYln5Q7Fgchx+2/OLEfPIQohrl+LIXSR8JlZ+vUXoPz5izt8amEPMncsFMRhRnIv+qTEDrFSX/70WwXqee2dpKHUDYI0YcSH347QoHJ1vcVtI37sbCThVkkezvRFH2tDnYMEtLQ0pdQzCV9tQosY3w0C3yncZKOjgNIM+4DP/tjPXv/PNIYfOG+r0VaVAleaA81ES0hGcHwuOi8nThDwfu3fhPGkQOzoNVNhROvu/lb7RSFgLeeQVlcEiYBiJo+7ml1R0hOV5NT3gQCW6kThHepz+5R/41mwfq2ZvbhFjIUvFzJ74nWClr26YEsGnGV329IYuvAaZckmofrfsWYlL2IQ3bdMiSzwV2jpHWXcIouSDeRbIsFXn3ZkpNHpSsT7jgwtWJdRwqcLnb0nyxmjxbvoVIA6haQ+/j8WQMNBbQ98O3NKrztQQvjATi0J0+tx/ZJGrpXaSgt4bP/PyVAXfuCgLy8SnXPj4vYuWIIqxObGMDzalGpsdb2ok5SoMOLV2f1m/ec/7umZqTIUOly0sKsPNCPh9JQXhPEsaNSk92u4WvbP+HC9dhL34MdLKL3akxKDSfDrA2EkXJEKbugRQoP4JD6+kW5CL60v+tNFjK1Lqil3jgLLEyfCzSKrpHODfB9k18mm246CEPQLM9M9ko2ir7uovJWHYCwRIyI7HeQGkcxI4c0N2cecTZC3p4Xh64Vi3DADaXTH1aCVp9mF67eiJjFuV6lGmnnTpammHWlKxrcIrv72EhU7E44Mo8RSvbznwtTgR94uA21x9wZlB2Oy9CvIFN+1jSfFlCpnLuBMRh36QhcCv4HzbAmamK4JK6uegusty2up7DkCJOtnhTsPmUp4hmxsc8xUC5n9fcOHa2Wg6o8vo/OAnhJ9hxwGX0HK3YF+SoxxQRl/HWt2qitbM0fwTpFUPhFsbPGZYTjBuJpUiNMl9JlGV2SznMLTDqYG7Gvet6RehseIuzqhfD86vhIR8jSDT6Km4oGSPtc160S/oSlW0kR04O0Fu2sgIah8IC1MyKewvQ6hqULhW1HlW+Y8zqBvT4Nf5G2HBs3tm229mX7fn292mqi89wliZhvDffjU6JEbN+xi1uxs3sY2kBNIZhk8URa/XvfKn8g/ed0k7UtG/lw9nnWROoBh2cJKXEAzkY+HBNpxMMoZX8zjzvUwkEm/88o/1vepl1BD3RBDYb4dR2enJBtFuEp7QFDDZqlpnv0oNsLmHwb+XfKchxJWjeR0V8JU5HIzQCVy9jEt8Cm53GLCSx+tUw7qQ14h5RZZ6UxWN2hLGZkw/kjh/wjLHm85AyLxkGyhANg8+v6QEbEiWj2oJyizw9vmhBalvDWKyIMHW9XXcINxRkgtIGEvKbuTLAibnuGH8tm3H2VwDK29gl9oLJlfsz527p2U7hgCbMLueyx97sYkNpmM4Pz9KH5AQNr/KnSsGNYSEMSDR+kvydKenjLdL/wl3H+Bc6ZSKDUHdBQSOQs1CeBanb8hDUqtSa+RupAVgkCGbyqJk/DcjrVQmPcYEgE5pYFpj9QFJggylo4T+IVwyV86vsHUmk19U/i1Bqt89bXKfvrBGGH+zzXk9Rm985xrAmGHC7UeBt7hZ0IpOkrVSkWA4BQchIVdrIjS9pMaF/3PFZrvyJyfi7GDthmbFokLWBqSHMbFcgkikE9g+BDAwjx47h3Amji14S+2Jw+VdfypFAkN6P78grMwnHTcXnPbVmuDMHFy3Wad7xjDYERBy3mzmeiZz0mfxmDYKVC69Q90sNegFB2UeW49AzM84hNWw2qVQTg1BohjZAwYodL0P9x9kJv4LOmaBryDun42efJgz3b4aQz286Gw+g1c05PHYGhJH2FPI81pK4i1ljhNB4rKLrsedsXRUZaz21LG+vd48rmOA9bLbDkmcoWxak/P9KsM2eSBAYu9ifGijhCSkvxesxXCet/3lXJdR8XkTT8cqfZ+kmnZkLYI0+SCY5Wj91I99vWSW4IKmsGDpwgn22nSrnGRyLffcQxFR8MxhHZg9dHvlN38t//oh51KVmszo+yEa8gOFbXGwCiAjLxDF2jOt7CKqfRMsyX6bDf4DZSroWkzBmBjLu7Jhz+xbptlEQ7xu1lGlQgHMM33v0Z5CgRksWzZNift2ar+rfRmWbkGenWE7dJ7BKTnpi+gRp9VTKAURldPmwgPLb16JXsvloYdnowlTCHb/bu951GQ07ieJJKdkKEXUtOtC5rDVOr6mGWz6/8qtofbblYT48K6lLt8wqjjSbuC7QhV0Ev16Iug7Ke3DRrySnAA0rt6L5vPtvc6RuXdR/MimpKGU10Xcii9O2aZG9I2hgapnuhlkc+tLz9x5UEPIN5UhbYNeJMJFWkihJVTP0/cYQOakkEEs8pkhAHdi9RYOyL7AQFeYKsuQBJfD6rVaoIxijD7Ie1LgL/rAYqMZNlkmAKBuKkfdw3SSC1cBMGY7koga4KgQ+Rt2/xWKFYydX8Cl1eGEhJD2Lwdq+CsfFmsnlc912KaipvYqYz6kEERxUIrI+NQd2jI2YeioVHgh7a6ibiSYhxDzOsFvQ+scnhzpY4CJRbr+duarGBJ8izhcthFXXxj4dfm2yIt8fr2eV9bhlTd3keoVBTOdzFUB0nDPQsLCq8+FkbSRK3rHHXistD6Bto4OW1ZKL9If3XziwgsOqXQZBbNJXmJzr9zbP5V6+l0lhs24vXqTlu41TzgrMjGP57EUajVS2lf5kPbNvShhCvIvvJzt8lw94WCf0bFo5oaezpdlu3XjTf9l+SqCcqYNva13kVQX3RAFIEkS/edr/CL4Dd0tp44bIGj/xHYO1Ep5bcFb5wm1FYS4suQwEeSv8LwAqkrZf4SxKvfXWweDj57oV1ZqfuF2C5kTKmLRKINmvL9VZ792wWI2AMj5QEMMX2s9N1gS+2pRT7RWMASUzY8FoAs9CFFgKW91zoEHFqReY3jx9kHFxgsUxzuQWc+1CCw+wMTD+sJzwQ+y+3oQPx7wpFzaJjYdvRkPpSoF11vR/e3Vo2gduT2yP3KnenxBqR9vkqGwVVZJr91Te304dyBT++DcOly8dWq4qiYqdFBgAfLF2f7eCnEDlH7/t86LgboOMNLoQ8t5gIuocvIVp8BCZyN35P9h9vlvV9HP+btmEdEJnKZSfKUMN0MqXRcpAHqoO74+2ND8E5/TRku6sa0ncnbwkFPrnqOmHwZmpcTZ0gHVH1VXC+rI5b+SHyIBYr6pmmKL07EV24pjo/zwc+kOzyORiQ2fNEKiaBhEfskdjObD8AQ6LsZU4d01T1kUSHP7xWnTL7qMHY1aUvhvzl4rrFoNS61K8JVg2KRnA6Nn4DYiFKqn4fnu9PZCU6FjqCbcUVmHkECfsBAOry9s/AN+/PYWAmgrOXpmGdUjsIUui4I+wa4FLT9T78thHRgVq4FO9q4TJOu6abqXOK0+sy4RFqhfn4PD9MWpKngslEVDMMVWUp0GmrAs9HINTCKQkBe9laQQ3WWoPnsdzYswhNToGSjtCCCiPGQlEDPlBKvrgymEFZ3AfSteZuCcTeYu3UtVMuLX4nhXA7wX/eH4FY+yqSateFQ9+HJzIMJI2y1p+J1Tj9g33n16BhqRr+1+yHKnyp6miTMOoeTULnJ/9YuA9sx1Ig7UQrRBmEuB9EPNhzt3SKScjTy3pNTBCuXCvdqN8OAIGMl/OVsmf/5bMozNvs+pGDYoghT7ER1MNZhRX2KbwH5aoGJzM8PERNNw2DQIRtgd/vQYujrxep7YnzxiOBaEkXGRVhyfkMHw1UGy6GC1UQeGyF3q/daqy7MmEJO6NSaQE3hL/v/lRptQrugQjxsx838vW0DiMgq/8PD00HqcNsHZorL8YanBH0kBpMaq2Q9Pz3uWXfpUgbcbUUXpG5YQF+CME2Qs2JS4BLqpnhi3wI00PiXcfg3L+S7jOO0yKOOGDGOttFIqkW3JqDdUY7c3DsRdEnbLtFiP4UOllvHDPGwyReDPC9ny6QYEPNrtoTxuLcBTVOvC3idvezIPq/r2YwlZ9PjVPhv1qDtCAYstjtd1b+auON05oPwEoYTsUpFl+fPTozb3DPKNffSsQsJRbvk+MC0xyzCEEUC4NSG015JQnuK7CkMFvT8gdmeWsj8YkPmEtNzgwjvM2Iel9mIuWydoBbGwi5UMF2P0LkRv8J+yMLch0NQwbO97+bayLI9w39IDt7DGEsjPjCzgFBT4EVnoBdxqTSUvj1HpEvFJNWbkRLE8wsqCD4GSPssJhGvnrn42rl6EWKXvQVs1Z5vA/jxPej7tzmH32l7N+G4V2JR8tPfjAcKlCUdSxK3V8+MBbmasRIY+1BJhUsHznH5hb01Bn4m/5rZx7iKVPFiI90Y2iO6c43HBuDd9ukw0EjEg7KJ3ysAmL2p/mfS49VffJhjpBrHIpOCysrBSrUee8jmClszjZdv42ohRopGJfZnjsi/Sr5DwI6ztGv2W3Hy0mjqw5QwXJKcEERtetwzG27gplFYW8mUDuGcd9ems83sEauCdy2RqHK99ER4YgTVPXKhck7kupSv7EuXNxQCBJmWHsk0Yulh8fW3Dmz7+L7vZ3vcCHiDUBURUElkFqCBILXXG7BsRf+MYR9dUTZa5NioEOykujO2gzS1D76xp5CyEfSP3i4k2M0NsaqZnFTIC6opD2BfigiTeFApZ7lkhpEy+P0JqU8QU0tbBNCjJcoIqV6gXlH2PioWEDBStczFYtcwXj90zHK2aBh9fcsLdf3QpLcoKQhZNWY890DP928rdVZN3yGzyyLyC7tK4TA1H7nIIFIL7V5V/gAmFfzPHEucxnbPu5QmMDkskTcggfOt/uwFows7/wznDCo+7J4NuPPkY2EJwuCSuoZQEk96ap/xi65zOGtLvnz5NKdWCgZ2o6adeBEch48GxHVIUlAXiIQ1nL32X+5w0Z87Sy9Zrdxd9B4mOZaAvYYnxzNdRsaY12Hhu4O6ruDzfTZnmBF18/P1N3XhNZ7loONJO+XwFAz0Igy3HRGOy+Cpp9nxm5Iny0zrXyj4BvT/YOI906BQPo/Q5fvLwauparW7H6Ebcpam1SmqvjrvrPzgkmdwOdI2us4XhfjDf72/5UoKfUGwCknQRFLH9rTkR7SQJcxx56sOhDN5U/+mBsuBpWTy91HiVDhkHH2NLzNfiCkh3aGDlh3anz6cofAG/WN1PEZpAAvUcwpmmNVFVxow+3DtlXe0BvzC3Xysf3AvOcC3Vxo5nNwSrTBvopThgeTL9+nI5Aa39xYzvn8OtF2RwWC/JELg26BtDVDId9pG1a4Kdudztx2rFoODmoygE0nc+bkx6UYg8FKrlZ/Z0qElPPQOD8Po/+WmZAG6b/uYZ2Jn9AC+685LJAPR073YwfYfE7JGOM5E6Y00RIj5zdl8ZBwmWYLevJUjuXFSKOH74ygKxnh1Utbv8vmtYZRO5FKSA6fjWjHC/oNe+w7079X1bRICnqItVzetoNS8Avacu/m5UH3GAcxVUfuDt2NFYy6/LsdxOIEhAAcx9LrpbL5916LGcsCZiJLN9wkuw8XPDR7JTtoMY7LLDkCl9ulDLPnJnsTpR/7wwjzJ2rEYaX5Y0emHcmNl0/gU1O5wtgeOaVGM6c7+SDOCw/skw6Ij9Dv/0czh6HEaSDIjhqXkilxhFY2bOUG1g35WGphb3fnWH2Wx3C4wLSOMoeV1XWa3brKqTYQ0i2GwC2r/PWR7hH1cQy3Y+KOKqrKewgMuEjj0RR6ail7Rg3jrwcL/NT7XWsZXrWFl80tJ4++q3/VhldfweK9LxsGY1Wu9Wg/9RqaNYwpDVH9Ynp4C0P+te2k5Cw0MrJ/J327Nu3Y1lqR6fIOSVGzznWRhh22ZTLCXOZ1RRLgVemYCEBSQhHhYObaiTYmFcs9Y7xb8/AAJNgWEbInlM/tzuPc1uP7I8AiIX2Efr7vMeqPNHP8LE8O+oPdiL/dZZnhvvVfd3rq0WZQdyDTuGuXjRolSW04sVUXVBy9hKLHGpVuV5fkSJLc+8gp9ZlIXDL5JImVhD9qHu6SSLz9lPazdAJochkQLBUOZ6qIe86WRxDIHHxnOoJn8RD5cYZBb7pycuFMxjdPRNVyarH9SwPKXPwAC+4FxKInmo0wnhDaQeNzSDvxtqOJr4rcKiKMm2VvnoaQ/1BLunnBs0HpDhE7nW9G3TodohC4oNZURF4UEm3vDiXMOawkPnSpWxT7tjBnxuMim7xQpy7JbNGJj6Cg054uruGr2tFIqSNmnPC9PTB6UFngqs2P88CFIh7Oax70yBMfzEClnSEK5pSep0XTfZHNWFNz3yKdF/3sxpyO98978WlZPjqHauoD0Pvp0OzGTSliV6dhUi50yImr682tzUL32LxvCKcGkPwc2vRzYbhO78d+11oIMn0m2p3BwuW3TmMJIoOdK61crj1m4//3N5fHVH0rusc+UDvaWKvBLQtGEL08dfQn1sJT/KER6BLnvgmjliTtqHANk9sIHRms32vsH5jOmnFIbCouwFb2g8IEDRJBLnPyBWNN560/Khqmkbp+sxgZLc9Jb7PdbXwsToXWbBn7CfYEo4WaLhmHlXn3YOHOecNzYYKTmq2499UF80sIohv62nQn3OIC13HHPIAmLYYom1fvt3x7czNt/uKNUCwRA4wKu/L5xxcwaZRW3E1VYAgfQ6BGc9OrQq6dV9Sac4LTbU8Attozn8n/bZ7Je97U06Ua34+SKnfJuVBfLNOVtNbNi3OCTjOfQMGwAIag9mC6GUJY76FCFN4eVBIrKiZLfg2LQ6XM3KMWdz5XJ5u1rOz2/u7Cgi0E2UXAzbOGyqXaQvHpwvQaQCE46K7spR0BDzOj6biu+kD6PqYtHgdDya2bSpXEbJSOOQixEyeCu+dJBhOznJM6I9Hf8q2QfD0wGuXQ8AYyBoKUfO0nkbmfx2enhRY+XDrhke77I1XeXW0AmpJUqus8Nnoz1BoGxxtTZZqiQAUTKrS1PprzsLz9Ipqf+1PE7T2kRAbwEl8AePON5upCB+ZDxAbsZMLnhs9EjxRaDm3UiMoq+ZMp1aVZt1rL03iIgOd0kxNkBvkYK6DaTMdnzLxsvCVlaJH/cC0IZoMq2syoSM929eMbJcSknnIjbH4ncB9U4mgJevWi6BFJnXogd0jrKciubBjFM6D6ePWSdXgJvoH6WAOShSsuHmqxz830ZRgvXOqxPdTlm4z4ZWaV/kcZjghvriPpJOl9ilBPmfJsxl+SmYpcyzJu52hWjMyMgh0NBxlutcOHJMiRc7NsE7XxOv7Hs+eK9VrF0LkbGVEynnlvl3Cgeujj2i5yoUkydDd4a3TCFw+WMVJElv9i+fGRRnd3ZUCHn8Hu17B/O+/gvr8ngnf2VBqDcKrOw+1/SZU7t4vx0YnsxJBOn5cG1oEi6GtOhngaTsDdw/+HEabdCCzrz9hwbqCogfS4s6nGWXHwcfaXk3zUTvhDjOn7OyQjwsPCUfHTWp77ck/b2GahBErLxFCAShgVTY7oEr0KWOrZvR8pl2vmR0RkzGLK/aflNxsRtkMB3ct2d8/HHYrd8XwGzTVD16VyPDrAKX/tD9bP68WadOQ5fImt3XjnGJShP1KuNdfN0GDFxnaAtvDBQyJBsBvaxprLvl8/0PqbC6g1T7JQuahiqeXyOsJZDcA4u5gHvQAZK7wvWyOajzjpSEBPRocPOCtGiMaaoOvnDQDfsO885fvMdwRtZjl4iIs078+OOtBuxuyokV89MJuaCKp/l4L/Fm3Q9tBRpPPRkeuCVNLph1ChmuYmIYFg3nAJ/WvlqOslSbSyv/kurA+mKVmAGvNburbeyYxHV4IWcpYrMMAeOaZgKUoMosCe2+0hIAOMp6uo5Mg3OHKD2GrdKMrMO9w4fPfkkr5HB4croSOCBJZoDbOut4U4K4oDv1TBTB8KWmSkQzK+cq2PQBetQmObyBYeSs/R7itVfjCLaS8+pUprUlIamIgxkRtd/X/PeZ6arcl53F00tCw2J4eog0IGEOBhSRZpxxImO9KfGrqGx9aAWYO8idpzpDjD+WVRbJJcXZ/H1tMbm9AX4p3rEWbtIFKt8ho0zYBJ5l1JWb2NeJWHE00pZ8/0bDnvmDh8gopF7U9olgvnQgewqIJmrYUCARAlO3QLeQBi/d5ZH1o7oxdBqmM4XtlGiVKblj0HXW8cU/6kf3kocg8YhCTbYWo+ZhLwHO3d50icO/RV599Uthr4YXEWQ4pTWjCrrn+hYLGvriCc6maa75gK+54bPd6r4/cZAsxla6swb/BKcePzavZjmZZdjJ9F+/h2kNj5VohNyPclsx0G1w4NA1tCGvL8OuAcVpgIc3eg4BDAImZSIM+H0XSkvrZO2RivHxpafSmlrPClbk+wi+mFTbq2KFHTBJCraTsm+R6FbnC30bSrLxufXz2UArN6IaJdlqC6cUJZaeWENZhdoxUIz4vJySt3FoClW0sO3qXanBcCAgznYz8yGoQH9AbmjzXDeBx2ZFkgrkUpaIQ63icHcYT4eNqpBnRHkuCCnS1SjrwEzrL8ytka8IHiMoaN0zuX1w8d6WTTIZ+INvW0SRrI0uI+tllpblvo95+VilI99jnGJmM8l9ZyBaUFgse9WLCBoRdV+mwtzFx/mRfUUqMLukc61tWZqXFgoPSwGpe725UNQVU/gKkkv1i+aLSv0jOfaDJZiCMfg0LPsFAiIxL2d9jLHaffAQgU/kmJM2Ouz/pbw9Oo2OyK3NLv1B4CDnnfrsgQrc79mBcWKFwELacUoQm1VRXG0JCCkqVnd/TFVYJybo4UPr6zJOyylddD6me7Q9ZiKBu9KFAcLbkwPymp9tgKSZN7Q6clzAzuXsqS74/Uw7EbL0DK6n5Md60GM44h3V8dZ4+WvGxGOub2hTNAWbAhuhjxbn6Ysa5TMq9OAuvgHM7Cqv6ElTFloFpwlwEWtSdVmEL/pchBwC6lOBU9tepBxLCKPWz5HqMYDKWA7xgw3FUEvsgnH2XVODByYjqNEgsmY128j/LzImPLcY5YooQtn/Z+ikub6OpLRZRDiqcPU/iD00iHRZt40jsDnhwjzlgMc/YW+U+TA/3jq8DGdl16eaEpHTxlJSdCQ2K6vH3n3QffBVTbijisTiRR/zFCsHMBKA11qCaveBFuh3irZPjTNLgdWPlMj6NfXaexbu18zfxwS/XvI20Rt35Bk3973dyTURTdt1udOyKfCXbAjP1rkgPsePlIPBhse73+oT2Buj/knYZ2XP4V22u5DdB2IgKg/nxFrmOVQMGP/7sLqiFHqZ6CYop06W6oKO3BJwM131GgeoIHWyXm/91+Jla+jIx1hwin/XLgZeGIANLbelOtkXXhUuEtCdVUCfL56hZM0pcwDrn6fn5G3R1+ceLVcd0KvGUDyGnsUInsnwsEjk0QbCLvWq93a6C0NbJGA2KeWXIwn+KNjw/5MfZN5JiTRUxMP2QoRLMAvGtV8G6RtUgyAi27c3jCuYg9I6K4F40FT4v5d6Vfc4gVc+j+uOsuMnsDw0lq8An9DJuNDGwG1wencqtX2v5Kvl8jjzcjxA4mE/w56plfOozsViwxOLLwcdHC+/x8JooiWtOm/Sr/Z9j3nizX0vMu9EU4UV8xowFDO3Q3onlBQS8PlgUAhaZcdlgfpsZV7h7TpmPVHMMrfB8nY2M2XEy8joKlIy2ok1tJP2D4eBfE+L07KGhlUwzWq1pBIAi8Evl4kHubNEaGjpDNxjAQdKucqsSqEtLD9MFE+sbUbWJ860siepquNGKn5TOzj93CPqBFPgsi4wPSp1y8DhJ0NjwkcVhxtjpxTynvvE+/iR0dzpnleosh3G9+bIgUOOCCH+oko9phaiKKK5frl91KA3L1VpciXIslvz0Igr5TyD6j4SgBm8AXCVUKiIAn6zHR5aVc/QcMO+9XI8XcGcPv7uBqg1dEg3OKWe+g21EjamXmM7SYAAOdoO+k8mW94w/zq90Cd6U0Euu5NWYhKWajSIW2vUJBDwtHA8UjeDunxRW6HgPvGC0j0NmWvX4tpeK5c8O9gPz5QLJSDp+buFIU3m00IB+Dt9+YEullC8ibbe4RFMqXOhMybYJvYgisjNARAYXVAVXNFSFlplKxd7VtS/dir6RcTlmhP5zKFOsSAekzx8uNESj3fN1bv2ym6Kit8F0JjE4Tl9lRa4CUakUHnNDv+I46LgQsg+MgBjApSP9FTWP/4NN9rDDrMSoivOmyYqWyEefic9CtWf1FbBvI3ynwtpJOZpSYA8kKzSs1XjkNPZ9kzFcPYXJM7J17kyczB1KyxoYGnhPaNGnu3VvcmP24371hFGsqzyZhc8xn+gBOefqMPQIY0fyTe8itFSxuKclTF0206cr2W9SsXoXIBRz1QdbfqSayHuj9vrk+RUvssGsKVejJAa6y2Q5fGrtKfXJmK7DWY2xy1SeHPPE5Rg1zt+Pu83Wj8BMdUKCoIt6yKR4eA+6VcIkLkVPqtyvHARs+epT6biEx7GY95OnKhByF+ak8KwBNwkSqa3AI3ESrcVC+WU3l00Ik2gsbIvc0ImM8NgjcuRV/xzgZQEe9QWhpGLObBJo9npFJhdXZqoo+qqP8sO2anj8444TeKbEjRwcEhItcYgvvYGlr3N2/iDqgxIxngod0M2KRfbNtBRqch5O/pgpHWu6MyMS3UhU4ZP1VjzbTzRqserjATOV7cdWYPO2F1DDm1Lbcfi8i6jGSeb4Vch9jiHj5H0uZCOVXVxwoYdUtpvP+zBe3/Y8J+zMbChCVV/HC8CZylHtRQXPIjFYjANPOOGIy5BkE+9FdMyGtwX2HakQ1IrcmPWumh+eisdfr14ruKMnfGjf0w2DZpzprlPf0cog9OGdQel6qybqwFLXfaXnxW70/JinO+tZmNspoBkyrqdloxymp9S2PNfVnQcYqlCe4GZry+YF+c5HbYqre4vE8RlPjS/BZ3krSzbHX4aZ1QYY0rWPa/s0SDFseYAfOKPlq21hkw8+hqQkPV+IMhJzo9AnKdQ2yEF3dyIZdeX9wGTfZJOWA2pP7Unur5FHChxhb5iAFcgnANkY7cSSMtteerQ4PTYbsXrNUm3F99zeIpb04EYkWh3BSTMCR2MZ1LlSW/18vDiQ/KBK5ha3Kf535meZXCQItEvqqHTWV/zTmjxNDrc5OxZynESZErnJyk0CPycJiMrmukor0nC85rU8+z4LDisO6eFfDwamSWxt66oCntXZ0uoFkcnhDZ9XFqpWEu0b7lF2RGyvCNkTo4GtW2x7lx5+LYtfe6TcswTWldZKz++t7Gvpi2YZYQilLn1CkDM8aGJUnLeQvHsWnOgLf+zN4xnunfUL69L6GgZ4IzZTuDHTkGZipJ8N0iR3gnXTxU1te1as94hsdJfDshwVD4CsT4t7ZC+R/IR9+k4r1WNDSek1V7QrIRcagPgogHeqnP2PPOD16BWnfW8vBBwlTln625sQURh1LwtgrTZQW3t1s/XR7ygO83F42+NZHTOGAdis2EAWrNpxn+8wXWyz2sqst/Yc9tK98uDhQivKxXWdsWOSCW8V00LWqV940Qk7x44B8GXgI5xhzh9YJVbIHQ4egAERkX6jCNQsqZdinGEE/VCjsLFvjGhnZS9Mrade0Q0RFuvyhfQn9hTg2L0nNksaNlMMEJsd48tlDCyD4Oyg3OQY8rcGDxWaVjPH1tpCOuurq+55Hn5msu4pe1wK/t5nwCLF1ByfZ3F9fT1U86vmjWPDQPrPL5hKohd99P/woZTww0GRrFBOWBkLiNctJNuuOM/nNeNeD5hinnXnf9HwyWqmWYhizsGMDSLyo8Z9gHp2rm9STrrGMIzgf+5gD+3GC1Q5Gi1GyeheFlCwCF1fYB+DSLy4J1uaRyKlF+aloMz4Vx9ndR6/Cg4tNRtSdxM912EmypdseYt3mIo+SnthR43uYv+9geNzPqfzqYXclWaiUb2MGC8wNAPyaz5SIEVbtJSfDjIqcvBTXpsg5Yah6ZJ/4LWsVJcYxCOpRzEADfjcCPpJM77JJb7wv1i9EarIq3be4svgp7B87ULK9F4nWP531dkzq1nWLS3wz31TtUsdeXOKI0fycD1vvvXQyPXhB+M0dN90QlC7SXmYc5Fx8EKWUTDHMg5NVoKSJydo2gwH5b1GBmcQIWqtKplrOPEMOa/hATuUQqK96ilFkvE4pU7VB/1OwWgWhJ6BqBH2C9nVTr0GKxmnkQY9+FKio/YflhBzg3lOmqmJgYB11YinFew/GMfAYvYIYIj4s0n9cY2E+PPCCG6wwnr5KRmZedD0997OD6GeJRjWn7FYP9Sa06xi2GOd/uljT98RnnqdFBOJV7OECmJIRvFE6yxKJo/9+Y/ey3k4r8JANlC0VcD2TTyDcKZHI4LoHOq27sxg/JMjMnOct9X/m1c6gMOFcbTx6CvEMStsgRrZFVsziwvKUUBEV2MEr4QJxOerG2e6jc17bvFnEHHSTsA2hu7X/WmzZRaGeGY6p/VKL/4Eu9edscaKx+uQ4DDVda0Uj87qz0JY+h2wsWDz3gdQc0Ztv+u0pnh1RLK0+OwpHvZ/pwl72WErTswP5GOFDW1U+nX3ECj+RyPrP/qjNDtRxLPSqxa65vJpcjDBJdSrhxdxeWjMZCBSsDdnnEKy6pxEo6E/GB9Jnoeto5eeaBiQF/RqqKdZo9XFt5QlqQIncZN+OiC2x5Q/4CIT6fN0oDMC1uc+4CW7VoUx9bnbNGoUQEANBxQe8shxqgSm2Bkb/FU96+uJIGx++J+Yqqw0NcLB2v5GW7o47fE+9bfs5rEVHGY5gv46hzOnxYEehtcoILekay1fldUCRgOTS3H41fhauWk1ToRL5CiFcnkT/IhyCQoZmDtSvWctMlBgMDyfqBpc15W0OsO/ykbR/oyuCC0KAnUWRpc3P1TbdFc9CRRyfO2s/gJxbjJ62hs9R9M4WF6i8FH1yq1J1prbFwpFaLCQdeRpmPWrKdWX+3t4lcFJQErCLFVUZm99Q60dR1liAyghtP8mPqdnh5J8fyw0BILNvxrBtQJ1sQkDXpiMPc5s29Eld9tTC7UraMmWl5Yrw2ANlNAraLk/L2u9vSp8mbFwV3f1r4O5NVrtnFmogl8k/gPqDbh8zeHnhSc+QxDcmvs80dc3KJ/ikYB9qdPTyLWAPsKfgCPELh8zWulboy9GLFa/q3P8m91lrBZu8dq3lV+4w8lclxCuiJ928cA+SuimjDnikXtIxnKkQlHj1JHfMyCmcf5Xc3MtCEjb3Ra1+x1tb7Pak1KwNY04nAu0bCCM4Qpdao0RVzulQsydrp7Gs2Ec4R76W+S4RBO+vntFicWtkRKCqERgvuXKXuDpFl+bh1fOEnQYu8+qy0sMq6/UrwpsIZ5fZ8dTJT75fYAswuhs9UIdEinudb1bL/rWte63inK2SrPqPfSPCIDkDgWyZNxuXKX48n04P21ztE4JEdxdYwmTy2zbzW66Wn6RCAGCoaVJl8fSIhZrMvDSoxc79+izIpOQl7k2pYNBdIpBxDU9gIqeJ0khybs26/AC4KM929jrJJVm4Q/M6KuwaRekenCy9TheUgPbpqVxfUJqhB6TdnpUoP4P1bFbvMX38G8u5mYb0CEvYtoaQ0hcJWavhz8glWfBWvCnMc+/7j5pdCrvhEYjclnay3818FfIuaWVoQialkbTwDLdDzY3thg757IOM7grktMBfe+06mBwsV0YPoQYkZo+rejqoG27GnYuXY/NkoVOGb2HxM5rp53dRvaMa/G4O3Y9+krYiQKe3ifcXFuDzZ6u+j1Nd+/rRRTRejRE2sziO1J4DaTndQBK80L1IJ0RkrF1zBg4SMUN8ptTK0+l0DIVUHB0bmzNNK+0Q9DYqvsAXgTdwQJd21pQO1ypH4pqYo355DDJmro9fSCBwBkLj/1nEfnba3y6nqifm98pWiEto5RSrwvOgxfSDf+I9iEt5LrtjyS0pl9yYLuW31OI/brzHaWZ2gQRpKbFm0Avm5Vcpk9BH1dJtoZ7NoH5ce4p8+ak6WuJR0FbB9JPfbx2xqEOIYE/hi/6Fehk9Ofu8amqfIe04c7g8Lj/pqTWlQ2gXCnvXKL/pGOHPupi9KPvdyiko7G7fF6nkvo8c7CabXEb+KSMBXFQ9r1uwQFKi6Li/eKBY1Ds+IHdbq+0Wz1KTAo+l2e6xJMSc+R2qhW+23zfvj0ZS2u7Ax4dYjl/OaKGnCOGveemn6JtVBQdf3q5PI85SrIvCYsibgvmFmCPy9/9X+Tqcf5m6fVh1mnU24arsX7qbodgzI1eKxK13d4kKHlcUuiFR0Vj5DohyTPENsVp4D7Pxslv1rJXHhOsN5Goykt8xlFPw9kphEVliV6f/GINlosmRWvINDOWWriCxT+7JAoL+GCiI/cFcpQvaXTUwwxjyU0Jn1G7dkXQsKOFBc7x8qP6dPCLyhQQVz6Dm6jM3FJwnc1DerSGZYfE1g59MorfNLrE0GLvIVSayQqF5ZgEkmcS+JLGhsfiKLnqn8Bk/L4VbILS25q+YjvTPX3K/TDKr5yoJniXey3P4c8JnBuP/MggyB8Xhcf+8A2hndqv9QZJAmzXxz1wXYdOnzqG5M9iSTqL1oVJFwKPKB7+IMUoO79ynTRoQSwr1Ru/rS4+/8D5S7+Opyadq4KLWtEDkwLDxhPtNKbMxAX8EwEGIqwTUFazY9YypX2iebE1fHj9ntr3KqRRaVlrPkD1oQAIHayJKVChR4ISD1pZJ7xAJHI3AkQtPHlIhvCBaU8Ggx2HCSHNkZte0wNj+baPRe1h+9tWcXNDLOhHxQq2P4rc0GADAViywUhEDEuH+ED7E0SeTg50yOdnrtE8nZ96MUdCgMFQZCej6HgR3xOplKpPS62Am89B8unezckDI3TqiDmUsn9u51eRMGwPQq9Epgpy0GcAlRLJfu2wcFCUvejLtVn9xjolJaAtWNXsMXRBY0k6yxkIfbFqQ9rP3PXjmxbU2ba+J+YrNXUGi+uL9n8wS4epFYg45nTAQuqoO+esSpDfAqOm6XnIaCFwbDqQNYnTh26nCyY7TfidUxgjSir8NnZgWuBZPA8wevuW6ZfUXwJdEqcLWwxiL+uHrYe3Xn98+/RpROdAeEpa49qsDI0Uwgl7CJMCcpCrsnl7lBJNiS1/eq4gYId0uqKOHgwUHan7PlWRBL/HC+dHlpjx0vLrOjhwA6zleHQbxFNmphuTkxHYUScuKIwRyshTLw/m1mc6Rk8i2ERjj81W0hlmfHiQdxzAC8yTblrBcrQH+D5DnX36/qcF5CdcrUUViuzC6m6DV9oLnynMYxxXrAXA9JsFtyOuW1AhE5GRPVaj8bXHsguMovJ7ZWf/4ZV1BnNfvvqGlO14xNu3Ts01qGivU1APCfgp+B1wpfB8Fs+l68CrsBu0/FJDBHgjqox25A4jLGuRYq6Ot+gEuPy2grIcyWRe3n7tGOURxouoMYhRszMTzXK0HJC5xtKJiKAdl6BgS/5WTt5gCrOFQ67K5+Y0Sf7KYW2hJwQRtKerCsz0ecOY1H/5PVKgyD8h6uX1EOcYzUsNLkwfrJu3Wdz8G4UhYYVPHcIRIrEU1MNCWv/opOI0AM0ztlVENWdIexbaiEOnp+EWJtdiFPE7kMoFMyjO/kuip+w5bfiDIeh0s8FfAw0mCH9wRKHiF3whiENRy0DD0dltkAqvJOktSt/he+Ek1l4ZC27BloNi8GGo53Dnn4CkYIsg0DCTEZAEeNYQ8NO8q4ejMQQ8gt+mLJhgH8v+QVRNB8o4/GSLem9QYaxj2Xjvj8ZAaAicBP25AREUhI/5if8atvz37XdOOj9AOBw6zhghOOza3l8CC+CHLwCM5mc1uY/kQRAQ3q/c4iZWJ6vYf8/jOaeu7jbN+gI4njhmboDMYYcFnCT2WBfWwepxPgsZWH38Jkc8fG93ZTVItoDGfGOva+LbZNwxcyAdQkYtT416C9TC7i4wLC//tw5ERruMe5gMnzknCIWAxCfLIbB3l7ksBlTiLgjekUsCfCcPF35Du5wLtl/cdcGCb4qkF1JWVXjw2ofwfy1YtH6Y+jW0CkYgXiy01nYsbRfs+dgD9SWwz6aLCmBXaigpfskF3yftRH3gyQVbdaEoa4b5goc0nWe2zkBPNbJXww1vShj9W1xbwVzJ7Jiq5Gd6/ZQJRrBD7ci8iRE+ugG3x51BIMH3cU4lh0DpusBhTGr86xRnXsprEfL4Pi9FmdkYpKTSIv7MA5jb4JmvAYbUvt4W3GSYJsKAdHlVLAgdNRp+G5042uAbV6uoBmpHhoNgO5h2D164+Zv0w+yzVIeo3pNVJH2UkEr+nrzyvrLhdf+pjpJ3l9+sfRJrMm0FRVaenwIFeECxfzWsmPS0MJ+Om6cWwnUF1IHJT4Mi4U6HQ6l9uaygBxYbDdDN9Rpg+bD0/nKECTIC2RiOY9DBY8OLQQkWOTRWIGdcTQk+Q6EBJIdEAkjhAcrRY5Nvqiak+0SlYs39SERqf3tOEH8UgFEmkyT+1/vF8gh06sbZFeQhdbu9zrpDE2o//3qclBHNqQF+PHj0njT+EnzllM8IoGCfnfdv1k8x9yLw/TffUhM9aD+nUqBFfcxWBhAI6Qohpm32Tk8/CliyTVKQXk14I91IB3OAq2ycBcJT6Emvyj6kFGkLqK6dC+NIZFKWQzkar384fMTa0rjyzv6lduoIyL6xkveFj8T1xx+QLTmlWtXq6DMienMA7sw7uzNacLUUG4hTCf3mcmRANdb1KN2yElDUBR3xNXhWzNh5ig9JW2JsCvz1U7XCefWeE2NXJQa0wamSVXOe9vG7UAnMQlbKC1wtS4RJUceN00TKFrm6oggn1sgurAYLeUd7b7MgFUW1BSRySdS6oXC5olA7ltFPom3Qh/lu6hpoGOQLQcFL8ZN1flwTxd3mTFy02pRObfU3Nc0tD+yYiDiJgSSARXnRK/5hQv/7KVCROHCB7nl/tc8lckASujp02WUb9GmTYkU/lsiQcCkGJLPmqcNex1KPuOykoMmVv1rz9KCGOOQtIl/dbaLYZGWdpZEL//tL0a+AFIqC+ZTmHrp8TGjNtLgNmSUt20IufXhFxNt2jj9Y8E7Xi9XMaWliNNphDxFjOM5tdqa7hUzjS6Opq74PYzLvCa7BgtPrJuqd20NtvHZoE0tLBAqQPWlXI0Nos6WVUz9N3/MrYy2XI/3L1if+jT1Ep+aX7xjLWYsHCC22M69vBRy/zQSesz61OghYGn0RO1MA+mh9TjV1uzaSL16WCq9wJjWMe7F0l+Xc+fTpMYrXKeIPwtj3iSbNd1r89jtizdjrhzUyQertW57ypcVHcelx38ZreGRfhKeJvCkCdTBPcw09rxhbEoLREnQigHuIg3BpTKTyRSlrJRK+jef8lmqjWp8yA1GyzrZnknUz85rVDZKDyK8j1Lt6itxwfFRY/kqO90AS4J63ohvbIXOeBO+E49pO2kYKxeDwpn5uNaSYn2gh3XkXr3s20U+8Xd46SGFiHWQSs53HAiLtBUmcUcJ5LWpwr8cWoZkLaCoIMXEpkEzTxaktsm8uYJjq8lyI30diaVTrt1A3QQv2UdpD9ccnKdn5GfPRghyEoorBDLX4dtVcBDjVjCVh1zaGYYD2rGbBF1xpXAv6iRrS4MxTFVviZ93t1ylQFM8QQfrCTs2mgoNu9tqmT9eQrRE3Lr6ljlfivQtIO2H9BW7Kb4MZxaNacE/O+kiofY8k5wbXq547pXWUDYRPyB+YhVjh08BKJxEGs5GltYrlpjYo0k/GR6XsBQAJWVYNaqIxFXRus8kfZhDguOviZPkQwqDrWzDrsT9tSH45lVhqaUK7zYWZA7mHaVQZMHhVKKSPbOU565bShfRdNIL4GHDwOtpCCAmTgDQQD1E3X87dj5cXwmRR3U6/EKTIRU73IX297DkE/yXxZAyzDliy2EudxGyMDCRJ85b59aV4ME8axXGaZNej202WzdEOigCv71k/0+eVZRN5ZENeJZ9MrjAHbn2SvBa6jjt9X8Tlqexijb2sEdZiDoeloGCUghzJGMCeMsgnSblVTsf5Mhf8v13+Y0FhWvMb0AF/cAMqJiQFFOVOQRA0nueapDRk14+hm+DEzwGt6vFR2szRBI4nMM78sMra+qfD0TXHWmBf04oK6J1dIB9ldOmkHYL3TmzybWob3JmpqgrtwO1AWhLCfJ+BNaMOMXJUL52zhESlw7/7IkqfC3FmoHLwf0e3hiC4t+ZooWSyWXeGj4GEHwmHKR6XqAn5FcAlgK0qgUAoGv84020wGPS92jjeRWh7evjfLIMAcJzAIevJN+UEYUU2rbLAWV+XUhD3Z5GJQ7DIOpVE++XUH7+5q85Dh2nSMaE3JJKmt7BMpluvduS1Vt7yHcy4F1YsrpaxcZTmvF7BXwZoZJN1lx31tn4vFam7eUeYZqyR1AHI7MO4iHSyuEZ85wRXeNkV8MuGCTnKLEbt1dU/3nXwQbZAHxzs+II3vfbxuDO0/RhP+rLfoUJM/QtsLsupuB49IOHv0bWnf+K69fwdOmE/+XdytMwZKxOpKX23j3JKRFOcerkmz/8JAVJdoQy+9cfJbVf5Fxr56Jh22T9pyulR3TcB5eL1grmKNggxjNWP0WYJ2njHv5cC2kpioOH54dRL27R0h6/9u/8c2L222HEaOhYYa5mfYJu9SPWQvIbCcibPhx203bZVrNRXVpPTBLWfP/GFaXAXZ4Qm38XglEZwM69Uk4NG6HVwmZNwPkuACGajPbfwlIUj6sjNOybub39vc3HtegVhuXT8pIk46c7gyGudtyLQ18hqvzl++6Cnd+0hDi65uUk/qKjMGalC/rlWiTsZjuMh0yaOUsESGijS1b+2VfI0+NkG+xymN+pnc+I8Lxyd/j/zviJ2q7VOmcZ/lRei3pBlFTrQTNuaENhaJarcbO3rg8nmlCDPxoweXhuj16Yl0uNxpzZxl8O/1OiUzD2/8N9dkeNG3JASIs6P2hSWjiAmBL0VczE+6YlgVtPj/lgLrxAWlX8BZqOo2/qEf/frbiT9V3ChT4ZLqUYr0qhz8CyeTu/+8RN3lH2Ato5L0tDGuHW2WyvTzov40E1ySIT2UMDUV/urAhRwHpkYsdQqeq6kN9UCI1WEwJb/Ujl8p87baZoQUJLEiIBOwfRNZMp8C1/MSk9OMlkUnxw8PvBuNsNAbcEUtacvA2BzLoccUrXcMVruZs8dze1fXKvl3xOz15ZFWbQE6MC5VXt7ipbKLGP2vwT9XZiDYVSsuLNQLG3vsCV+qMO+zaXJTTmgIIeqLU3VG9LI+wmW8kREH2LLztrs4R5zCJ0c6eHqyvKUCUhAigZJbXG0rDMGLoR+kABVjaAILSm/EeuWjHE8JZ2jdsswwoPZagCUaQvyyYRbsb2V802tlAFRfr7YJTfcnqlnm3/KvuzjKuHnzRUOmZJ4WgSZktBA3xOmhgIz40ugEmjHo8QQ2fH1MOsqJkxeqqdGuyGY1zthHz06+EYZN/6IXh+RxOhMGP09KdDvqUyWd5bn4YvelflsgINnb+HnQRBaqx4epN75TqKRfF2VxZ3wkNMFDHRzpLs9kjc0zUit00eE3ZKgQchE641pZWmDq7ZTpJQ39LhDuul1z9vFiykXE+HIBNlQ2NlYrhqcJHBW2jUjW1rPHr7dsUyIGvW+MJKzhiPQnptDCwLYztmEUj28Up2GGLiFx8j5XuZ6eRxHLNTfzogLS8QwrivR+dGI4hVM6PzDdnlrHX4N8K/0TzbxqImCT3QWTBPscKOgKSoBujN8T3O30B9DB8O4/QM+Vr5GMyp4UpFJ7TTDvmFpKoGmXiDYAVvWYpHp6FsjBfLu7ZTTDwtxe7teGenoSJ1MHFup/rorTGArKvPwtPAxudtu2Rrom/xO3XNFp8ue+h44Mq0uTXEG2/fVp45SvBL5g2JW1PnsQQqWmPxnLHhAI1oIn6RKNA85/gSa9aPBkQqdum27P1WNpIWurb5RkkhzIeEZqo0c1cBJftyOF1IPpZ/6bO3pmIYF0Zw4xuo7qZzczBkV0oOfm7xkT9VL9gqhbGulyXARPipJinurb/53PaecCbLZ6myOii/07QH4+F/TQf0pBxk6OSjQWRu3Rp04xcpkr8Vr0WgnSsXA7pIZdXo8A8WhmdeKQ2rb7vcVzf6myI1wgdHMnXNQmXtvf+0qAOt/5frMfK132WN3xaGcSrkTiqnDsUYpaOvuxjboh9pkcMvPpUOywL0lmWL5yRM0OvS/KY4h3oqD2eWyRqkLUmbElDlWX9QqsU0EsWrWgJvbuRKg8eD4eXcLtJT91oHIGQm5LhCPG9JpTDZmlaYEOfRLigBZQN2NJHrmcJo8a73zmAUI4Vus2BlFOQBkZRDjwauyMNIIlYs2Wd5/ym9JlS+roHdoR8U+FgRLDxPceiI/Qvne1lys2Ut/ZqwFxc2pKP0tQcHuDHtIeUuWfh2jSY9gSvGzT9op5IdfUxJ265l/esN24zVU5XabJedj1f33gWzBd2odPJcAVBlELEZUs6Byyp3CxeWcBrvKheoF8QxnxKzIEYt6hBeJ6IgrJ2jlaBkwBDdiZfQAb55Cp95GdVVh11kb9BV1A9VEe9hS3N7szUBzUFOcf+wNrbEB1ucNxbcj63SXYrmGG2xir8hHGaqyE1w8EfsIZe2sdMQveSQ7yDuFODQyfpBZU7QzAY3YqsQHTuRURZqqgBVfPZgiWuIJ2UCu6xt93AcbHh1WBEXYZ5qo8pi/yt3twiwg1RvRb7Sk4Zd6A/eXcwnkoVJrKR+GSotyqmFhAZstIwyPcOIo184f59qn8jybIJIgiFO6zFCrBlYuLkm8nG+v1wTRnYePSI8b5aUs8j3H5rQZ8MLLNm8SfFdrXNSQoFxrk/EAS8mpcPJJ+qEWbeyjskPqXcFjssobZfRoVxTHV0aoZ9acBsbp9BcvYX+ZojyG2IQHihVAoRKKiJdFbqNLuqQXpHc/it18mSEzkJU1JwzX4XxYgvWdhIJtHdLpUDau2wX5OkROYJQ2wbd+RO2lJzDLiZ8EUIyorq82fB4h+SYFMR6zMBqJ4OLQsM8rT56h5fL722ZouBHxxFvJNDFH8IfAijLTavh7K26H+x9XQ2KHcl5F/M8e27VcEkn6ueYSEIas4OjU6gta+GScn4SSU2mnpId3s+eB0UoJ3TYSS6s056/n0O3m8NhZs8Kbq7VFlv0vueGs/uOQ49OSNDUgF14DBllVYMTXphrw2YLHVOz19DU+J1U2Hj3uwrivd6bHs2NiKXqs/EgnMHJUYf4TlqJBBFOfBQi32WhxaXoHP3aZtPzRyEutQfJhEdGBiL1J5M/8wZ2s4a9gySXjnEQ5jpIlAUdD4gpF0GYVpL53apRnw1xKzLW4H9TRUNiOSnEXg7/sWjLcMyrViVJ0H6gmFRg97epQIafT38WRTn9UTJnDLKqYyz5qikUjfvHJizq4lNOPG9TCIS5TD0mx4JOeFB7y2QwjaehhrIJ0xb3ycnGAdQjVpp+k2eNB0a5hFrtmzdOBxqP+1ze881xW0ZaAM8rwt8QC+nQQROKuh0vBKl+MpBqEUeW0CGvmapoVDdQlhF0b1xAISmAHD5w0gOb2yTkIxAeAnHEfTeG0Hgz7lra3Nm5BRiEOtRxIf7dVqqoYRNN43JF6J8dw2Q3lw4n6jXl6xg2AmBz9oNDwsy0bAH5pb3iTNqif44001UFzGdoUekhdtl/Ni/rPyTsdr+FDZXm0SKHFOUxuY2ES3Gd+i7C5B+fGtMH6B9BErmOg9wQp3pu6OpB8lT4b7YZLWqWQykhvrXVES+H4bLPub3IT6op0vMmFtQb3M1vKT9l6MlmVOEFj/BZq09TFHYDpaEveYZy9pmd52xfLHjQiOdO12HDI7T3wNJdI8rgnzZHY9WlvKQM54h/pVR7USQd45d2ni/YRqMsL07qSQ79fntx6i/Jyfq1kSnIwcekguhUFz47nAgUHFJh7fINLo6joCDiAqoUQOKLk2mFgbKxuW55yeoAixumASbT11bDhVrkK1S9ab8VMHo20COIWoyme1bm0MMynrrM7rFDUolgWscjO8EqQDM2qk0l91ptHPG8JJGVpyukaGWi93McFOV5Y7WIC/Kl64GSd7tSaM7xQiGe8ujeRLRCLWNngp7fxbQX9068+8KZ0a9bDDrkEeHH8UnI7TQeG5IgVwZm1dCiwhWyfLVyw4arDGvCi3D5yswK3fdgPa53c2YnOar4NelpNQO1IZbl2BK/0Mz+nv8DkdCS08Wy85QCQbijW2QOHSFeKakqe7xb6/njWE+tjXz9vIZFZZ6C8ukGSJ4KdXlUVCt8jydt2ELtCMpvyebstzuXGmJ33AvG3rgtN8XfGZMxjgGeL51hCBgE9+HT6LrTl/55OfE7ahKUXvRDvagJBO6tn7VnLGvlyNJAxPLnthGYqac6tIIwZWSguteuMI4y50EWCo9VmXsJdZLyiibrRRHfiQNllA1VuABO5zUVN1UMQgB83DUUHkxGKraySG23h2Ke91Tz0EIDyRKlspQTr9VPSK/xQjuoS+VVUDw22sajsYoCKfVq+Yn5pbLs3fH3m/X1Vs3rM4epp6cKcbfnzLoPpY2Cfnbh2/G12QkeYU/ENJCw5K/4Fbu2G1SZkNPhay7rhVpKflNCEFAvqc0kxb7UZ9loet95PLKvDXVxP40cUN0hO3rOhM5GwAHdy1PSrltMui/o+7WeHYo3Mus+S+igwxihy7vMSgcQnTXyWzD8LNBQkHg19qQzl9qkRTFDeyX4+Aw86TxjteQZ/zZKxDdIDtuzSw3bS+acqYLuEGOWboIS6oMUkpOktCld2JAze4M15UcFNJ/PBYPWzHgl5u2kLSWipyqhfPDvUC+FcURhqLvooBPS1zz8sRnDFb6PeILvxfYn2cx4QzbzJ7ed/hZNM9GSiVq2ocDHxsRH6giRF2Klgj7Lhfd6FXqLJLIVBE2pCikH5gwyBam7gOiJlR/sMHPlHEpCcg1wCRwuYVQHEymy8+SdG/ro+0kVPWnaFJwwygq/uc+SR9uANiyJM1/fIHGoKHfoPc9qS6DulqHx1bE5Bj5z/gE0LuhbuY0NMKqW2jWri3Cba04vRjHLo73LNdYT0OZwryO6Ex2bESHUcA5+OcS+j06Nl6MBXHdbE5SAKZe+1jQPGW6v2wYQHTQ7TLCIQxacHwQRoM9urFo+sVWlUv7KANS8vrhdCkrGkonOAtaC6i1WW5zGvV9xh9jcoxLe+909k2568flLa4HrIEeiCa8HmayLPSyaiCVzvd58c6z0wFt6hiiZ3cEexIFlof3rh+wiEIuyTCAmlzaeIndhH83rxiBqGcr/CbJx2QhrXf+YTF3kyeF+Jlt2NkOoIxsDjVgVDfDShYWLwbZpLqjyt0pwGEuvTIZqesLm/bYWdenIJRR98cYdl33dw/THqjiuy2hLMAxNOM/iG0KwQxF2uos9dICGSjzCC5lE6S6kqiSibChn3Z6y35BAP5mHgPVUqYQeandPYZoHteuOaF4oHEFP0SAto/4GLZy4OSgiV7hq85SaQqH+EGE/acV2rljUu0NalMH4MI/KAUZ4rdd4pbM4082vZiLpW0stWNFouvI0muUvH8QsTIsVDeRCMVaShQbleujnI1xiFiG8+j0VgFcgOz6pXTArKeKnu3XQNTADEBm5DtaxPI+/chOnwhbwHA4LveuFibDk+Zu7BDfdjnf1R4USNlI7Ebel6XhxlaFeAJkm5CBxcw+4SCaGa08vdytDKkNNdSnPnn9CA9bOo5dzM7YX0bwi8edBzmJercBw/ChDaRhbjFvjkMn67+Tf56R4h2F0HyHoDEkjFIbB5HgbZRxLyZqW72ofVc8rEUS1OIH6JNLk0Ut+torr4hXl3leQQLEgjdZvWcA4SscdX4VxWGu9JuhC3AKyerU08iji7cCPSLmHQBYrmEQKpdAMYqfdf094+dBMTTKofaD3w+YbDiQ/fr+TtVhfy4CA8g86cOQpYnSqNobkqaZHlO6Dat+Kg+bVqZBWbgsf0fKQERu3B74l2TFpR+fNagsArpDXAfmrjRw1shTUxv2vKlQTSo0tAIYAlOo6zL5H+9J/V4y9VSO/YbxazKCHzwIreDm3AGzJvjl4twtncZHnSYZ76zvFmrTMImoKRzgYGGYygNhqkH3yf9rDzQG4omDWTFDdzD75q+Az24n8TXBsWv0cAgTw7hkomjAUGILpj8r4bbrm6kijLXjXf+zkkLUk++YDDgQCjClXZPIHI48SeP9oteN1JjvmPi8qUwuwZWerqNn4lBTvRwxP6iUiXJn/dcWesoHP/0p5enkNiwY/8LKyKwBhR5ESVpAPUY/iZDWppdmE6klvcil0tgPu5wG3/kehE+t40kbdH6fZA6IN2v5wAnMahIzvymVizt4pUvT1SC9LK4SXO+eCOGroum8LkV3fOxkv25EdhhKyNvmBYpYhLYuYGLCkTEUNrSUf0o1OtDCgtZp0z7xMt3V8Hb22vKfBuu+csevXE/0yobhZXnTbPsCQ5EHEAhNRu/Om9k8xBplDMNyasNCXBjNoirXVszXIQBHhJ/v4aaY3VX+ys1kf+S5OAfQqyCjJcntqosoHLhqlsm5Fs27+SQ/KnDUn8F5S9Bsn7gogq5+hgZso034tyqXbyxbWQ3aV4FUeKUfGP9gHcKIlSQRsybHng9ZGMRjqpWkQGS7MWu/dTXFMVp56kbV/tMmnznphecqYy9lYL50BJhW9TNwdBOlly6PEgUWCZL74uSO/sJhD1IBsD6m6pL+1rWLcx6EdbQ8WJR87nYFSK0+o7H+IywghFk1oJx4oxkJ6rNlNMbG6ZyDPZMC6G1xkbqklP46GSy+SqiEKz7yXFXxf9VUmOnAnqhr8YCG4L7N2aY98tIGeQR780kmbC4lDZnnSEqCB8XQpl27UBJY8CyK2+vvYvAeAgVT7gvYD2cjjGzqsVN/9o9dUHwLM3iiABhqr2UYgw25uBSvJQ3wSFrx+u91LWPOd5QgpmWY1pxTyZKQCz01mJpzC2arEPFV7Vsdyn1/OsjNTiKMHq+8lU68lGzzwio/KdvE00FHcsHsxcDmC9tmBeq76fCmjYa6HOC2ouihRDe7YeJiZlsQ0smHtc9Bx4ve2207qGPRdkeWbg0mrq3Hl/muDVxoV9KOgYB/19uZy5xA267UqLf08a0UDejOsCIdkUgTF0VS+ywfA3Wh5k9Xw+74HM3ZtjCQB19g8oc2q1trpRldcISC46rOQNQnqxIr4nbRu1Ufh+IN/YqcsAhrFPdlZC1WWmVV2AuI/4LyxtBdb8fwMoHass7zqeFhlde70oNTUKuZETK2TxNU7iNI8S2zdM6WUMLD882JMz4BJW9ZOa0JgDBqCKiREIup3AmEwUtzOvZhdXmwrN+br8T7lPwpBuoEeYsEYZ7ItYhbPgA8g29PNcdmkBueWOJ6rzJ5p0d9uEH8zU0Zb0fs+ObMoWiOVWpZsZq5EzyTN4fqoi/1cn+6KVszi5T7Ptlbshhy7Xku4tZv2So9TaLNQVS7Vw4wkn/H4gG9iMO6PBmHi3NfuvKPH2W9A7yQifp3Gkep4hdJl7lIJX1TU099VRWkuOcYRyA1h3vKlngRqJrKMXocBo4ISMy06SvS0bV9ToPzXzBJA8FesH69zv4P6JY6wblPeY8IeaDqXpzlZhFDH0P9SEaoZSwGKSHK+rSaQt0RsGOuANx4fOVmlG76kwTsOvlxFLi4pPv+x+xqxikDCHU/pL5uJbWVsPM1bksllFzX/K8O8Xv9J9Xjm1XWE/E/mRkF7QlaqihvqcN7DPRv2kBOFsIV1GiwwsLGbZeJKn/zRe2wkCVoyonlbN1zlnfrLfBji4xsF2iBYG3IOHlgahnHTAHnKj8XD7Uu9cfIe7zyeVmcVXRReoY708NMFvlGF1IcIHwtJdu76RYAH0l5AYowx3qsIODJordpVBNkx/b9cNl2VTb7x9O2J1G4e4LO2ZRk4kYRQ4NJOcNarjOoQcNWt8KXdE9DF3ThqmVeRWNT5Gkf7d7DuL4BPwGVU2vQINTwQY3rO/0ZEjfKPxp36mSaoD/vyEjsnWsSNDHj0vy46RgjkvuAvdlKb9/0BWY/J7J6nrhaR6/PCleRe+YEdOCqeSUbT4xXWz5bq/wCbIDB6SzmqxnVOlt0dLrcty+HSLjCJNuarAWB6N2f2pxrikCnXWWOPysCQHIyfZ9B5mhMcoSjy/3EPGo7188yYFSDVk7br0R9UTHvT7bX8rjdrKbFLlrUh091uCqHwaYIFLCYwvWwvcdZbehj10KKcRip1Kmn/fEhyhWMrktMzwIoaPKP9t+O0lXrETpp+ozWHp4QRJ5OD/+kJxjJd9LLMKbt5l9rSZIUMgxv+/rQ+P4NVVYrDi5WrZS32+XBnUV6r9fi5+A/3fBlh/vqnQ6J7VZ5fDhv/F60hmy8rkAeRF8u+7FTO+1sg2Lmh9uDhVwHg9ri7zZ0qnxQv9um1L4CZmW9WL7WI/REyoBzO2Pkp9ccaiYIfA71JHyTqD8UwUHfF68MeCaVd+4zbacmgiy628UZXTRw5xY3AyD11Cqy0qPibcY0kLiFCBwwrGnlct0Q1RAqSvtmSp1PoFPl1PRudx3AZOk7UQsEBIOxiJ8tEG3PXa3rT0cRg0W8yzP+L4RkktMNZ3SobVKc+3RDqzrcnVaqOtuYnL1w56aQdir2/DYWb6N0SRcIemPGy4HOqi7TV37FtYTzg9s6nX357Q4w2ZpodeQnMFESNMIx/mip0wOaOQNL6HWa2DU0eKBEexrxuoApfrI7/eImzv5jgqFbs807qjijulbsbUA0dE7HzHsrWC+I3peq3lR11xWhiU+yQ0lsChPdLC0b7SbeCKdU+238el1fkouUu+LlZIurOIL4gnX+48vdvfzNtwAfhtCWdXzp5oB+LBnZf1le3fFBj6x+ZYvb1UtMJOz2SQxV2nd8z1BSc2dEDXzwiZFVTeCf+Q0r5kaKjydyWoguFs1gcztKgTIAwkl3cUDSp0CxtgJ5LB1mYoF+XKXfxd0EQRaWYxXuTLmCwNtSmEfTjr9cwrpzpmilX9gEaB/0S/pLUqCQmh4PiuMK3KjTNPEWj2IrhtsLXpghx34Z7GQjBGo1LU2HP9vCdk5H2kID0YqzLm7hqZIHhtGmxO+2JyZtkIQ0teNdgJEo4BLdPmEvwpEW44dyzjdw8FCxFAHt4fWwYXSGMll3WsN+AzkbiaAxovg5O7grrKkELcYfo99J1nI/xR5chlywb4TR6YCjHZqQP62cFSgmKF5DciIijHU3KLIZknWduZcRr9F8ZetNR8BlIXlLfwafjJ1RbuCitOwSFpltzs5B1+SzQLCPE2d1ZaEfVZBy0WA5Kfg6Dk92pJbemMltC9itm/pV82Rsy5L3JByGPTACAHyRM4L3xFVSs9zJ0HEvkin6F2FlU6lgEUjocb5ObbQ4Qq2euBT+quGwYw8xh7iDaLW5XhWjNRqkaihFuzBvtoSs3WM9IS/IoqMJPXE3WeBDzR6Bn7N3F77zsOECgFqoY+jV5MOkEPuh0xZHqO7wYEmWdpoyGpxE3T0daXUVTmC43YNUjPPxZc49JrbLStQtfYpzlj7cVdPJQrF3hMuMFJs5DyQfKuJrttpeI4NF/GhcnZ35pxV6N8GhrT+hl6xVi8T6QnhRiYF7aWdsRFUnxasz+tb5Nkxc8CRqty0aiHNLQIhx1C0fvCi4TJbI/i1RkCPli/azdQxRxpA+d4dzEObFiQUUad4ipJ5sweVW95C16K6viH5bKwoUgb2puBLygzK96FHlJ85nSmRkbxkBO9BCpWlgSAxWd/Pprqgq4UVl3ouYqW3/zZVi+PwwfADT9b0yTK5ioEUgBfVDMfPetp/SwJXJv5vYaKndu7nChpop4qxNy6SWw40iSj378zywExzFvIcqmyxz2q7EvuMfuudQhalb1XtY335CDlaI2taVPruptCkxtdE3zobshLM1vFOWJGv/PqhDqC+cdTTRZFZ4S5oSwdtJmKlpuDNBi+IW0I/3hpl8EDupfcnnltBHt62K1MH7cGoJB8c8qusWTP1GO8K38Gs8LdiMVc2woCCrA3WNMUj5/JrcIZSvhvE9hTzQC9kSU9H5e7Y6xEnL/hlb63dOUe2xL5wotmHtfEp4qNCwrg2ohSui+ddlsV8/vuXMs3EadFPLSr51CfxzwLWjNt/IQT+0qp1NKESwdcAMNnL8qB3HiW3r12YzpHd84hdipB+/ydVMCZ3JrqAoRR/s8KektL+mA9Djdp1aVwAunWg2TfHjc+/x259lJOyHU6V6kdQ6dcEE8SLuojydim2tcKX+j0c+s38v64h/4huMF3knM68M6RTmh1xKAD4S19tI6uHiubA8UvBlK0hmqdbeWz1hNy+5dkGGcIIse24ftGfWN34lPS/iACvGE8ZiIG/5iMm7x82xwfseP+jnReHxT8l0t5ji7OEkPLdWIljoAZ8YB4Ve2gxFFJS07MfZVH5CJF8aZtidKZfhi9MxMSZagOxaskXGKO133pQeSuRU49taXIS6EZBwK2W299V/t7gIJJXmEjhJq6WDlmHgt3S5Kjq8oJnXVf6mEKzbi7kVTQE/PNl/IoSG06nSLnXBIFXXrUhED8YIL+ZhFHt29Fn2qZ+QAh2X//GnhCFTYdFcpn2Rdi5JzQ7xY4/OXcJsCzL3zZ2YY6iZZPEvxDHBlnnOB5A75/8t9Uy1720QGHXG0DGylgRUSYi0Ye4p7kCv5qW770ITbzbnfymODZvhgMzv1QOu5Tt/nD81HWq9z/DpKDjci/XuesLGvzZ6mUW1oK7VGL8ledZdskfbBh0ulnjAdwF5nS4TF5+54HIRdtJkHjFFIQUc3Z6ezlSg80x5hKdwoW2GTBzjvSu8NXZ3gHCKVt1HEieWMKO9v3r16oylVLi6Je7O2CVUqFs1t/XzEh4ANWHW1g781IKSFQHtuuHdor+vpjcdnQ+Oz3A+EhRsCYOde+IjQy7qsufbGuUszMCJDPyahO3uLS8chn75LNtg/S68/KqKbyYT1o/7/xlV3MwX+qALfXUb8CCwISWd6/Sy+k6ukI/vofTGd8sPTb1LacsPE8868Z2llykZmXTperWwPmvzvEnE+vnTo5qsvR1MpD7OgYYQsywEza2yW2xLMTqj0/3pLjllkB8JYAOYiU75/Mkq1T+/b+Z8fbbnzeQYZQBh9cbWhuth7QH8Nts+/ULEnSOGmNuEVx9fG3VhFtZPaGkH0eFyXOLeOLmEe6nKs+/S7cunjJPJg5djyYUxy507ot1RZE5nkTt5j7AzIT2x6Xk01qL1LvwLCj95HWIFeHo+ko69WJ2wS2vUpMqvdbX5Es0xs/2gRO3sImlPwJM4EBmgt7o091qdoY0lNhkZoDxFplVFLoCEZHTJCrcufzeRDYsRLbVQbSmaN3P4LKeq5TNYJrUcr/JuH8F5EUmBFJsRojKfUzzAXxpLtHBNYFA+wca7ifnWuzDXPtTOhVfyvY4Kd/YgwiSfN7dwkIIslCIGWSEUck2DPQLgF54YVs2+kgL+t+hYUUYhhONeIo73ayPgK8etoYFIHFIsw8okMLLNdnN4dZJ+c5QzD6P45uJBx3sl/Wz35JCV/YZzDAk+VebhMV77JrNndUP4ZkbCKPgBJeLge+24kojTPnqOVqyqk9cbZFA+AhrhAuB1+hTmLjroGWimRe1BOHp0qCJxobnTPtgoe1PK1+Y9YHTVvHe/0VekBnyRZkDuSOXALePYVPHByRyK7xN2U8k82jg7/ypD29i/hvQSEEaMftSGbFNpfHnEBkIBj0TASKhvzwlpzsFnNxcmfGG8a9lfa8wj82RFGwjPDTI1hAc2SivaB7MaEpJwY0VQmmQdmIG1Si30A/0793Ihb/Ww4wI4sIfhJLp8/erpM9RsVKEyFGvwZL5f0Q0r0V9a8ivZ9EVm1nt8t1cmTTfWNCfDcYJ+C1Ur0lsS4DAvSS58xi/cHxIKapmNA+7JhLcFES/u2DjvL6BuD8BkNg3mSF2n9wtDXRYgs+WMfNTusMSNNPyQONSA2okOftxqa8gpkhpEUqRWXSG+toxPih/cSZ9qTkA+6agLzu3NgFbmZ/CIenleO8a/MTqCxOYkd3RF3PJzuqXzJbE9gRSz5V7SMdEBsCluc1sYlofg12zW3BrzWFLXTcmUEqCLtXZr5ekaKfyx8QYil3t9DOOf+nxfLezhf4iWt4TAwhk4QgJcnN/XWtl3r7GVGLBd85deHt9wmp3FMlzHZDtoI+IJaffCO/oEnwqzpLz+0Va3zdtNL1nFU1rNH1Xk/GzAcyQ7YSehlNxQwi8DAK0GId7RoY7nCuJRqdZKqvEWKdRBbHLdnH6UfluWG72s4xAVSy2IyODqtfBjKsho6dGG862IBPWkgyuE1hkMu24tk7vm5g6ItiBC65hD67OkenLQoRnY2p0yDtCyU8dZlUnRfhqQ+9o/iGzIKi14geJyL0O3GYkEuYBEUTS4YJXV53lPaipxpE8Bk//gnOmxSiuM7TfOu8FwjOLzNRigr4x88txbaQ33NRc2As+KKMTZccKyodrS4Lsm4lUSoGgWyoR0eJU5cI8jX3W3c+8j/sKoqfStX6+9EkyLcJuPFkVeDExVtyrUYkLplhJO8ZpcUSO53RxbBNnEbhTRWlBgioOzh34L0xt3O9Ba6NkFnfHzMEZ6N4OL7bi4cxAYNnzqFLP5922Y04T1cyK/EvAq1twcOn+UfbQK0PyGvJKbWorc8pDJHb616qWh9tPzHgPm/2T+4+nGota4TLfmJlqGfWvy7mad0kaXMhThEHC7Qrc0sv8bsZji7VSyxOGUPIwZxafgbW5ZC8lIzLK6gsDqPIe7F85XuOIXYAFsiwbrQQfulYwSvxrCpFrkJhf9WqITTuz19MyxkHydzJqa/uaj9O9X5ZENrorB66ktqb+Mf1qWt+SC3uKggR1lXOgyU2GmPD0anHCkz3VqLAihfYQB7jA6a0CL81wzyYvCzOT+vjPKt6JtV6St+fRVaqaX+/uaA+k9nGWO6TKsqiYsKbjOx0KwylzOMOmVKt7F1G5plsioTFVMXaOrBN56YMcE/pgOocTADhAQD1Oh78ozGGO8oY9sccCtptDgP9CVqldLyXknMvpyqR3aY4k4EYMYlZuO9jjskj3psR/xt5lrbwQkROEwCXtw/vqKzK9f1CT69siKaAypO3hocn4qCJz1Pgi/a7BcWxeJw0/NvY9FibGGL5M37/EJvaiBHzeXY1385m3xk7hwewUKwskkzG1ac0is0fKHQtUTxmERrPycOfTXcaNpzY6NOwPF+5JNCZOWzv4DiiQcSxfzU1V9AuqhJZJ8vt05B7TgYSMCQECDuBkmW130iFpOz34SqsrWLKYaAJ7M4kQOXimeLkdZCDZpCoeaaNzOKQ+e/wP+NEwgtNiEZWM9waLDKdj8MwskohZ7NBdFcP5rbpUcJVI/BYP8xYFN5hh4QpuEJSXdzE39WexTL/zsvCbrzk9iQEl3UmbW+MWmq5hOdDkDagv8gcXz8iFXxTPLTY2MpgZyuSafsLEkKDyTe4X8gGFiy40EGpH+CaZxwRz8unRP12AVwHvFzSWPk7lRMzVe8BcXMCE31oCai1K0myMCgVErUFlMysUycEBnXAmu+Xc9OdaUi453LL0ug3t3NJAXJPaPLqkngAuKjdrV7jyxw7+Qmbokb/fwd5RR/N1GRiL1FRI55bbHK27NCv/2TTdMa/KvyqHV4LRes7IFP9emiEfgynZmGLWq0PDrFxUg3Ld/WVNjIA/jKN0fQXBHWmXixrKIntxwxXq6ywRTCKSBLx6lbSab1FblHK2HwYs8kNTNgVNZNJ+aZ7Mk1NKMMbklGXkNnjnaeccNW4meuKoE2r93/Jzw1SbZUgu3jzfZf0Ak3WezL7PBFYaR4l1HGUFN/B9lK6MSFDN9qQyiJoUldXjivWOujnt/HDKtOd1O5ZIHzmsqNz9p9LcO/br5Hj9qNzMC8Ci0YlVKEgzKYg2K8xBmVo0fA/0M55pndd7sZbYYr1yLMJ3RJIHE7Vwwtl55d5D1BcuzgJsFdmWyRL6tfzu7pJwVqx7G9LLHQd1u3Vu0PLlmuC5pCO72HRGbhYNlca3QkutgW4atR20P5PbxB3lJ3/TeZgLUYD6LGAXar0COAXrAZmCwvTplToST0Un5fR3E2YqUK1+uFNwJIrN4LvNuS1d42c8nU6K2gvSN8h++8xF75liYLOW/bJ05m1nezTLPnSERw7zRuANHaLEl1h3whgMcOzNfDbC/ZcsOSbwef3polhiDZ3Cq5zZ1StwbwNlFX8iaiuGgENmn/uSiyQua/k0JsfdcX+dlw7cpy7TtF/+vbrCQXWiLnOiTAQOgKR1YQtN9qLjIpNRoNvNOZqAAGdrQcxOBr9V3JjKm26GVkKiRgNF8fMDD7LHwgdWJKSg9LKJ2orbCLXz/Ktv5DV3eOHnwvPKcDaAd93kO4pt++l5t+Ojk28v0zB/Q+ymDJAgITbqdMJk50G/8U/DltBB+67MnVWjDEpXsmRRokovuYkG80cihwxwuYYjB8f36LHsLHs8z451QVTlCwcy1vl8ZlprBthDIKCHvPUvc1J5qUC5YD8umTNCCAIFb6n3qbXG23Sn5iFAhYisxdffkRdefZKv4lKa2WarYiKMdPcVcIwngFt1CavXjfQBDcEVOruhqWYMy/qcCmydlVl4VX0VEpqn1j/eUkkMfiGhXgaFIDBX4cTRLsVUm9MBVCg1IRTSeC2lY7Zws+VVKfBrFus0J/595sdzWCJuDwnfhuXoM8kbbjea5PZrmy22pkaYT6gv7zVIS0MEP0K9tlFHlf32J7Q3IsqtJ6H70lfzzHMvXBqSsXeI2QycRAAYR4EXON875LUEFZpAQUnDjmmsCnW0k+7iiSUhQF4Bd7PuVkY+pQdMuEvwutQJhj4s4jVRd5NW7soInWzhijUambrVSCFFq2UNmX9TSUK+1oqzD9GLkTtqmoOEAZPeOJvH6Y5JgnY+opAShQWxWVAaz788WcMscvaO6S/d/+AOjz2vgvhJek9MJwoh57GBO57tk0AfzSQjWV1OQW28GxxsIGgXB/nHeqabAb8H42a6gWTfseudKpxQdOwfWBM+7EnOl8cTN0lqHrgHi6eW81zuJ7gBCPVQpIqtalax2sVG0TyjAVeoEK2dbkZB3dYMQzhSCqtMBaB22eZFKH19eQHVYvKXdtm8CW71vBMnbh5KMP4wQFR5pflLah3NGjR/84NLmBjrnFTiNrveI5ZHZ3uzamk3UYOmIwE9q92obXPltGVjh34TmwCzf5cx0pdJ1PDc7FXaoF+h97hfJT9enYe0MNwfhj1rNdz8zeVvXam+X9uzNVUMnpZqn8Apz+KBjHVpA+4ESmxWBM1Sxt2eOKx1tSurVXMD15CVdqMmznO1OacEy1RgPEHHIRYMv0TWDuhf5e9cjy9Gk9pTLPWfLXln6nIBk0TXfBykklw6W2KgbSDn6z/zkg5lxzNfgSZfedberE3FPMBy8FnAPI1zMs3/g1Pwaf0D5AssXEixNIizQoUyizdj/dsE6ji3C2m5PB/1vGxWOk8H60vxovGMov1KblzOyxyGeD6hrJS4YRD7OjOW2v1nPn8nXLi9niA116vSSWBm4yqhf3K++UPtVDAlZ9qGMDnzyyOYBXaT1OxH/CPdbIulLPU+Y0HWoyrrO98YlTi5K9Dxpz7DuZX83ZpKpzEFYLzFA8GUgP0xbTPIZNg/avuHftjWtZUFbg80xWJ25IwTh4ZuMDmuP7ncNwuNfQln5NPzp3x15uM9FIwx1x15KKeFzcHd7e57M2fjnKAEAYS5j0TEBsjpb6fhodWNysRZhW0KUtZgHSR9qLCZROxguBx3mq3aFG57jqeaAHWZXQ332XFyzYaqtyMcbvEnVx0nF4VgJ6IC3zY2YzHSsV6AmrNyVV0NPlPmMSr8s3cte0pqK5ZC92ZdPINcJLjaoPqtSrkfE82G5sSG673ctvps64zMslHB7zALUK7f/1Zy5GZqjGZF+zGrbqYEwAuyjcMMq0nnw1V3F2UopUPR1xvivQKneWPuemDI3ZtMpfAIzNtjnM6ieuKa1J0+E/1oflb/XEj4FaqvkiRjatMXfQ2OyU/UP/1Sh6k2vTRTygUsLZiLzrFAukH9W41j2OeIuIxYxkR95vjcRUqjGB8Z+Xo/J+FfWuUXB/TLlPom7b+aohR4WrneLwjMBALAVScS76lFDuBQesnzHkvXGGHuaAQuxQb67fQv89omhc+JfkrbvvnqIEWOwWh0twzBfNOfUja6UWaLuJZQT+yY+9Ky+/Yg4GrlsrsdsH+93J0QZ127P3XtxcrhYUI+jYWgtKwuGhG2RBSoDvnOcugCWx4o/JUxJ8bp6sqANZjIaYJse4x+IhQYA6slqMUqlX+qNaXZF7tUpOsYF06VMrDE+7VBnHMLfOIWDVe6o6t3kcwcQvT5IbfB77ueme01XomAa2s8imE/kllo7vmFAXQfKMt/HAjDQhRcTWeKP9pMNvUvAP1FoOlMch56450lzZ7ZujIMY3zWWnP3pkCl1B2+/HPRjegHJ/C+KEK/Ir/U4E5fvlzdfNZAt3DlEEdqkTYOsLWBpxh3Hg5oF+8lTqKW0QK6RL7Yno3vMQNsx1+64YUW2JDRYEcFbwvCHNO5liBKomDLuk12fmnVuoErGDz9BEtkrJhBRxKCwQffvTrgBAyA8aMtWjyQR1ASLHpX6YDgkNcV2lzJBtiXlvXSupN5Qqx2CVDL9ub3m/39Tsa37DEv0krej+wHHUFZFpsMvqO85PIc5qt3kH8ZLWU7JFTSGsaEhpZ1KJZphnT+Cro7xAVYs7LKpyJlww2cKwK36HJFJoSQRqhH3BqAtQiDFmSEIRD1/dv0OahsW7QuxuB8edQIzig+J75NsDxb+hl+hK70/kY4NYk2nWrro2yYa2RTtlOAq9SjL+nFMw6I4EJPlhZXwT4wWqJiICbG6l/stXS39ji0ZSBqgfNMPvUAOUAXCKVbXwboQxJP48isuHLLvCeoibgDRn9e61Nuxd+HkfloEmY+nZTItZMBSmahWV7kFUu2rC+1ByO+GkbxynA8CXo/leafwhAb9VOyz2ycjdrmiNT+jOi+qUhwhcmXe8IYoDRgNKOb/BG0KYy1V2wcdIrCckDYuCzx+6wkvezG9GNBlo8p6VpLuwomOVmCZmZ25SH8+JtR1jhZCUDvdHYlz9gbCt/6HiYPWWMlyVZAeZ+Sg67I3yq9jAInwtSa5V9wq+UbKQASVqT6ag8nfd4zTU028LV+HXvKZ0krgKqsS1cQWQP8gEqIM8da9MmZvEqpZ/UJsiEZkDi5TxTjxojtX5ate5GcR029sCjOrBwkZy0MaobbE49z26YAkZZ7Cu1B6pvOxvqLbas49BxhscDp9bxr+aPb7DNs/4i2KTNlL7q19aQ+3+GaC+p1yOW1WTif60GBZ7jCu3om22rilEP094uIcju2Pk/QEQmtklYXMh32tOD+7PoHy8sZu9ZGQEqz1/OONuHUfJAGM0SzJpGDWTSHNdI03kIx72Cr6MHTWh8RWBb9/x4f2tDLzqFVmpXH6IkLv4y2OX287wvFbXaXVFpmONgikYy5PSDRntxDCLSEl2lrd9T2Fkdtokxo/GQ6PFfKOzk6AaGQmhSli4atRxFtskVusWKPcT4tC4cL4gRnFrkvPmem3MTVUKxEMDcWKXj4s/Hz+9NLX0hUsBNCQ4f6FBGNzs8IgCEnohaNfhU2F6anuU3Nj5AwwPOIBNSU7rCxg4TAQo/jG1E7/5SRETCBD/ZUTpWHRrcwRCg0RsdYoAFALHEnMZRip7HnZREchDVCBKkeMJC/u2kArZW701ryVz8lAzyorDUAzgGAQLO0Vs1vSR4VRaKf5Sg1Xbjc+ZsWNcJFIUUxGY4lHEtlDPUN5MAR67rs8+YXKMHzAXNcBe66gA8SkPDEQUws/oJs6ZH3SxG7p16+BEJnhtrQOn0iI7v77wwoT3AJ6lKQ3tIaFFc0XwQcxZaNCKDgcaWrp3dL58wIlbyJpgc9R6+UCxHSCKXBO4GPMSYQBYQUigqLfOGX+JJMr0qmtNeYvPheuQ0IVWBWkmIuCl3Ohw5qydW/59JnOYOtZmEwIK034HtH2GwUpFlJKucGybKB7gxms6D5B7E41ATxOIOs06mzSQtDPY2L3qLmGXPsN2MR36LHqHAtDANJZfD8DaDgIa77oxYDGVinpTHZ715VYro48D7j8VMrmYOWeqDgxdijuU9pZCKRqLg5qUOYFTeDkqcfSss9Sn6PHljo4gEuduIRMvJ3t1iPx9nsOxfHS75tPlzetl4pGhYkZmmtpVe/Gm1mb5RRnrLGGmQt0Xr7f6f2uNL4+fIirFl3OBBLBlV7/YenYlIQzUrLCsIOAlahmIAzyOs9lZIZXKIanIuxILOSo/JbWZhCykXfvVXlBJ/SblDtE8EIYTUhs9uTuZDMzsP/Hulk4UCRivTPnaVrDaGmDp8K+qVgiOLQp0Dr/D+7TtWIdtz4KlS7FOwSlFTwqG5rVtbo7d8U/NkGfdLpX8na97MRpbj8WavDVMqBE/mz4b2gmzm1Amu+jbCBdbqZAtPuYa+z0AIcERgd6LRGWQGJnYLN8So7mFN8UeHTGBFTRAEEY1EoHDrzedJODkyEPNqnS+eCDvm1CuPxcS6U4hRf+HqaiMCG1kwdOhN341Z6NruZ8SL4cPSCMfXEcDzUhglrAALSWqegxECE0eznYmLCEQ3mCL75fxZ4NJh4qjzSRDmaUdGgO2k5YqgtL+6JpK0kQC4YTbMojTXsIp55cMhnJsMRnDM8VuK4XNIsm+UxpA/5XtfPqEYz3StL7qPPkwjIfC7R3+IPnU3j+FpfgbZUSWEVsJL2NpDr8AMRtsGRHpAi/wpIy/me2ut0KeXEDd+RoTKfVZXTz+3izbfGuJnWZC57XoY/EI4bUfnmR7UhmYsxrdqAXlDBmcXhxvmjwxXdBVhwwlwE/0DfD8L94MXBVY4fB1jRct21la1C2RaVtOGLIA7OKAfWfkQhPlbkOLEJpGf755brVt8o8zdyYrDyXDEh0w5/6oG9+6IaYYhWjN+tkzgr8Pu945ORahc3X6I61WzpS/HvO7KwO4KbJGqbn57mvr8LV22G/NRnfmtr4PSibzFjmh1+DuBiOMelDLOHv1jXUoyUPKMj4cgG51fr02keMxP3/mNqCLmWoQd0hmVCU6DqZNhSE3ayhQQgCvxe9nc2Ib9XjJ0SSwporIAQ+lUV+b9+MRmFjJnED1gdCAtd9nZbTo9YXl01QHv+ZRRfuKfMacWFVexjlS/t1WW2rK8ai7azKigpFDSA2/0hfBtnjaQ8iZGhHKwZlDcdzb15wRKAfu6MD86ynaM9WsqKPuk39qQvfBRhy8/8o5bpqWWQvmBN1s0C5slYIiUFhXy3vKNjkSbv9bkTbLx0Hy1og5HTCsgBu2hxy+7YzD8PmI9Gm8UtzHDClTbTpm/dm1IepwphhGZ/1WCI8WNmxwD7DzkQtymL3QJyB1H7uUATDh3gPoIYLSnsBWUR+6ANGvGR24+U2r6c6NHT+gocubLv6DBAE+aCUISBAakCZV64LXiIS/03kFiYRA8zWZO1LT/uX3Nbj9sgt1jGvqbj9/3K67B5TrH8D+jIDZocC8aZToZPGsXVX4xvadeNRft1r6ADvwqu9WAjdBKNiEczRnZ22dMLPLN9b8K1zo0ZHc0PiPBale4EBNJkGOZHPRE44OIC+4GFoKWWajEpPfgH2yknSdpit6gQXNRCQwX+kwBBHq750OLY2/LlXDxAB3cXDJMzPa3hbgke5NJy1ZRyCuv5oyDy14aY6wkLl1VdqRqq3bXrWc/YLeoB2APOGccV9TywLfv5Tw0g1+tZUBZ93BqHn4MYKybeU9Zg9sYgpDxY9r4tPSH2c8mk4Dxj05SxuCTMFYc1NU7Dps+WG2H+jzXwoA0oIPQbjF92pjdtrWdy8altvwMcmyVlz7/pSfUXAOZBEBBiMbe1fiYBrkk8rfc+wIWowY1dAEcj5jLd3sy97sbCirpZoEawf2J0AVmt4DFii88MjeZgAIoJi+e8HyxMcAYipy8Och/WDian740F8IkWgvhxNdJ4DZJ2V0p2jjI7V1Aq89Gnl5g6N7j4QwGhiOHwOfCR0Fftep/2QQsxzioUpcvkU9PlPxzoiYIGyW/TQ79+arZwYOaxf/0oWrbQnXsA0oR4A2ejaz9dcykMAH9MzivIXkogoTfNJ4kB1v/CnetRUQyZpH3KsFeqyerYwB02ixeYaNSg8SWAvyF1RUy0ONwIdo8pMYSEa8zu/lb8w5+BLJtjN+ZP7/q8kWPoDBGfoLCMlVTDr8OjWwY14cjxPiRaDbasrXcmo5DNCthDMDYDEshnN4tqdDGPXb+ctHXU0bBaXf+i+01kwSsYuaFM/nrqn8txr3PzSDRshas7O904uLd6FFqXu761JcM0XLgOXPU1g4d8/U2pjjp6E34oaxyuZRO2XCka26J/faPRlvdqkeunqiIQ4V/LcA/Ngi5ZZmb2QA/7pXKFx+JSPrQcvQxKLLExeW/XY/SPPGt5ixfGAhC6fFPHmkhTbOdltEsIPN12VrTyuIvtiAuzCzT4+DJtydAnp0wPbI9ADKhXkHqLNo1IhM+4W7Y24sx8KFY4HPZ7LS1Qoujskj4krNT03kYRt+afK2bsV7xDtlr3JY8ELdQOIwtLs86KwQFxtX2NNYLp8cWAMRTe5cGcYStSDboAhNrDXXA7/kFdQV9dsvBYlFNgFLsrv0jaqO0qKWqipQKEhsSI9CTArX0ylGw7bca2l6t6IM7sCUoPtlzqSpO5Dxj6Uw5WcWVG6nyqZY9Y460gFDlVi7vrLYK5zeTtgISe6Se+JHxOLNnhEf0KN2S2NcJdbN86LNbrCPmSrdJU+KerupS6bt64HxnYacUTz/5faos7JWDol4ZI3+5QBb5OKmBJouVm9P3KyP3HBpdOwT849QROjGF8Til3qfPa0INqlaThKhGA/USvZaxgfetipozCVFbNv/5JCUIqrZkFzyDQS6w/WVHUYVKVZHgSaqWkwPYRVH05jfNA1EiO/CDCNdaXFA/zb8Beq51ck4jv3lWQ4a/gvMxTCu8c1MxymPSJk+6ZIcJR8GN/jCB3DXmOCAYBzMm3Sd9YnJuuFC8UIDz3nfxdcIeqeLjG6/HpRmOa/eolM0ywOOGqKqZ90CIYNtHZfPoTzT9p2MQrNm03AsGFJ9qDBUU0XAVOCHZk7VBXeMHN3uT7Uj7vUKQnOisGfglP5jtb69xRmfsX+b6R8rCQE3sBzegQm07YvlJrnEn036AJSM/oEiqeut0gaaSwQGKGAwv3vandYllY1M+GnlkUnwMJkmBSpnP6n7Zxnw8rH7cTXTvnlx9UN8YRo96mIFRrySJ82hX0SEvUTVGHKf/yjggIXI2XArdYkMP9vrnFe6UfLey8kgpXDDAaBhzhZnA/aRoLRiZHV8UoOaIhAGyqmubqEapvO64E6PNhrb+Cay0/X+5IbvtWmnKkMNEOz3hBvnMHzaB0CI1i1YfecSsiEw7BlK6PBd8+YufChqYqjPC5aMdkNk47me3CNXA7elkDYhHUqxbcapMkGnpWz8rxe4EzvU1y1hZVR54STzgt5LqbHdj+NIPtgWf7GoLjajG+Z/sd7cPY4XbjcuBNK7fJFATst9ONe0tIccN5vYtYC8jX8AHau5dtFrfqcJyhth5Cq10h/UoYtzx9lnlWuwC6AWKcSDusCzfhcX6x0UcEzL3yWTHLGFurwz5tN8pklsYyZY+F5G8CuKlkVCFNJVwA+0DFJmhBZKv7fXD3NpR7OEpL3cDU1XaAkKsbn0XcEi7GWjpj0O83OOx6W+9wS1p+m+xHMobdny29R5csY3xDxl5811yjM9MdoyhY9S12BZzmVwO4GEJleVUBnLybPk66halwKv1Dhbha1+o/tcVi9j2NOGl8nNuL6SmlXaP43Si2oPaYgJPUuYWTD9bYNOKDQj2RwybSfo/oDtn9VdcSw5mVGxD2cMIqu2n78yD15uGF3lBlEb3JxISj9R3l78HC1YtpfVbxoC3RaWAZkPcV2i9eXgA+bWz+mRcKeDpBRo7sYV1mMPxCbrC46oDngicnTNCrJlRnEp0kwoviobyttmxSnBPRzSRIgsVHEH8Cl2gohIy7NPwiqDdkN1Lu9SzMzB/tdNWF5dIAJyGqoVI38YWL/ywBahA+vEHRHqgWla0R/qOZ6P9rkKb96B/+MItR0qK6Nv2mmvkm3XCtBYVS4myVZIpWEeXuhTHTh+nDQ5el1Qtd286XL0/ZzHEB7JBzjH6/QoLUKXmEc/+EQkLeUgCX073hqtl18ngtsIKrHuBa37y00aKOzq3Zl7aB1cE3STP6kmGeXDFduVbE3kp9zSF1FHDww14sQ5gPwTO7CYjmDh4kn7EBacmUVLdv2N8WaHKwtZUYoPbdCHM0RX1lPvweWisXs2ASGIVNQ/FF8Igm6NbEchOdcSx/xGIcSZ72/Wz6zNLQFoc7vFgV/GaeT8jZp+whYhPfTgh/SEJfSq9ShT8nwiS9iTow/L5qBILoJkCzZjddxuqb82FTUVoJa3SiYT0f/yN4Iel48x0ftvSL4yinGHOIZSiQWXo/PISdXxD5NrqoobtnMSjDfrhcrHBBJ8gnkkSi9wxOTQnLUZt1J2YVfcwcnXZKKh5aVQNWuETBtLdCKd0IjPXvGsfLYw3MHifWgVlFuI854J1AtaTDDyxvKJg0MWD9tq5LzUdSi5lcWBpFk08+nJG4fPMpaEnXpNcKfiAW9W16uEHOrg5T70P7e1xRWr/vDakfpTxNpC3BvsIwi+xWPsrn5Pu8dUJBOAtxnwaBaIlX9g4bfkSjJqi5By+Nzf+BBRxdvO5EtV5lUDqHnejCJNqE4y3Z7mE4bQ7wdJHBLG2uRNTBh6V8G4b2x1IF1EQ55DtvXuQUUM/Vm7vZQDouF4DmyP39dgIG15mvBvKWkEReax+WHbxOfMld+5V6ZytRaK92zK18xgbRwtivI/XZveQTEVNVV1f+E5gfnXC42DotAACgzsFO98MGuQYj09/Y74TMXb9ZtDM7WUCrbfHv1VBJyBPEoi5macewhFF+NMDOswp9mmZqAJ1o8WCWGChdmMk39T0zmRY32yR3675pNd7ZBn/O2jah87PNReBVxOeYH3ZJMmttIIVp9NCSjra5T8qwj9339BOhVrDq0lIpU/W12j3YR8W4+BXLTW39MrPu9MUep36iFAIUnHRVXUBOtSD0HHMZh7pZxyQYCImfHdCv1B0RQ3+8e6JH4EKFJRVJFDbDnh13tOpNqGSBoyCRxC31r99AqciyJpcGYhNZMPdI4M8ZSxgWLyGlanWXbVzp7KFZyzhsN8UddBTsI2qZOnc6iHH0UD1r26mSmXutd+ei9UxSR3/RuLx7CUbKoguzvoxbkisRbZsxUSo94vqBj/Zb/aXDKNUEVPMDeKS8GtGxuiuooIsxu/NbxbMwtFbPGOEAzCu2YHqHFrsBbK3sIjZvWct4ThIj90Kg10eGFTjKhh4fd4y9txRwswi69chL2obz8nHSRSCC89auAx8wIzOhpCSblZHGvQUzqFmOszC9Zv10mdVISkWcrF1gqbqIbcymRepURX5VrwaDUiXmHg4yo8mSeHhjnpx3I2/6y9+Mw8IDP0uHwZYELOPH5oO3Hc7wUzvWGALvoMyV2d+H7DNWFP9AKxeCvvCzFqqRuNmHHT7KYG+gp5+vA9x8DRj2UdhWLMJPTvNlPChK3zfjYMpyy5aPSMe8ovp2+lC77dJS8WsGEL866grv8r4TQUaw/+mhWnlhT0KamB+/Ad23YhbhAGxBBJaG0NIFYqJxmBSy790C2zMaW6jyenwxqyeXOEdwq6ttywoQ3f/oxfX8OkPzx/8vydwLDK0Vi+MVxx1Ox7OMAovFnEQtzWUgA2F6s8mtNXVeK35wGOgYrI2rMbPCs81WOx9y3lUH2IcI2fpbyBvW5uo2xQdE+au5/f8pHgOh8zE0Rl8PA3qboxOEbo/2pMd8L53LSSkZYFtFMzAc3cAME4UvWp6pYt2svgFG0Wn7+FuFtAvyQ5HOfrsP5y49pwxjjF6d5dmiJ+Zl5Lc4RUmc4SxV4+rWr0iCidzwdGdEilFuCzZ6Rp60FLkclzyltBMs8c7TcdUgLEIPcb72DdeSfJeGqtXY/0bgit/Blqio+L5HVHYrRFhwbLECiyRFiGF0zirqj/yu3fkyAS+upggQKcSFjb3ttQY/KBqf8iQyFJRwcW9niVGepBqREqNG6J8HDs9ALOEdoGx96gW1zwdGfK+ElVt7kuJJ3BR85fZhUlft6okie5BiUxd9ZQ7zVFOYmZGBBQkJqSSe9cfbKVTXhO9jK8wd9lNHjtcqk+o6trE9CFL4sddJYX0bi1EA3eb+DjlnolYc7jVfJjnBDlHLUQdlp82q+MxhP1M+T09NimaU0LWhceF8vT52RkfcriEUHbJkuhtCdtvOD9tDzKXcxiH+gauj3rsgv9S3UefICsaUNLh1xYNaVRYBwSvkqRLqHQfBgNTEbkzf47XUQph/OZZnn7EqIWlrqaxCe0yvTfNwfGTYkdQd5bIF+YNzVMTTWARn5scQrDFZBzbJ2PrnWXN8irXmXb4aRj+l2AxIQvtnt9n8t7XBOknhmKHv644D3JTcYoxuTbWKMmoU7g8FzxmUmubhaap/MjL5cQ9J2TGo+Xp8hSMun24TbDm2z4+VOxHoCuC+JBCyf8Uj+LLPXrAOxdhvuuHidbIcWuu4KHtmWotkZug9OoV3s06k4W37/OCjGbEeyADZzgnBM3vk6XZOYb2Fnybk9XKa/XcnqmL7LXXovzR6ATSUYzX8sDrxUfS352PNsmoiiiS0e3qTYX4mdHzCzLusHjBW0EF2/LfBYuWTfwB5n9MN7NlW+1q9JIj382IA0ZTIXBs27GNydVTuBwDjvnMkf4QxMPUDAEhvSonhgZfrkYf+YUor9hTRHuHFGcYKeiW4Y4AeaJCsM4hXFmwqFV5zJj/OxOBUUSqUeC0MkwtK2AxqwPjLdW57dFI6AzN89L018Sl8Q9d1+SY3kxqCZxVVlFG0Z3mku9A2fevExXFwnVGw0T7MTRLHBAPsnnw9aql3ITsSSUiKwukXquAgRasgLsklZb9hvirC9i6TfiRf5dtSRvDvA6e5QWESFsCfqNhBKrzGhp82tOrhgVmLEFirgC6k1pxxmJPznIcgIjIMpGLXDsNpyx3IJNx0+x4rhpT29wb0hP4vCnQdaSVCBREUZPCdEkvr7CSgBTu4GhDcf1yMZVLWXCfbM+f+Qv6OPgUdSNjFW65eW2myowegdjTvSO5pKQwBsF43mHKw21WxcSFLp3Ip9iCTi6shV0yFkBBGDv1kcG3eAjN9ndHTsFW6wTBRwQ7k898qq3IfqPOXxf3SJB44/va9cqmMfiquxc0gKUH8/H9ATsDHQRSOAgILLCpqBlycTgtS4G5CGgxqIZ29GFs03/6pqw/uCLhNyUdkdufiO2/+xFN7/ZhHS1e75BlzyudT57O6L5JCzo8W8HyLZwdrxs260u/CgglvGIctn3mh8UsaHgQWoPv4C1IGP1HQl/7xXCd6ILZJhTrwQ+uU1bbh20HfJzu0eSXy7cpXUT10pFrCTslMKIz9IIWqgUfODf0pvWsMYqa5yyTTu47wHT+Uy+8zHzRZS//VeA1zqOix5lO4D0loMt+dhWu2+IY3mDTvlbJq2I1kVdoEyOkTdegVtqL0vN6XTpefTtRdmpySjJ+HNcwAJFKDLIAKcux8zvPwrqFdAzqSLXy/gKJRsPIxYOUg/fETboDad2ezezDeGCX/GvcqzsLhZPZc1EENatAlFeCfsLhRLSDN2+bU38x0WEt+bnN2ESlDIQsDf7kPSwJU8Hh2RooSBDywWlFbiF35fSDwJ5P+3H+QVD07Kqz+Q6z4YltZD1lxvaPWFAH0Xcq0KzFBoeFQQ9EjSO2py0YZVfRCCi9oFUUKJEvehKsQILqjStD4Sf6YDB1br3wZkpXb/bk68EI8LhYV8vLmn615EBk6snM2MdQfTCLtp1W42IeNNzOl8wh5pFPjCCn/yw7i2XUe39fm+IZA/epIuK0iGp/nKUiiOfF4SmPp1164mBfTmDI7wIdW4QYGZ+c5BnnK4aS/m9qhb4dK5YtbMJnl0cLF++9kK/bfmFBhJdgkuLvuaLiCEHG/TFPomzXdViU/Gposa2LUipi8X/GJsj/9Z7iskWzv7JsYoYtTyrbmh/GH2SvQJCDEkSkf38FHdZPx2TOywG1WgQtDm2FaG6xhfTQ/KDkF5mCaOcXZFPUWPOgj9nGyqiUAlHypI5pXVVC0zDIYbdEUw2+STNXWLKtkvHlpLO210ZKqlYRL/vJ+OWDVB0K9Z1bwNqbKWXLMZeoQXmVWePkvqGQ30WLm/IS4BIVBXP1x/3Hu9xv3WVV4zL0ZHK1WxiIVD/aRxtLauHd9F70mF8RTJiV96e0k+zrclGJehGskQWW92Y/TOgkBTPmyxrU1ST9Z7gHl2RWqSfjdZSmt0OIcI3L4Z3KIHtBNad4HZ2e4+NlawYhbO6MrOys3x4K4+ezqjaPAvmq2Ye5H7D2M/WmwL/j4A9SVEPRA66iIMenhjGn0pXEA0wrcFybSXSWIWjOPbHtHc4dVOZgvxuZgbSJdzaMGERDqXRe+ho983YVIXohJFTT+V1qj/l1KX3j26qjMRNcpV8yT8pbIStRxbQiSERDGV87HkrvF1uiXEyV5Ysq9ywlU19CQUQ6tQphiv3rl9QEsss4Iopnvbaj/cSjM2SiVOEr20Vm8qXPOTv4Yb6EK6H6a3gYafG4znBy7T0l/x/AhzdJ/V8GJ/920p78u40y8gLsTKH6L1Vfh1KZKIkQwC4TWnApvjjNv8w2mtDp0US4K35MH+/yZQXqL4ht8sjZP8drNuqCc59cSvbv4v0UKZAZ9P4BH0QCxQlL8tw1Xs/GBJBLD1o8dKSjhLcjLTvTvHPj6ugEHbZ9ta24fku8InEbdtEToJq8UJvSwsT1gSiPpTYGBTcXgWFHnxLNI0zPX6EipwnNAzBKzDP5GK9iZwlN6/k1Mki87St4m2I0zl+3lvYbEZxxqR7ff9MVzzaWlHIq/v3EtzAU2pQqC5U6V5LozLN4gBuY3dYv0JAky8ATaBnZ1UaAPG+8OOVMcWGThpUp5sqJu1K8+S0xUORePJ9X+wKkDVO6EAmRKPm8oHJCoCDGeVI16cnnTA/9NwskGHqt2R5Vf6GyCwIfViiVud1JXfPYRxkUSYXNs0JyiC+2lb/JXWGBEWbWXSth9F2y07yYuhW4MTzMGY42LLqMd53Xy3s4ah2pOPwbQi7iF3//8UggN3f/UsotZQKiU2AYW7TDUgckwnuHg1/Q4OVHjtti1ScybAbPMnRZORN437N6zmsaIuH3lWI3Fyxkysg7mWpJZHTEDAG09UiCEO7mlbnG7nU77VI5r6VjW+yrupyoNXfVL+W3e2DpMHMcBk8hbJFFTbbl9Z6KCtW6mk1YcT8duf/9NH9FEGfAuVqNKzuK1hLK+QECKJdsDrKwW8dXj2yGSm6leUIbVV9z00YykjVG+McDlj5ymK6NMcZ4teMYN3qF4lqymHPVVSVnuKIX+yMzJ4n5MSjB05F2GKWUQvScIeYmlzRhQoWZCicqXc5dGcOTl+Nx/B3V7mJufx2fGcjBKmAh0XZwYooo9RzUINjXHFFt6RX+fRBK2wdRLYSSkkCaj9yWZwJRmEiDWesDNbcctME/4aHYP08P8Q0Ikg5P/y+AB9tRkj4pg99CrRNtfcyZkzKxPbXhKk/FY4/hAbafGAJ4nI5kyYPxQWiboX5x0FzXen/7xhuUgbxKcT+U9ADRFoBzAHamHqbMPVzpR3m5cXUNeGV+7l/WZ3F1rAV6y7xZ/EXqN52QA56lQcuJm+0ooyLmebFhXSiOW3ODFAZmasICKAnPL0r5zw2/e7kjjuPpzcfHcAJa8TetwhdFWXBjIknLOH1vhsBNONRldtxlM1xsqdSXonQDP+TVwSJGhmRDg+kk57fqdWHZMOmBefzC0BEbXs5E7nxQArGd1bqVebtJTiybcL+7eUeXZfxOM7yKo78DH7KcQeU3uP5OmrOoVPZEHkPPnXml02K6gY9OBwqLFDFTESP351y1OrIiJjWnkvfecD7850DHC77wIrFb7vpYYnDvtzzcFfI14XBo3EJH50XWRXTpOHgM4x4EJ8c+/rAihyvZ/4pbVYe3r2BtY3ngWsYXr7oyRhH5OGqu8XzT4z8aZ55+NQ/e8r09+AieV3gqFqdXN6RtqKKLSe0fffgQtOx6+UHrhVee2oyIwogV2lTQ85wQIs51bM7KKY7Ab494bpFXquaVvFQpBh5YGAh6uUPQROhjMOjX0aj0XFoGn86WhcvjU6+hbgjaU8bS/EHIaRveKTgoXvRjqow2mdSq2ZEXfBX99TmRX2Iw/YpCzmskHIsy3LEbDZvcGAd1xEFeay9gGe9M6RFh+7yabffZhCdTO1L22/FPd4/VIMIExpY7Z1tThmh7Qo2VnaJAHw3q6b92v0uCS8iSVCSD+GTE8z77DzofmaG7VNrTUFERLsUT53wiy/6H6l3jQC4Op5z3+peBt01FpmLbg3gkBNk6nXHThpJAYwsMveRAycquF/p0Q5pDvBlVxM709cdObqA8tq38PFrfhqlAcZzP1NHbjr7LxZYgbea/8uYHJ9BrMkCjb8UUof5RxThxCIohR4YTLhvV1u0ixbZP71r3Wt1jX62qliKNXFpg2+xMCFcrXcsS3wf7h5lJKcKrsRFO8kmphTvLbguRhTCz+7sK8qVSyn4ikD4kVSccszHY1ZRpj/P0U7p/lN+fwsLsJ0zhRpmmZHiXTvIdwShM0hRVAfRAL8kxpXqdM6f3Kaj516kZkcqU4+tKn7DR6dNJ7EF+zU3jLgNP28WVe9ABeiL85IkxIdAZ2TK95iyTTOEicVZSZzXJarWquUV5Y6DJ/E9jKt+5tciv7lz3RnRCWBzWcwzeclE2l585H1NFUXx9t6XEX6uskfSkEL5rrm32SwO4YQ6KrbmZo4FNEr8gEb/yL9AXX/mA59aNCq9c/9VHDNB0DcrZNuL/ULhJyOeI3n3EBtBcknhRN3xJIHquMy1rwllTaY6EJ+zC7Wx5P+rJ7cYMqfejnwGMQJgxnuuLQlZp+htnDq1nxDJFELyD6kMuK4eFedOneOINF99lC3ajIwjf79CfZv1fnoiOztbN1zrdgHfV6wKTDcL4oMkV6z8HsitDYSfDa1T0O9HbO+jCitlHOwv/syNyZ/e/9ywcdAapCf+JhsHnluM/dbMTeqwhGlSdnH5KvvHGBrBVMHz9lCn8tauZCfUHoVO1k7QSMrrAbGYcXq+NSShSQaIOFOtdUwOs2LgRpIa1SoGB9+qT/044C49lOvIkn6gHQBg3aYX76X38S3JYdfgrAqwKMI3NQPCjupfC2qwRlbpfAZP472v8aUoOFv7YlVsgopZZJCsPem5z5V4TDGv8vspsgpWPGqtHROYsyczac2pCveyBYuPaGyHs44IJ3MbxkxVQkkA7lvHl4L4TuZnZrOk5rHwuuoIvwBgUsJhoZbCotH5TGJHjd/oLCqEvVPhKVwtZnHkj1nJxXLbEEVTcC5NK1I0FIyTyOE9mcIAtepzOYOb7vTcIGExLA0kyQxn/4n/xEqL8DZcszx9Dmwj19xKvcBzc8o4y3HOCnPls+4zaf++rv5pPbolwOXoX/ULfDisOAdDxC8dewWwsZ6Ncl475dhBTjNMY3T2s+6YscXypTj6JJ5WsMKnaE3uiB5ZZ6bxMiU7TaTNdk/r25EPDt7g2WojVhYCD9P/CQAOJm81UnntiPef8RKANEIvYDEk8z2lxBidDEhiXa04RFfupaYOlpW6AxuOkhunBmtZ3u+sZ6tN1kOqGAO2UShFBrKk1E+tlVStzyIocoSfK64ximOVC1oj85kI1ua9IgZm4MyusGRMwTo7hSjavCzrJh7BoxIgA2aootwh6l3PjrBJPcYFT9JjNEznSJqB4b+b57ZqjINgH/nAzrSzahIHiuEu4cc/KjzL0nXGGCdY4bnvjaGHv3C682WBBwq6wI4BQyxRnIFVCXIU4JPRb/4wKPlYjmSEIUmoGN3kb9HWPH1zzBCmlGDb5G5kG1alof/2/KF1SzW5AD3zKBe/YqsNlZmk2Fs+1w/1y0Os2+S1K0BAiFoNsDDG3RnhLtk/LD6kSRBD3V/DouS8ZBf7ODu9jVT1GWaPfheE+pNsvM9hNmeChb9Y5Ci7rM52nvCHGluGrsfGWHnQYIChpH2+yKgdT2ejRxqCdfYMnWc5hQp+lGWbgo4XqHFNQ1rP2YtqO9IqUYKPVOhRGNanN4wR2382g3OO7+ye0rtxv03i+dObUbP+yLyhSa2TpZbYJ3V8KpSVjtaEulYDoPy3E4aTY2vpWfZg9XXHqfPCbMbgpNC6iD0MAtDEwSczf0/mo1ezvvZwhAwIsX9lxqArqxYFJ4un2q3wkldW6WScwK7lLpXuiw459+Xv3f8/kj/lSIIHoB01udxJj4+diBL+q1i/rDYxgov865cLbxko3qseH4LFbH8UtuQIEHstwM3Y9xUQqPU/aW6w6ZmkzJuEwbKHyuaou1aPwwVKhA4Dl7zFTcescRJKCKJo3y3TFi6CZYesoV6aFOrXipvPUeNlCZxixxUBsS28sacRM0ge5LME7PbUK2yVV8vfbjRfJT1i9QHWuvp8UXPXE4dOBDa8ob2yefSKlyX1waZ4cAcxIqiWSholM4ho6bqZPNI3EDLFbvVCoxaWeak7omVgHCSlVyXx2orCmxjNn7R/4rTe5bfKIN0euIAdMIOgS67jCaapRaaowNLsdH/HCetP48WjAZSmSadWHpTX84XsSMu5OTKnQTwSyAnukpFlw93YGVq/OkyPo/uzBd/sxsIxLseIZ5q6FuOXwhTOpusenFWGqg/rKEL/ZX9ZXUPoLKXVhPkjfOMDn9W6a1+MKKINN6R+UW0aA3jgTSvZFQvx9CC17pwla4shh/7xfd3N+co/2Tly6UfaUVKwWNXQBBxQXgPTilqNwdzofkJMqwuoWZYN9GvmkjKDVgrDimUfj7PA58Y4ERbhpDKV4NNUS+wbmFyfiKfZ2Yl7vcAJBdcPbfDAI+M6QZW+XKnF5wiQvgy+540HX/i7ZPuIK728bolBqeowv99WjAxp4a471maep3xmQQj4bJr4hTTTjd9dFTdcgm1oulkJs2ioKJ9hG85trQK/Or5gueSrtGmoqytGAvAFj5J7uYDORwGtjsjCVnnU7YM0nEv0hkFVDRgkHRRMbCpjhs5WvILIxv/PH24kd9O4T0JtjgcQ77sTzIpRa/6Bsl0cEtByn4hyCbPDragqq4RYSQIpr/Le3myESHJRa84ASsjDhabP758yNUckYc6l+EXUTrN3os5rd7y/0hjvi3OoYfKZD/WjlVm6m6cB/x3H57zJwVptOu+zdJnG5yoPQgruXgE12MkW53ky8vWCuwzWhrkUYjlS50O63qnPxVjRuP4PJ1ss65mzR33P+j6pEhKqPwAyi5p99P+0GZ2LygUc9NDVnXjgbbVo2CmKAvBp6NH8g7YBe4JH+vj+dY+4oA/4vSAKAV/LLV/9u2lyc7k7xRrOHxDkw1HllKgnNBho2c25TNn8koHnBqDeT/SdHecS73/ejY/+lYyxT3rsVO4d5fB9hA24eNZRM2fqy0tK20d2cPJWPbHj7XIktUkS8cW7MKXKpYEuEXpAAfgFECsf0FO5yn3I34Tta+pUGJ+gxl8SX13TsJSnA4yqc35raN2mrWqfna9VnIcq1/qwwqp+oFIsTKFMGHz23HmRtxdiSSAgVtjUjoFoava9GChJESwxp9LzteBz7eSRa4wAKmaOwC9WmewMPutiV0RF4jt0EXraVLRIfattOqwqBWbetSt+YBVtfUdK0TOwe3p7q2UtzIcdVy7DxkxRc7VVv9oqT/F0kjpbBQNxTdgfzuVu1RApQm7vQR6aKO9Mj+4QoxWL7q+nwBsox9YWJyo8qWVTzRpQY9hQ8dpOKJ3DcLbKd6u+Wozp5l5ksCIP7SEV9f42+IB0OXIMskj3zLseZWl0h8hg2U8GReBo/Og3j/6VrCjLnX3gA53P3oPOYuFiT32Tu8MwvJNEZtWi5dGSxLJctheuTnMArsXgUD0QnSdcW12iAesJOY+xkNP8uFC4+Fl3zXYi34Ezw56PHG/GpdUFflEgz3mOQr1XtPEqpupzOQ9jtjT813ByI3HuHU61MJsQC65ooGUEmS8O9d3TXGVWG2dtVEwoi7jXWzUY9NFdbVqeGBV/T6nBBH5IwCMOMtUaeLIihg2p4WXS0A5LlS6Ed2CLjdoMIqywUPcCSoVJ9bWHsHlHCzWjM7UZPXmGhE9JllR/M7ps8+b90xMGaP0oND3nmPR4xv9XENXxZ+GJ85ypAxRJNYCIIKU3+hjTfPWe375svwvK23i3EowkYeWBoFG2faDo7aJX3UuK34FzJPPzQBcMmJiFH8VBSJKEuhPGSmVIxbhnWLV3IpZFFUDTuPPpmfvtZJmdTcQNqQwUE+U/KudHZjI7+3oU5o5qmrnSGQOifO4GjAPBlomtBNeh9emCiZv89UeJOZfPmV1lVfQnfCWEIedS4HUHma7rD9EO5+6I+0M5FxY4be1qESwYfqRZEffCyYDjeHlb6L8bib/OyIpJQ99K1I2SglIH/Asg+RmfXlYWvGYJAtRTOdO296+heohODWGiGSqF/fQGWVhnlzgHbW4su1A9YOgPv4yNWG3H+4guYRKFaMCQKsYYRPXpw0wBK/c4TYv+mC3MeWqQyaeB2ZL8SVwFfT0J9RiJJwj0uuGwmEaQ+PC6Ss8B8Iky5TxfU1nO+axWD//YsETaWf6BKCS0oanJBXZLCK+W41pNM6ygNuxWtmhtZr5XeNSAbpEd322O2i9taZt9DtB+8RaJH6pu/BsLGGAdxH1/TaTCC4tMyqCyJPaWOfJ3Uka+MZ45qaCURsNIl4E39XiVNubUizusnkaw29K+FRdKCBqEM3Kg8KfAzO57KAZxs3E+ItGFcpS5X/5Mlwqzc8SbIGlijiE5LMoe8LQXOiSzXWdFsAw1uZ1Dq8tt2eRUWhzCkBmH/OOMZip460HvyLVIGLqA7i1wJMiRLtZpgmhSgPkBni3GMAOS2nPRWetQVPTt9hdQXKIMiV5gnwfNaE/rrrlJMTvxjUSP4Lv33/M/08+xqk2It9P+pgv3yEXRTEAbmbBWL2adB/SsDTgngNjXC3SLPpgWkeps2F5UDpfL5oa7MQp0DCWf0uKW6vawnHkwMQ9yRwwvkr8EiKHyOZEHkYZcbdL76D1kB3r9lGr3+Ly11+aKJwYTY4JCX/L8oqz+1Az2OYxQ1RIacKuNuY9Hs34wJB9Kfp/5JWHaocElFIaLzy/pqhlR938kBpkcfPaJAOKcQAS112l8VCLStLr6OZh6jrVZie4lwW1fYYoPbEywEoxwJft9pZG2oBqvb5tIhQMPbvfxTV5ltoO/kDhNod56L7tOVFWxtsBydOuJ/YyGDw7UdV+jXaHSBR+rwA4C3ZV4Jti9IdBe5+D/FUDn8N6znqWZ/FLpF2BxV9psMiorZ++pDjrtWdQ7nxy3qu2qstJzuTNzxmUS/Vfaa91FZESu1dxrxKCUzEdU9MpLWkIBqSnZMqosuz/TRNDHDQfW6iLu5PtK5OMI12XMY1KeGlEUC1HpyM2D/xPN/b6wvLYS+fO4pEdsd2VL51GG7fvIdtruMPwH6X+pg0UhyPyzmN6WcikPfFyn3W5omrZLQby3RFrdI6dDY1QZl6y9ZZ+cbUm3FNm60slg/1DbFbFKh1yhbmHn4KA6tq+zl1xmV7E8E2CjDpk6Q3x78XKaWvY2GEpGZgHWhGVmCu3VnDe5UlugrKoGpV/7GlOc3BLiE/OoTBRhCOmZL7lWcLRp57YRqxv87BNWrhsDl4oBSl1n9QUC3vUV4ese1T4vBItv3nVNZn1r6QXC53Ih4T3zkwpFotnfd4WewY7NGD/dSKTN2K4ImV9S/wug4XyGySxfQ5qWckncO/4w8goU4hvORqUUtm2dRnrsdG6oS/+WD7qI4TSi5QW+40w/ym/lPmOCWftzZD6sPqxoPD8ir4DJFECaRbWdM5r7TVnTY6EKf5IazDffxX+s//213DujJEQxpUkQDV81IoVHhXK3UFpXzOtE93OJQ4Lo1HM+2epoapXCOvqxHm17ilzdKiGpbOAfqe1+s4fJ62yft5Ql80kEHVGASxtSVxkQoBjSoSsUoPv/Qg6HCMU/u7oMjo/7Fs8jfOXZikEBnnRI9VvN8LJtBTTNyazbzqq/aQe03HBDOQBTuca5sSPmxR3I7ZjK/tr1NpK69/jyH4WIrng2JvGX2MMllkq6aCupoFBqgQB1tCNIUaWBK+G7PBPVfluqc7Lr2ftCIiFCdcsTANJ4OUIes68kZBlg17pYJ5PU7ofCjkC+kHFt42f8ROndCAFsZrBXMb4Cag7oRMEnhVVKCOCQ9suw6lFtJeDzHLNFWkJqbgUzRIO6y/u5ahvrE6jlfLzxXtJDnn1w+f70sBkaB5fun29SV9oOLdzA2FTO2+IILI08Egi3hNJYSrlFdpJ6ObvtcDl5S/f6JFJCqKNq1X89tuNxggjhiNSTnsHD6PZKvahjjGju0bEfXoXzlnfZLXs0YdQYSeIb+FbKD6zIOJizPEDvUZigjefTXskjfrpuLh0QmWXlRN2M5yH3+m3wLXtVFZNqoEeBEWw50n4eo1OfgC7B7ceFGbca3TkrjDsXBsw8ZHLLLDu06syKYBdRoFX+txRkv3eBAoaeXDh0JVqlvAuGdab8PZrMq97pjb//X9qoPxBPbGZbwCuyYFlcUdHJ+z6i+ZJzPlR8SgYxqhhkXdpQFwzEDEAYIZjF9KvyvIHSaTxZZitDOPucgJTJSz3BTJEBF/NH9O0Bzqu5AlTb3bi5Gix1atNfRGSuwwKNxSstzTlYgVMs/Y0w+cp5r3+uCd4lzWHyRBXeGn1IeBd6jj2OuOqBbMtZOLT1GKvealmgqtvXKaIO13wW2o3zH2WSJbAHFsQVt/NgIezQOv1qVi4wQSVw+3+iEST2TjbFE+H7SRsEi2cHRukP374f/aBi25hFUufgUQK6/LNbNZF3sw3tK7MQQsbFA+yC/yoQPzKQ8t/d1dlvQ4iKIqtufiG9NGqhjdMlXcRsBEpQgZ9Zd/58XgeSrtPitC17oBRX0RTsuiyHWTXyU61nBd820wdfmOjtT2+qFmPIsKlPAYysYDqO2q6yVc35IfeSQt3nmkM0GY4ljX3qgcQfuiZlq4+JDR+vl+s0l6Khtw1gHCmiwUufHoimzgLnC7+5QuNtLXembzNPCdkZT5N+SclVJbg5pDS7Hnp/Oo88GePXYWrRQCPQlBT3wwIGjeBqMwHxcMRHV2VGrI8WSURTvpWKnKaZDn1p9RVPM9NgOy5R0iF3sW8/gEz9gnXzQs3M6pLBW2D5iT/7+fPRWTXTIxkCHyYYV7juB/t6HGMZEMBka1zzUt8NgvaCOMc/4RA3nnhez+dpsWITds5BvpWrLFvGYpI0Px6hpKHXCmPM8jRi7NxWWR4A9xY+DqI2TPVKQ4mEqM1Sl6TytpVTY9KnpQZe2beprWRh4OWq0EauRaRC/pxXUtrIwNYHc5QvKVsoK5NyEHXHdZFtgO2H8pCw+jMfd4pvlleNW19x3hhbyFBPQHQVHlK4x6oYs7BXWqigj5nsaQd0sQEOine1S0+hB1zOebZKHdr5A8CmK6BrfcMnGNHd1f6qf7ztq6FNMjrq3JfwBbTLwvGrPAwD/gThD6uvek+BvOGQ7/6uwLnopS0ttiGSiNzX8k4uj8ItqWzGf9lbEydMHfeJFvLRx1RtzZ7bjvFtT4eb8TPX3gpvX0S3z5JqgxuQvSN9oCzXOY6C5nQklEAh7ko0Lp76FiuNA0JVABiL/WLJRc0Tn6Def9N+PURxWBPZOCl/6BV9i/CSxOy/iLU/2urBZ6JnE27qu79tAa+JX8fVVCvdaaT0RdEqTo9S3RC1qUd0Yb4YC9Ec9f/hlWoHhT+ynW9VOUPOFefsDAnnyZfvdndezScdqN334RoABLHB1FGujaos9tEu3h8fo0veRIsXVldusue72LWJSPoSCyR6d1/6UwW4LEE1KZBmQrmC0oF8XwjjBfkT3lTapyyRJVgu/x4vBRaMKpXZlK/2scKfyst3ihRoyXikOxghaMhcE5IP/H27uwmhWP7b96hBnTwtUW76yc6sgC/vnXNkN8ajGnNvLfh8UkUjjWvn7d6QUwAMjUQ2GfcWw9HQWrnOSV8ktXqWJQbK77b4pRXDGATtFV+DOpFvs5hn2XCVEHsgnqMTaTaKURZCqSUK1HuSwPDnzhLja9p42M7B6m/7oQ/pSBqWvQE9C/1FcEFFxSzkzXLa4DXornCUv7Ktc/V3RnplWt/ZiKR+uP98s1P7zuTcwxcRhzpB0eJ0R4MRp+DrgdJ97KlET5dcrpwvFTGJ6wPs/x9rquKsiPWXbC9AwhxrlKfMgcJKf/W5uiAY+BrA/zOH5yDZ/CCkzSV5eyQGcHkGPhcnc/YI/UOZepGNeNKJzuPSqGw/TLEN4sWRMyjEKbHpusAwRmAyjgZ/d+X7Yiu4Xt/XkS88jBV9YyfXAojjLiJE/ziHpe+I1MxV6nzxZRMziQ0Ofdz/7wzIvMpyefBswB+bkBYJu/13+6AzfVzO7diovZyx4RtDEL1KGyNoa6TCB3QzZCaBhZId+2rpbbwUL4AagKyw6eCU0rbb5YMZtYBxkMN3oN7z06rWd1jzUxCwRtQFSvAeULYFbCWmPHHojij4vsyPBahYgjvGcVJlDY2Dmaixs4dg9JYYxkts/MukLcJclc7HA/8xChNBURO1ZyrsRMZRPyQqQSRqE8LKuIhXMY+XUJGd5++75mJUMnlRyan6IG2znLVyXAsua6A2UsW2yBcUXLF8U18BhmFeiiUUqH9H7GV3F8n+eiqiqyI9+4qzYvk/SagFGdjyGFI0YZIMgVf1xLL0o3LqyNnyBd/ePGS13HxZC5yQVuFi4Ec52GqdfXVGeUzaZf72jME30YyWLAyfC3k3ZAfLGG4Jik3vlFthNe/l8zHoPNnj+86l2WBCy/A5WaWhOABykcPI90Hr2NB8h3/qZe89hxjCTq7TGsVU1saMrUcdZiRhs99EgMCaKXoyjWVVSj5GLjIYpKAuntF0ul2jd9jrSkkpGEDIGvyzL5z0SeJeQ9C+T6UI0OAq68DNix+nbumD716hF2t9aB4JIqSQjnWpWZy2UU5YeNbwHOaLBVMCcEFtow4NEnQk0ijKgIkVi35lY97ApsS4EUGioh+CefpdvDDERGPvhEh2E1t3CnMr89qYVtuVxoEIQvDRwz9lYrLVCUZa6BIe2i4Fj4KqSgQuKOttNN1nW3ilrR7O5YrUIcyiyrg7QqlI1qZ5MT0BMQP59RcuaTbVCsb/Z28Gqs/e/grkhPQhg1DO6z6EKYe5WMqehcLEHETwxlTZE0joxS6AWSDz6iGH24Aehq6cnyW2EzRhr1jbDP5OoR+oGlOUTE9gWhQSlxZAmKnqwJ13yggkiXxrMtxCgrmA9liawzZ756SAPCMQf6254ceWxqleOtMZ7Yv8UTQFcRTTG2MbaJrd3h/+A8VmZlc9ikm73RHHJCmynZFiwHSwB+okvVYkDCKcniuBtu7wrwkL4vEzCzKVGY7TIidA04DEROMRPNaA2CzN1lMBnzc7MVZthGVfOR9fb7v7fjlWMwEUfamjfs+kjXsJI7iXBsy7pcMk6cb2OBKax0SzpCLEhFEjytpXfUgj9AQtuJOZ/8y7mgL6WavXGSz7M9DK882Mbo9yoVhm/8jJZHmcyN/LxH4APFvY4kxW86jMk/eg/yBK+S29XZgJgXd1Okj91JxqJ58KjfiifjW3FO3X1HMPxRdFb/OQ+7/a3KaJeakM5oXzPPHfcb0e7Q4+pfBxpGNrengcWVslTHxVfifT5S+NavMsJIX/Ni+S5CPv8lUSZiPZmWpI4CMPx6IUeK8AyKnTtsCU4dhUJu/8H1DZyUjeGh1k5YiK3JK/znCMv8tqBHY6CkQoflzdxLAPwxAs1dW5frXO0d+zRuZG6ZC5AIjwm2+rX3qkJE6uxB1B6p4HMspTuRqZUJvARrszC4Kb/WWxcQY9LLQITeQxqHA7j9Uyr57N4L238WQ0FUHu77uRIUpl2zDvVEX4PtFl9uCzz1d2LVNHq7y7kuEHtCPDCv1pOSocs71jcRxJFDezPeRwSgwbOu6XWIVzTBrWYSmy0Jld5YYZB7QXy9p3YUH4TYYzUO5FGKac0BxGkxMDf2VmFz72FV+71rysbchWUZYrybDUAHnutsBkk/n62u8dLtISEYQJDus1859lY1LDNX+SzluOy8+uerCBbTaKaxnr/I1Btn8hGq9dPSFCCZCQB6o1Dl4WeUlDvgHv4i+Xx58ghf7LMeINI2B9rt+Jin1pnt42c5z3p8rIUPlcbVe7RS/z2G+NX6d6O6JAh6K3D2oiTV1DLQ/nU9MswTaHc3UVzhYJkviKbmCOQQx93uSpG6YB2MzY9J4PKA1pb3D3oq4KszivYVqJU3KFE56WsPUFsXAxyjPuzYTzxUxj0WEGMEU5Vl+4MBq+GLx9pZ9EQCQdTSOkIYAwj4on94+wReUoWWJUv7Y6t+Zz/JDwem+lzqueXt8vN7lCRJmE11aMAUtjS8YO1U8kvNxnvmzGDC6qsf16AYSA5tbrsn8ds79xWcD+TuMyIzCn5m4iLLdCAdVO8aDflrSqsbFerKxmsRmoV29aoKY8ZJ3kvj+26gX8KkGrfh1HjhNuLfkX1fUADbuKCPZm3WEP7FIyShczayv5g2DXR6IIMhpGztAkp2d1N/9tEvAO8bx1jc5x9BfgY8JlkL6EvWvuO1O05DZQAiJMnX5UNFpeDp2Cq6Gf3an5W+wLq1903NkybojLDLimutegZNUvwPfrkuzpvB0TbQQTK92rW2cFwuzYEXGuTlKvT3X4Gl6Ep4CjwcyduFMFiQuGQq0jYCM+Kv71cQFN8korw1g7xif+MgUj2h9nV5LDBBXj8tsWkWyg/ZrHNy//KGVllO+N9E7OExzm+cinV2yt+NcG4EUZHZXH13D/rznHjhHqFLPh7HFyeT8KU0yfVmXFyUtR8qu4bje/2hbXHEOe+ygBXQlZaJ/QlIuguK8RidZZTjPHT2KVUoBZlHTrwJfOQj1iKgCPjKV9pL4Pvx0TpyMxDMtaJ6rfrrpr3kpOQ1LDZkfTRPDs35onpwvANwCMA2llkQ56Pk8OdMHIaSxCpt/Yn/GhCD/n/WkSicdYj11bqii4id6eBzf3yGBKfnDwCcZ//eaq8xavWgQv3WU9ltOHtlvFT6iwncbN5jwJdbV3GJNjMazGcV2DKrKLD1INNLB/0luQufZu1vOrPPcXppqb17uIcwa67eNxhfOeAI8jbt/BXXTzTkdIKufUTDfFvVKAt3tqhG10CP89xTR+XJhwdrxgwGn9AW9wkgz4XipHVBHH+5ELsthvN+T7rkrR8qihB8VBq8rZBWlUDy2RGVUVmUKB+11xwnz+RZimor4NHEVTRy3/v5QcqWPlQNC3ELYeZ9xERoynbzlFDrd8yPcbpGMGaaQxcGp1fIocQ+fSrdxO1TtRX3G7ToXYGgOBqCBxPCXOeuoAtOR2BG2nhAjppaGPK64amPQea72OrpwEibtb5ZVYhui8XdQUG0zv956YAm/jPQYqDMAgMQl3022EBm53z8Emfu6hLKrJ7U+f9h2vyFYUKZgUy9xE3bezrLcwXu8yMHmqb5V9b0kUPtfjIQ5aYLQa2CLK5msrckBVDlexpZEyNhWuk77HC8qTrXY+LWJMA4OzvQyQiHxwJB1FO4Xe0TUr0EnXpxez/Y+b69LJctBQ7oxWGEPCZphdtUMZhlmH5E3QO68sW+vTQPklVxVsx0GK/4uW+W9v5iu6Y8laFgVvNurGGAMXrakB169F4cR6YwMCIw0eGtD4eZdU3ECR4pQW/3dnNWzVbML1/obK7BrABpKCJgfUbf73DQbK5ylnXyRKRya3jlkY1FkrPHq6FwtZNlifYJsy0l5yTxU8Ny5QsJD4HmtIsC9Jbpr418D9fLxsQYiR0DNTVydBBgSbiIimLeEqZPTTV+eviYYecyPagfvBVhPKNPaBcXboZKQjkCcz9fwgmlpedRixe9KYTKx180FBCY0me0TyB4wXq4kz2ysVx6+sG86g6a9FLcDr4OTHgoPgfV4QA/KtqaQkMAsMzJ/YHaQdWBzqMEDMto9kwUKmIxZThkGTXTM1eNImSqwvZqxVyxH/3UKIZSQBfakkoNTp8yH8VUW/LFtrtJHJlHBw2DcWtLw5BUrIiYDXoRvkIEr8TdQkeo1UDHaRF5CUfIcpt9eEG6qUB+Hixh2TBMV+zfSyv/Uqrf9F6WxaM4oHb2eSiirDwrsHKq1PnYkT8A+iLYED/WG7dx+GS0VyCfA+9q7Yc5cNWYSTKf52HmpZs2Bde1jcO8C2Z4db72rDkjihiA38fERBr/LfZnAd9NiDQbIo3+P0Jn142iMrP3eoeVd+m7BSSyIsP629LpxYo6QTp9zn2uuvXEURBxM/efhcuiKCnJfH1Q/O93eDMNZfx3fLH3InSq8xlX1ek5yJai9jb+NtczSDCmbL0dsTCbtxQzp4EowIG0C7Tfc4YSsGBHhYl2rVOzQ2TGgL2oRP2rkowM3pnaqMwWfSbZFvTCyD6aPuA+dm2ENscZJSZ1edzRzbw1E7vbSvl886G/qboXms4xeajQ3BDHHINPKgAoi4EJ01aZ3FGvycDBd1PYjkxJHj2MBEDik8pe88R+FG/R7Zoq7ErnJI+vMDAMTCOeOs4/P364oXp5vlFj9eqpfxftNeCem5tA03NliAVLdPvhMA0ukpTmU3ZQOJIcICDh3aVBfiwjnEXLFa6vBGSbOpnHUbfoEDQ8z/r2tQAdrL+P/M7x86TpXlHoAn3oCRKnH8pTrZSSUVNfArtiIBa8JycRSvh/eVbJQK0TgecRU14s789CFRgcvDV1ZqhDm9YVZuOYZlFSNeNULDnw4sArztb0oltBksEZDR+DCpg4Osr+sKGm9rnfhFaBw5M/1v/L5dOzDa77Fdg5zughT9vxQaZc6Zizv5kM23VYk01tCXHTGo+WklRM6MVZH7Hzny3fR5aIdm0k44BpfbXsz+iGi3m2px+auIxxabWXM9VwUCU/EET2GcZIBN3XCu95MRx+quotks0t6/PiN9D/B57f/MHZIG7RYjChFsS1Xf17MciJ4AbnY2N8tIQJdd6aXxAgph7SH8NyWzbbm2Ay6TRRQ0WGQo6uApeP7b7Ehuu0O2Xs8KxndCI+euMrJmQEnZRBZYnBuOz0p5NIYjoUUv+pX+BNvzVsRDtdudgGg9igwBHjr2EyUby/w9gdcMEk1EQ83B044+cO+Rk7xr8XWGcWz0WPw8yG92ZtLY3DxcTGTCXj/NPWs5BKfzEEKCnVq+e/Y9f+5va8eTa/Muq+asoYHAD3ooPp/IgZWBQns8hncK7T9ygVLGGs86ttIrvjdJWmVZEF39h2DJo61382Ry20zzwaURS1mP08xmAiPSqWscjjLYWNGeQcm6f7jRQ3mXVAx01QTOF374S9/7EXo9+vgtAT1KPmEZ1AO6d/4cSY/uJPYZWfRNleL3r0Sx0cAAB0pCerdyrEY31UpM6OPpkCrbCCOH9bfjjfX2UtHDAOI8VldKnYEI2dAKOy0HZ5wMvuWzBvVu9yFpg4boyjOqfUEeF8lykjGX9XIM2qpyBySxhYOeme82u/2+MK6rLD3dUY2ELTbdkA+Moo+VL2pR6wvBpQuSow6irCAeeEozJh2WhiPl+Qr8oLDVDZrLvLCkmcg3uG0r/LiZIkMaeohPISy5lyJq4pUVj92JGm4uh+hjUqc0sRquu9xBULfj81/IHyA/VR8rZ6Y/8AKL/xQhFXcWuT86egg7fuMOU8yT1a8ox3PhqxB9EKCjYDYE6e2nOtcXiQwUU+V+VS4E+pvQBuHy6aOmhU+WbiQ4O6xM0lmUTePxSblkmkL+4aXB08gMOHy9KFpwXN0T3/mbD46LobQpi8rqci9JSBIhGTdRyV37XlbVffPh5Joe43DLLfzJpCkgCzqQ8WgPhfxaGQNK6Fqd/z5m22BIP86wZInpggtWwxhg4vWiEWyVnCPT1YdqNKG2VEaoLiYbklaW+b4l6YJHlacyoBesdt5ESLxSoCmhB6uZzSg/+JiRj3YN5OCICsgSccZFyjGlB78ke2+ATokx+Trotb1RHTCwSHr74G2kPG8bCfDOYoFpuOqVDC2CfOWYTatKSTe48cIaHvT5BPScFn2FmBu7I0/1JmmJoD3uez2VrgIvRJZESfYl5RymTRjB7YTypzKnAAx+FIQ3CJHhYXdfySGr01kLF0sxmIy+Xv06HiwqMFClSUznmUPXGVQcFj3bJeY3kQEGZyOOo1xC666gVhfUOfV+soUO/hMesAlrusPJ7X+52ar00EMRafqcyPBYFbUTT+e3qXV86rosJVWui0/LwEeGvUokLd0KQ0h/nfJ5gg/jyez2bIlBAqggGqdK8FKqzae2Uv6TpyjTNlUmZWmdx287bimNUGyePLYYlYGtSkv4wPqtzxWBJx4k5hO+VHtcUgS2tpuqQon7II+pOqFuoHQ5FxKAUqn8hD+hXS1UbBR2wmrUPYRUfQdMO6+wtXoADOHz6r6hhwl8bpYdHw4vi9Hs/CtzO8yOulxWKFuuutZhvBCOYzsRiGayBP+jgZuGMnr2jE5wafCbt6UcpSrZ9pgxD9Tjbz/Cb3HX4vxy8/I/j3ZP8g+dIufbEAnSqYhczkDIj7u0qWDsx7Ted1nadH1JYmhMfMVTGo1EORoCSMCcv+nDtP92PRXdjENOT0bTe+pUH5pRLAAQ9b0XfHtWsZkYiD6mSp7b0oq1C9tgHNFtoOfcC2cWX9JrvAz2R1an8k4l9derPcGUjIJMWMT6yYsRvpCPGA5B+z5kgJYpRxwwhjVPQhLRNfGmYEFg3cBO5cfDETc+DeVn/lxjiPPUsl1lKfBqKv4UGrQc6PF2Ur/Oe55XfuJTC15yZAwxzOSRifbLMxJXVtILqjCGR/r3ST4gjRL3CuByH7M+miHO1jddeoovqivMNkLO5ZIxdR7ggiCchMXi41bPxfEQ3mqe4Qq0p3VWTLHWxUeY8RhxUlQUSrinMw/LbG1iDHl0RRyi4FUqfP7zxnD8wHsU2hj8BtI8AsxsFRlhKaHYGR7NyTlOvdUxtAcvjnmmISv2zYMo+nt0ez/w3fYAb8zr/civuP7LfXppv0O3ovavkvihJ3QpvpykQ4N24TkP+Ay/N1R2pNYbOEyEFBndZ94pDd8bEfggdXVwd25p0Qk6Wx6hfeJp7OaH+WjqY8lUs49BdOn1iZ7Xkz6iIfJ0xuJqVXHjSxLZ6CHzhviAFGp75FNfpepPEQxjmpIBSe10FnCrnZavIUv0aCtTr6WBMTlr1LC8i09I64skZa4CkTZhyP2rUURZiWAUtQZKFzB1su/qQXl25E9e8QT5quVyjoxesw8hS3Adz1vTqQCTqsnTB1rd9yMx2GdriUBZRTspJaO1IE5tmJtakWYmFglnEuUcxSqQs7o1iuvoriTvraUW4dNkmr9bXM5J8U/XwutkeXzY8cxk83jWcGOOVvXeSJYaDrunZ/5eJakSvRrRBcKif66/H5nblG3mbM3i2fdYpDImIgverfDB+d43zanHsmT/izx5MFPTskXH9SVuNYuLE/ZThfumNdz0P+q0Ra3bf+N/LcbYGOHpxwI+Il4rNf/AYbgZYtDVtBXuV+hVgocLpsbdFSYYrN7LczAiH0mOK/dE92OhsZgAtoA6aPrR9xliXDmel8AJGLpubYc0hxO2yXEoQmn88yrA234R+qTJ0JFO0Do4DotFQ55EXQdKm4ZAE8JbTsUs/NoXr4pplZyq9O0wCgRzxY7dvJrq/6Ni8jNI/99IWIjYxh1IiG9w+0k+tcVHQ64Nqr0IeINzw0xs+aTeLNqZ2Mp4JlhyQoHOElRswu3CA78O/PKnoOKGerVvJx0jzs0ejIMe8qnUg8hBAZekbUzIzvWhwoL/+2WTqpiUoJkFCI8n091FW3OFMQYTQX27H55Th92ezDOSu1wIYhDgwAeiQmtIrrWmqwsdWByj9qWcc0R30Xjp/sDYNVEeuQ4WcEjqaZCr95uuxWZmFhBflUMKZq4tqUaqeQyZEMbvOJL+a7rpkvJbH3WPBA1uTVOyvQ8Tqm4jgQ/4jO919pv5Tpbukx/cnptXXyaqI4J9XYSo3tgLCqHeAnpZVu1EbYZrBr0IiVXF8vny7iRbWVE5vUmrGH4U3oMD5qd8/Hsus2fX//QJbNd5q7BYr5paY70a+YwMHQlWrWdUrW0sSoTQOkumZ0lBLEoB7gakXv+wOKhAq3hXi/AggG9vYiDU5Ulim7HKNnxqrayleMKi/QC7i30YjS08DLof6yZ7qBDCUVuYNXvn5DikBTAfGEPt8aHXrVtCjTpMn9EYjbPu9g0wQ/8ddC8nnwOJN2ZRH6KiFoVnoL6FxaQ36wTYjKo7ymfMwKcYY/ysi6fC1blJbEZqBYK7Y9G9E388zMDFthbIFe+mH7Qw32PYzXPSMAv8O1qvF8GcNTTx8j61jrlLoPYzEi7bb0T+VRKv1LqJQ1TpzTwzVuzlDKu1Ga91SYSA+819wfb48PTqO8S1K8xRDuJy83+1RsT7quZMoP/XoCJoU7L6A7yEdh7ggnh+4E21oceuKK9KXdj6PDbVDKK+nnYjB8uRyMeO4hmCnjAJ79iNU+sCg43HpwNCm97pJuun2sZA568jMsuLVsujVzSEcr+Enh374l5cuLLaGqsA8H2MZoL9rEGcDrX6gSyUVcm77lu4fsAgNP5jSy5R6v/IdmWGFB6oCr/5NI2Qg5PJ9nx+/EQxmlSK3ThYVZhEMYYAHiLsP3CoIuki2MXO0I/Fv4gLoQYeeFBDZ+iIvtGouBZby+Biqb+4n0qWwvswM2SlkJaIHS8/lh9ZzpMYwDY+SL9Bqv4CylIyCSIOV4MUoVufEthK9kElJlqC6YgPzoS7YYkDd25SAnqkaW2bnG/WWUCQDM4ODS3e03qCMZQZqde4J9evTWB8qB7V2/52djxCIcoj8QDocGRb44niC3t9LJut+LHO3DxU9wEOfMkNyG8GfdDNpSwseQNGaGTrzlXYAEfvdoIzZzPBcBw0BS62hTld5X/TLozPb+skYiDxEZaLc0SoVtmMFDm/dO77Lb+1JHpL5Uqsph7+GLfSMQLqdNC9NQWx1zsLDUj3j3/Zo2M+Tg7n+TkqrG39Qz+5qN4KC0T9mA/xVHPe9VUpSXW2c+kRL3v97GP7SQIK8cA8bSe8Qds9P2E8cDxqP3glML6dPUY9hIsK7IBTix+YsG7c4wmGRWEg+wxIQYERljgA7nXNXeNQk78EV48YWoo6+Cc/ejlVyV6c7e0W/1nVsenk9tqIpbQyLzqJyLqKCBDu+RIvOSiyi5n9VoeKJ9QbIm3GVvGnhGZXsRqG4D0PVQuzXFlt8g1UKR8BaF6o96mfyvur/Rqzk1U+oeQwQ4O27dTdFrvUkkmw2GiX2zrNtoLmRZE2z7+dAyGwVY9Sy8Nv2l4LwI/bCg213iTreBz+ExYBd9QwwNgCb7kskngxhau82UPnGN7muRi9zoyL0TFlUbpgB+fD3mj5SkKZVui5FjdlXnDkwd1IxiM+QYaoGdmKZNKwjfj58EBAYibMk77spnh8aIRWpiiGTvpViQIXb7LLKFbLWPN78lzYw4x0nmKhtb/ArhgenOm/ZQ2C7mggD2+YcTnrgQl+ADd3vPPIDFPTUcXqDDTajIIzTKFfKtseieOsMt+DlZOxXNvulwdn+TkNwzdfo7s5VlYSslM8gbSchwpwAqlQoc60U7yK/ePjCHKYJG62n9wnGY1ilm9Ya3HGjn+H93xuAe0/0AdSXWYE+nBSPXgR0K9tDeBFfK3kAZ6kMeerd4ZO+PSmw0TmyQmKBcWzg330jxy7hKsprI4dEVcQRRhpK+SoGynswvj6cZoPWeyTWgKKYHbwYoX7E/nItj29ZEfFL6cAujuwLGKk2/nDYiqF8DXO0Ryhvm3+GmMv24+JBqQSBu6axqxZBIspAKUIgWgwX6qmCCCbTWgCqLJ4CkVnI+J3U41KGEA3gLNeTPgPGqfJKxovZ7xJpoUTRp3Bb7nbgpoXl3KXOkCJgua2iXO5GP0lpWeC6z6bSVnO1BtoRtnrtYSN52IpnAWKEfjE7z89lxaTIhTWVzbdTV69j8fXmbidjuZPHPkswfNDiefdNn0UjG40ior+mU/coI2dEhDznshm0vfqO2JAHKeLW4KGTtspaFY3DvPmgXdHYBUu7jR9fjXkTiw5VrIbwRi07ONrrjOgqePeWXRZghxAw/4XXGy8a2nLyyz7sST+6IUmNMhUrS3/a2BUIw8H/UXNV9Xk4VIuH0F9vZJY41Ctdr48G+fEiFXjTHGZ7iMhLBLSRURqEhnGHpzqsSezYRqtU70bvkb4fRUWuP26L5XV6/73A7qAFTf1pw9qtP+gDVnRFj0btVmhf3+FSzbScjuUZcG76HNMTy+humCakKQA1wU8i046ZC7UGLSQsnLlpMl6hn8GN2CiM0uG1Tb4q3DYdKpgAlFE2CVAsrQoyese+nbdiTWhHkRq5x+vtq9o4ZfZjuJvehGtL3pIVJojnjaBGJq/CcH8zaWgygiBezUv+9OD/S69r8Faw0dcCwxmkQVRL2AECpXpoaK0lA8M0Nc7XwxChJUeSkMB8u4UlAoh7E/wQRZ6KiP5a1ueK95BZVhus7RV0EanUkKDJrx8w7k72azmuHoPivAQKk0nRVSt3RwJAKJuDLoqsyM4naDU6xogVTWrbe2/7+JRnjNjlFGff9Dl5stCl4eukrH0SIYLj6CUl2j3dkOOaex/E4S2U3HvRGZy5QpiJNeUvrrL293jmYXJCGLTFuKkdAvoTeDB0Mh5fN1Ru8jV0rM2U3Q4xa9hJL+uawruVlgBieojQ81YNOQzzde+tabE2EeFoDQWx+hUAyq6APEFUyk7KtmIiOuDy26rr4kiRlRR9lxyQ5ZvWqIts9ejfQmmo0P7vkB1cG/ce0Cf4zGuUHO0oTXmDRSA6sO0s368kvkQ3Ewn8zSq11t/qAGOpP7Rk22RE8xptDEFOlwK3zIX9TsmdUxcPBOvmqHPLQMjFhn16miXTtR2ruA1gQydX7d53wB9czue49o8ccVE1k3t+lnWokNV3p74Z7Ai4DGjZwf1ZbMWqvm+oR90zJW+YjEPn2vMcvBiUUJz2uCsSuGBKMw58Pp/DFjOjgL33CqC2+P0YIPDC5/JK4oxjSl54AWYXvJvKLfTOvKGI5QRszCLW6mod6sSk7VknROeH7oMae0/oMEzLxKrFZiJKfj1wC8kV3DLuCqpUFBsmXLeHPQ/2dgrRSZGAMc5QwDDvbGJTAvhO2dQKL6uttu6yVGtAqs5iET/LxFM6f1ebxmmv7UhOOmVIp6BWcYaXx2SWr3ruXR8LIkXpQf9GHuZ8NdVynxFHYlhHH4i+gLfVbw9IUuzxmXSZsMgvuKldtbQi01rEcVcLZLY9L9x7ySuWlPZO7uvMv6hxzbbl5QjYKi7A6Sh5qW/Ek7cn47Kac/pID9hQ5Siw89RxbjbGjc73W4YugoWC1jKtiVcUV8ZOQUFVNmrkozZcHOi183Qx1J6WBd03dRctAZpCNTS9/B30ggUHQp2J0KHOJKOeVHPiLYXUEZYYyhk1ImNaQvaAOGpP3rGxHsXCfXeLW15stNw2Ned41j7qr9TSLPW3OI7zr1FhpK9Z2PL7B9eB10cGBls52R5ckQq4fW8CxzTAlHG5r5RDcmQ5I4HabHO0KUdqYEjcDVjJtb4nPmr3aJNhLHckxGgZXlRdTb/HRn8M3wRYULm+S2pQO1bSRF+Sk+WOyeIvnpy3VSoJpLzzo2nXpAJufqqAdtV0y6CYVdCOg4/VuaQGa1vT+KoW1h7k67Bs0nq+kFMlZ+E7EaSuVtAgmCCgW5LzHLdPAag8hJKNKecefsiw3JKnEFISJ8umriRzCQkyy0xP/dwDVFwq3GqKjL7wDWh6ssGVUCheC3PDg8O/tdSSzzTZzpy5xH0FUt+/NlE2A8z65HNLr8xfbMauHWCJ8dSdQdEHFjivr/3FD4/s/SNgYKs8By5dnYtITa8I3lyEWx4hs27ElAFbj1Zgxv/mhNnFNwdvX0sr+KSHe4bKXogh7j8sKfIt8EXWFU+Q5JPq3b6M9MuFfyuTi7OL3IL29xHfGHla9pIhrW2dM1A2QuuF6IrAIOaW2m08dwSSC2qii9AI+NSTFuDDdMMHjKbmCxtQHWzTH91b+9H3zMKYShvjNDlKSs6q2n9DOlMPydVg7jdgpFL3NguCkk6vNkMkQP1m3nG/Yi76a6ZvlevND11Q1PMbLDp62RYgfTkrBH+93Wb9RcY2TE8Z5dya7OEZL+AI/sk+U5Go0ABk8UPcqbJEUOBFwz3QDtwCPfqlGFakHMzb5w8OzCuBih1vopswPFzk3TejVIONBi9l4yHZs/NC30qjW7rMTibe7hBaaZSJ5ahwQUBMUpFKIOZ5g0PQbDBCwSX8RgCRgNCf/bzF1iYT1WiMcVbNSdCd8LbfeZ2erP3nEDmX1HMnDRV9zTVo9rd5Mp5V2z1Sfmb5C5pwHmLuj9YkuUTz3K4j3B/ESh7E/igmJGDonfYJsuqyOQGL2sgwSXezNPJPxzYHudHgPj7WRxGN7jeuJdg6TAg0KgzHY6OqfU0JH0oYixCILVHKhTfTuPSiXDCxlByVHEeqpbj6AzgN+lo+mQRJSf2vHUR72gUaxEQkyAj0/vRMXuQk17FRCxajma4dTcAvleQojEk3N9rpVwAFxSa36enGX60jrbt9J8EsvWbY3GHQ/dfSZubM/TYQZw70hV5Jnl+tqCe4IOw1uVnMVYBKKIiHZJaZrze/HiJ2qBuudh2vZSAa/kDqKyOtPMaWdtqGXO2+Ro/xwqA7i5D9mKS3skSuNFm7/j5Ri6Kb0ebW43M4v6Bq5OQFrxuR7I6I3M5vG/TP0u0DC66gkgslLl9ISi+Er9IVH8dEUqPqgc1TH9hSj7DcRcANizPbYy8hAVCJwnjG6BKtdw9gbJr94QgboMCVTdPAe8iFZ468QC5c6bunl67FWZnPfMwUOPlKyXnbZAYTFDF8FFskxF/p+Cw9GYYTF8QEyk9tyL9QFqD0gLuE3WSi0RsMiOZK1psOfwGdCSYlquAQL24unZaZFnk62lxG2Hd6tLBzpx83QJNivWiFHjQuqB7TuazWKxSqB6ygDrq09AxcY7HEtjd7+VDc+5tavIK4KYn9d+aS6BDB497QtWh87klQNCV9xW6S2qqquh+r7Ny/Q6TPQ7jGjfxGhZBPwphR1Xubr6BvCEVc3srpRvpa3GLFfTiMDZhQQdxyoFHmF4wzXTpjLK2q3DkyKSwhIyZFEpYxMHyii44S5Eiv3eUXCQuwSM1sbtDu34K6ZhSmzoMJcRDGVTjvl+euHLboIVf+yWsgYW4SRDAzbYgvsKbg2EoGGqcwY0OOSANQaTrLiPxJMzeTE9i8ORpdhC4eE3YR1psPVTJ+yn8z7zdoQLGD/qqZGP1gczBMiCfOTQvGTgh62U7NfaG3RLpfKzGYWxnjh8zcT2IqNbQ/NLqyh0JuhGfYeSlMNZpGwiURjL2r6QGfNfRJgpTOF0wfMTCNCd3d1gg5CwthZn/xltBupmoVkGEhqSXRwdBfJMPp9ijvCb+uIxSnA2WORCcvJ3rSQ73ULt9luCD7DYisn7KQoEnj/2L70pcyCbA4JctE8w0e4+eZbJRkZisk53y3Fz2GMnPpNNUFBov35b87LdUvGe4M00YSgjohPizQMkiCxG70r69te7l7dJEIRunTVmWcIhkbYDWGFfPChlQAlQfU9H95X8PLysBY3c1zVNNDhFmHqth/kg3HLd0xr2PZxtw+CQXeE3HM4s/uNXkcD44+9ffBSQJgcgeMyiHwraK5YHnyn0fnVPsWYXcuMSZqQVqg+cVmZ++P6TM1h9N7MtKqC+b6Eii5HJohIebZoS4VY1n7o9gTORmAGvecYoNzPkPJGyUM5Xebqvi39WgpoZW+IZKVZz5XW8pEJcBtVQMCNgTnkQeDXO97HDYK7rLN0tWLZy0KauiauXmisk5ANAJgF6OjVQDbQo+YFSOAirszEdFF4m6ujdMkB53uwH/9xqFKbEAJSR7bu2Qj2SBB1kY+1yuwERQx5opw4rw1kPnpwgtSD+vUM/modaybywCXoF+znW6E0eW9fbpFZo1mAQ2/ga2pQdW+BqPN+nw2M1b0F29pcwZ5FNbq7/sIzmdinxXGUIwRUhtZ/i4fvubblGogY0aqC5fbGT5fOGJIy4ykr8CgYl6aw6J3fLG0gkfffi9ST2zwt4rpGtxp3ZROJwYOKKxYBhW71+KF6Q1+jSoAwQVV/OqzA4GGVTODfnuiRrcKmQzf5d7XkQ/S01EKBkaLERk9XGLW0prLAACdyyD809pzTbyl3PMB0/uGR2XJ4I44JH7u+j9R+SqkC7Gg/7mHBTS25pnkzEdnP1FR/8X05YQWGMOcVpCMjaz5AbJMSCnLTMRwaQ6g1mkk8VgvyiVDo7HHzrBMOirljNYf8yr9Zq/0egpuEvwiAVXtAaZDgCUv3DdG8v0PNzYEMlIOAqteZpWj43VHGHpo1uJZy4FgKHxlfK2e3IT07ePQ2+kPVaQGjXweg1zgrSPtlFD4ydlCXNxCcBzoKrY+bKxF9flGmjVzsoz06DVve8h/8ItbGrkNRzrOURLqkRi6rz+OMOywO3azesvXMv3FfvbC2Xtvd6CdmobeL3f4Y0wrG7s5zoIWXlDFkKB+KcBE/mBWJxxkRSINJv4Md/y+gIqj2Y72MaNiL2FZWpUJAtUnpe9KDV1tcdrNkYd2aJkSBnkW8/rMRIYshGBnHx0HfCyQtasE3U/4z9wnshoPzcQtc5smLnQ1KBntsQP060QaLjeOgYAPT3eJdGXMiDIXoTX4eXlBN9+H8U2ahFY4fuLn/AQflghoGou4APA1K3d2cwpeAoxuym6F9E8hLWihSgrHzh8dgL8fVoy9xEHZcZwbAWpr/3BChZ6sMP9Zkh4CHKqDZiff6kyBdOl8zv/18wE2AVvO/F2vaLflwP1BzzRaxamC60VEcf7FS36AaAhwrtbabVJ/WYDv8GBKZh27Y8h+0Ea3ETI9x6RhvTP1VTwDk3HZhy8hVSDb1vX1on+aU8SQ4/M5DIihBu/FlQaWEQThldwFtRKYvYCbQWRDmd5nKLJWoVHRNNYV9y57A/fq2gX19eIiscdTyNdeD0nCcAZGr07f2tTf4ky0ckzRh5PWMnqxrNSw1EOZdOteN/bIT4UdsvLr95MhBNYYvKumEo7YkRJ+f+Rl4sUJJJHYMLxgH7dQR3tY+1Za7Q8/Zrm4Oo7ydu7dQ6+F8g+vSw0FRfpvQaKGrrkCLI5dMUQJRXDuPKUhD6jYWZnfHLHXg/kqWz2vfGbvk8e/DryKhW7ZYHkNXKMyb/Mj4CZ9vkMbgB6nYkQIsDIo+anMSszdQsXidEOJUYwWyabBtT1h4curGa/VY++cU7P+dC4jfTuYk5iRdqUKiXanI2mwm+b0xq61gQyUfffRfu6I4OwBO4M0Qb80RFtt3YDLi5Idy0YEzjcvsHqiDSC10JdaEBV8vLWpUUeRZDl4IDCEReW8V67zycuiNQkdDxMtdZy7m4CG41y4pnqwrffRfg8OiwCqIdstIBt0RXhyPk3rpaNCJu515MeK/3pD5CSDOWZbo0rcjQNJs9gNEoOdwooQuezQ1LVK8IQGwf3W/TNOXTm75cEpbByy/jmzJOm4djqrE/9RqDoDIvmO0PjAfiEv/e/ytLWO0NXu2mKn8HM4wCuPGbwPMtnqy0NfijxPvF2WF0BKBLa2byWBz264y6rlirrlRXTRed3D/XZmYWk0Aa48F5Ps0tpWQyRE+9jHht3GAyYGL0rD4QsjHvVNnriDJEdDag9AMR2iEcBbvRa2rvEhF9IJsPWIp6ZoIEnKcM3Dzj+Scf7T8+fo+QnzM2gjT/bRmgZnT4qHyktvZa1O6JU741ninQnmmr4cuJWfPlzY9eKrj2Y3/F3brAfawFoh0WbzPnbLST7XGiVpfEBf80NQnAlyE4LUxEYGnjOlgDgl+1hMMXnlqcc3Yt/fyNdTr2W+DjWGnacmQBmcNjF+c5oNPH4AzJyDd0i6ZSsSuE93t9UxLt8gSyDYrSxkAIIfWI7QeEG4zmKz4BeFHM15JmuiMHGzIOnEzuwhJuvm5u7HUTeXzGgLjoKFNYRvmi5tARU4bjqKNSFyqkRcNiJDKXiHkbbPqYeVvf5rlZ2KSgeCuNhue0TydT2r2/ujLXszSYcB49K9AHsX3ix8dd1nZU/Y4pERRXnC7HCJZNmjLEG3mWvdEl0yMygAXuzEnurKwmfaGmddGDxTttf69ZsMOURHZSS4scQcRtN3HZJgn65WrPZq6P+4rXb8rtF42w0Hw0dD/2RdwcksPgLyMKJ0yS8cXr0+DD4tyPn/YjBG2oiyqXY0l3OHnHoXnRI2Ndh5BPUYJid+e/4gbgkuViMPkiu9rkNqkF8hvuOJDW/rBZ60MrR53BQmaAc6OaahpLsSAYvcBSeU6426N/pxEMQZs1Mxdi5RXBtqGRAM23hExCMURRmnhj9TqNfXyeRH71ubTF70bLxVPL3FRPA0aUrG9dhl9LjwJPzwweLPubXQ4/GufMbn+HnGnCqVagWy16cpNk2RmAG7y3t/ChytuB2HLB9bLUaTnpxpmvokrIJW+DuAqWfhwr2LkiZqyxiUDS8p211JxD1kZTK9QMjhj/75xj+OLpufv+s4m1OyPdKlDtkoNYDKV9/KHrrsdQ79MJYscTXzYYktoNd6B0cefmnqOBv8BfcrXEL+uA820xoqJwgNzRHnM3OWJGPi4IOjGmTghDNxgK9glMAf8G0SBR8uDWfSPgCMdgc3PbkMZulDPnwIVp96GipQkmfszjS1c9JG9/llvrnfGdsSXKzSwtweAT7ENu+nruXSTbnQOniejDz4jgSH/AYv6m/VlP5q8fOGgWL3bujbfisepY3nfnWhydLaLNCAEbPTGlWxmmkDK0/SGgmJH8jMEB29ndJb2RTiLAapkgkTHbw7GKBQV4+bya0hpJB5OS0J7QO0SryTuxv4CQFteqOtPQF2maMC4VRuHyhPEdGUixEY4DFh+qO/Dq1JANe+NTWyfBR8had9dWsex6ND3+u0AzoLK0Lx6cKszwbJhvwwrjcsSCckADVKrqX+dCRKycMLq7Xwh9GjyQNkOWvMRzEHXWttHpR63xvwZT+vZPHjo5bzq5wJLEi3G3KvzejI0wY7bYQPkGWZy6atuidzzKg+YI5FwvyiXxzbq9EYOmzachE5XxpqC49UJVb4QiLHbT/nfH3MeOdUMgOCeg/hnIkbiAxTDPWRDWRXh6s+nWJI50MT+TUdkq+k3Km/GSYdEY2kv0PU14anH2om236G/UYiKaC3U2qCUQSWOryN5m9H4tGRY4vcLjjky1M7DeOb2swVmvpldLB87zVstEFc8O4hzGm+WP8JUC5O7CmflUugrWK5X7XJ9WOOuTylTTyYhhz/ZUyVl+w8Ue60D6YNWo497pPJmQUFXfo5WpXrV0a1P8QsiueaolP0DHakXUI4Sr9XvvWkgYf+nDllvL51QwwQ/+fGAhcHplW4fqIN5rCvXT5yrYEVCqsFzVsVua4ptCtTq0csn9h3NZDIbre0YbGqF5egC9q8zKS/g7O9S8Uz95k1M99n70B0caCUJKJzFvkHSd77QaQMTdSPWjOJ5gjlGoSFPKjF5PbOJtf0xXjVeIitMnapsdHSl45kLQqjj5+zfMdzOPYUgH7x/yi0UR6++UIS7SvUurder0uwG/DVrGUI62nr1SmhBZDEDDC2J2RjUrly6j0D/vIIsJfQh8RkBIFjPKZoFdHc4GKl1oLlRG521j1xoxc6ekJWJnhpGpUvDXj5NmLCHz9TO1pzuAV3jJKJnHQ5iR5c2/DfFyYW9SEJ78A7kZ4aFAiGQ4TYV79jcZuoenkbBD5mTXz9IYXXnVNWQ70oVSREBzHJ7DeSUjKEHpK4HujZGdfBBwCoy9qfEKDc7Cnln835ueETKLQh9Hs8JajyCaT2jNtmxfkawV66ypE1v0c5rbSs8Ptvri68nG1jjt4L/qyTpp2cwgZCX8gFxasOwB8QVHWH/r1VvXR0IUaLf0hxKlpeC/4viW9QdbPY6hbWtfbkOSgz7z5C4NnN0TXA6ECQCM4SRAS+45vQ+KZ1bSdNIfQ1AK3j/eCGdV+V12/GMre10UdfGfMWcLZaDGsc3I5V8M8rdbwaWhNWlbtXTo0+HEK2378QQ4zzuYU2iFRe/Ne9n2FeqZzLMOuwogB8eyvmfqpCQeu/reD0oh/YNKVBQc4Oj7b8LCI9wrFF2G/1zdw0kUjxHjHkZfaOyraEnbeiydokC6AryBTP5D50W9OYefXCK+3AN8y7AxIyMZeHJ0DvTYypicGdm6SNoauovjUIdsn45AVB2vh+XrBmqL/BTUZjpbgkmZe3K/D/Rw7uoNG8esthw98KkqfYSaKDJqE27HTiBEadV3/wOTPQD+XnK8t0DFO8ywbuA6Y7R//XC5pU4/d97z/cnW/Bo6uDFLrLuoyi47BWx+eOoVBNKpmLubGIKR0+NyujFpRaKpRqgJn16UgIflriF31K/w1qUIM2giVJNKJI3uz90Km0A54cLqgTn5aCG/kLgHCJZc8SHSeH1rd1fM6BPFwt4h1mml13riJ96V0JWzoFJwQUQGd531/JAZxQljUJ6PceC1sOuRzYsFirD3v7eVUjbglfBZwokVa0srW/U4QNu23d4eZAppCc/bGXXav24xgQPMt2MuMZwQCcAlsphG1JosnJ5Y95etT10pY90XgZN8Q2UacYeFgNtknPhwv3I/5QPAzKbRg/EnWS70Yj1Bjy66A0Ua3/76Oh5uI/gA0dm+tIKgWZuqk1JMobg0CfLPfdW1GL5ufxNt/P6dea0yMYeucGu7DbGB11Tuyan3f66fB+/0tCHx3/+qM7WMWPP5tAhSw7Z43BMCZXzgnO19Mt7fCtd+LTnwjWfzlITY/dOlHgUSFHCG4nui05ZPUsFbuJZr8huVcHlSgJkHWKoOpECwGvyoDU/3T1ThnQ4bE44Gvqef7T6GMoLUdftHBuBHwY3IwpwSNqlKTqpkq8OtWSXX4iJH6xfyPdfRHRuua4ziqizRSCqAsALY7rWKpPWaQpF5UIznYravPrUqiTc8O0JMQHEZ6Z6g1fKt6g4GhGEr71i4qbYJ0Lvnv8g9VG8MQbHU7QKkNj/LpWF2HeZ1OdisciOQWX5rkYDHW5Yj0RkfwTp2P0PTF+rk9L/zXdm3gsl8OwXFqf4Y7hK5o6t9ucPv3ILK9HSc2dkRHdE7mmXTOP3yoXjnohAo3tJAcyqGLw45QkZFCUwX84lpSjcEHkpm+pSYZPaPHAYT1pFFpSvBCmwY8s5RQq+oB7Ch6O/dFMA8EXPVcwwQIZ+P3y7V+J/72C3AOEZTtPtGwmrjaZr/3KETISMzcDw9nGDxMnAmh/MYhEgRMlQ7kCezDZr4zVg5eS26K3aYHLvH5cz/0eLBnw+DlxLs/j1MyyAjoS93gVA1/ztPNyIImY3QpAvjXjtxlSYTMgU18QoZmL3zatd8ZaHlJOcNrf41pWSxkZf1VSsX2iucrlzgPzhLwlZHGsI9DTCW4CyUWnEydbUmYiyHJSl4f/QdQURJNeD8ItumV6X0lqgfPv01dtUNIErnRxR2mYFWZV98/qtXf9MjImSbns/g+MLOKzfTuMfp+clp0lcYOEx52OoWnxUHQeAyS4s3E3dK+0dTfIvxM8iQFa7JnHpw8OicHU8b1fUu1IVNj9o+p0IIWBaAsUtbsZ4Nc9FMoDMDm+sr71yjeq2VCTzHjPVCxjO83wY7vHjntMjy+xewERniEG2+XuldRgrm623rMRoAymprKmkZryG3H0r9rrouB9d0Ni+wyBcXogPtkoafX6qqNb9xI1HKlZUWC8bTY4weo/5VFPsY6IXhUg0bbK/kVsDkb05ee2t3cJtbcTGaxIsbxxkSDRzd3kG161zdkgT3fsJrodHK0Gp1mKefZd09AuFTi0nhW0nvcr0CDmt/uEUND3VqheBg7nz5ujw1c3oqIasOPVnV7yjDVXYVjEN0MHFTQXplCVXbsEZMS/rQmyyUU7uzuo/phks/Nmi/jl/PjJmpNHMKBhY+e6Io5cbdbV9KHZiIInVT+gzbCsggr6J/KwLfZU5LuvEPNwW4b/1Va3V4JNwHxAZwI6xiHQMzvQr69PcWlORNWoMCh0eWt3G/kv/NSsdWM+zfyv5Y7QnIiWHbNy0jnptl52H0N72h7VpnOlypS5Bmtmoah4tcFJVLbTHOLpoJLOUd++UvUeoQIb7jS4p3WjvJaIj7ex+txno7gH5MgHMpQ4M1+7slkj7RSMmM2whDmbqBokQrCiPx7gNOtuH6Le/l/WCgkf967eaHWpHb4TsXlyIPdNZY0sjwT6ZeKn2VbFHar0QJ3guEKtG1OABkNXPezZQTaTDFg6PNwvjYl5nqeGH0/iwm1rajfJbZw4pF1rWRl++Sj5XcxtRQ+a62zD5Gg7K6qfDmNY4cg7tjY7RAX8CEuuNWgGGST/MSAWapLeIWTXvEtdjntAcApaoMrqFMvnJFxg4Q6eNlTIN0DBlPovGqVjMdjPAcyg09WiAqNKaFqwxEq+8l3eGakvY0ltCwXVcSVbWVBuwEPcwtgJcFWSvVA80ZPlKKosnJ5EPzXCsebY1IcUD+TUiCHxZfNVx3avnsjO+Ds2PDPnPiWXUNW31siZ766MJu1QjEel1GS5DuyxNuM9C5twmOblhmZSg9RBpf6m2v/EeXD8L+nj4arkU9AWDerN9+ywqC/0LjP5i/1TpuOGr7RgjeeKAhS1VZ3CN+FdC1JrpqRdRSAvrflGXZTw2NkT53VTdcmSudBFsfEh0eFo3+WNbJP4HheWzn1yfd6cXmE69Dz/sxAJQ11YuK/X1h6PmE8ZGjT7p1DIoAi4P8kSzyh5ZH/NnDWx2faFLjABKRj7qbUMdO8pHVD+DNoYdywbAfJIMFHmx8zkiYVxojy9KPfUsnjRJHoDvTh84ehqz3IhEU1GDDrKoqY0nu7EfBypNLPCUEQq9j1zv03JSGnbH+RVSw8uah37BbY7VEvt2vk98MXqSiw+AVoE+ToEHigPc3oiDmjd2m7hJTYTr0Y7QGpmtuw6Cz6Qhz5UZjhn4Y5t0taiWsG0zdlON5405Qx7pmkPf3qkvIRaLdKdVvEOozfBgGFoIKUgoTcTD+NQVZatoQban+aKptDOUedgZdQBjjpeASWeeCLntjv3iHVlcdD+zNRybWjbprhDHfCMMWhlTXX/ld9PEG2ezqd5nnj5RBxd75jYkoUrqaTDvymy2eRi6+FmsUfsl/8Eb0Jjh6WJH7nvyB1kWmLpyZkS7RJTub6NM5TjKX4gu3n7hJzZN9YuKb7r7nG6v6/iQhT4EwOcW+dqCXT2bnqQjIuyhfbr/h3f24Uyn3ly6ZDh2pmoQEWDza8hxa7uze6F9H1Bzrn1NNNU25D+2/leWzMZlsB68rfeI2d4KPXWG1/BOKnjeAbofpvQEyFYGm2wEk/31xhFkSpHtChES2O1hZJxdVSa4cUsAMrdMud45kOp/y4VCHt38pYtwzFbWNLF+7iokO4X9ZsQLpE8U89cOi0/NlgT+He76bJc7FzRn6/ml3uMacQR1YBn0MyptEIc2LMOIkWlAoB+tASRtpN1SAnU52i8bwNwHiIjNanJSHhHXmldd9UqMRLCEK/pqr2rItu4brAMgw2hibTwKJgImqnA4FvbTIKBgMH+1+Mb6fE+luJg8n9eo2J7Uba8a3ohsmFyQsuoav6kBLJ6W+1L9YAkGkqTQ9N4lhsuTM/+zku9ONyEI87CFHhb6rgCxPhlEAaEGrZI1wf4y+HvVjrrAuWNOmp2BCU+IzWg8lMBwOrC+rRKatcnXV6z4f8084lqZ/pFppWBUQ47AyRraE2K7gAzCmtqTzYfrPqC1pTjUSZQvr2+67x4brlhK+6ReVuUKTybfw/JjGBTlIhimi/yuByNE7NTbgcJdpHM22pMeucWLQsTZPpWBfuXlG3WuQn3MkGGvK0Kx+mSHkT7ugZ0+d8k9GgsEz4uYK7zht1UCBZWWY1qXF6X7IxeUOEeoVX+1suNU762v6GDOxjk0VxlTkMe31v2n9gaGp+NQNhD/Z3Ql8EKs2Ags9EzogDdj6CT+C5+PHZyG+uvqd1GpVMsBu4RkiAPjDQC9CjPACq9f7XLAovK1NMntVy0z8ovKB8CfXvkNsKV1Tw92SfT4J58yC9CLu0V4mSdt/wxCK/FO8gUVCOfj2VtEFW6CrPZOj1NAKOhM0Lpi7c0jJ5hwxqMEj7uELeF8m5v3QxuF7aU9uVZZvwBCG7Qce5OjL9SNw/Tyb/7p1s0cttmAsDh9kzIKbImrkvi2fxUPKQ0X33yddQ+guIA799+m5DJ1rG7AafM2c+j6lkqgo2N0M3gfX3ygwv7rXAU83d8GeuopWujNsi9IvTlTz4TEjvenIuZsMJQ0ILWelhGbhbNtG+f4rIJ/Ig2PoMEN2WU+Fja2FfYhCFPiZ8M/dBFCjRK/St6oNrd7VRkfF7oVSJC60q/FPQNZCitoZ4dKePPN7+b/srTf+/nMD6Q3ynsC3K17uX7zGFY3271FJ8vdvWYrrajs5fwgBhXoAASmRQfz2qnCarF9HTOdQK1GnNyblVOIiBegC6D3OrwEpJvuKjymuXtrc5h2tq9SDki4uYAi5OApQYUX0KTxEL2fsWu33qkTDh+LYD6+eUkUGw/INolF3Xhvu1C6Q1rkdr5OVtjAA1wvEzr5TNJFHXwcZGJWwRIjbosrlR4LrXITuVOd/7BJ/pFb6QZbit0M1t8dRwaWRxtjlNLNHfppG5wr/FFj1yh9Lvt1r2PLaF3t7vFoE2HrSPbLTAPf+Fbu9UdcFVphKrmvKWHHX6NhSHAprs2Tgt0xB8Xu1wl3M6KENFhZuPwINR6Upb+hDQwRTtEaR5YGni9wkEEiqaYCVqkolgAu9fs4acJi4gyzn3yJHWFTZLgiVD1fLRW6Lz93qzkgMF0PFphlQ92mnkItNwAfUXqWqC3yJ52g7R1iz0YqHkVYkc4g7zFN95s7x1jIwewJb/jw0HBAS1A9tP1p9zExYphcDyuEN8r1KIYpCvHn710dkQuCvZ6JcseRsyzny9bfltWwVRGCQp4wubKOV/HhLr9M0klDyUqkObjOucStVb6uDleMk1J3xLhM8dYAwm9RAB8ScwRAABVRCPNrJbHpiebi7Q5NvyMe9D3xlahIqEI+10XFVKigi20UWdH0n57tQE4sStOJ+Ww1cqDrQoj2THTz8uil/dDm90fmqHsVVVariEQcqEZWK7Ny5IV4UWAd+g8/8SqXxOhgrXZptBMq66XnzQ6k7h01XGMg0umC4Atoksj018+bRullfNWDe2ySTUGVXrcGto8amQo9nZBKLlc2P/YG0tR8Ku9N2Jly+B77nFgsa9vDCATf8z2XrvkaqJcf0xty/2KYqcdWlSh7qa/RZcu2re4o71GWHnCyvedwES7e++HkB7iKEsXiQKkYeFhCjICBlFBCoY6vwWzjnRNNALItvNJOEueYZVBO7Ey34vdwFYWXWWerGtNN8UHiUiWy58dlf6B7oOMXJL3d+nEyYe+NDs8CfFjUaCROQMogT0XEYW3XeKLSqa/s28pky/8Xip7LHsx5G1E8iBRYxLavWRztBJ1G1s+d07CX7BsLXZ4ffkjRqk7cOWoJbZMLRaxzj/LyK8gmj6D6XfE41gstI6NAjEion3VbYQSkzYrkp3uCj9lsq19uyuoWnCgn/tE7xiYgUs5q+7dLV7EoBgGTQbdmaceEkQxv9mBkzOd5aj1n3U9V5zYFVPXTpZ9wY138qyJV8BKm4/vb3dKYUNCTPi8+nTDpLZXTqy999HQrXGs5CukOTI6u3GaQWfuPHxypmaCRFpTuk7v9jaNmKZP1DLoB22ym2SYB+X78D9MyNb/qRzI2YJdhHP94QQ1FG85bpi/kmFxVW5+8951MLDm9Amjzjyo632S1zE3lCUCRk/7elG/q55aXfoc593bBXN/o46lTMWkO9hRxUVDPmvncsvIFLaXtn5wJPXbrKzvh+bQjA8zCicSg43P8ZPFC2x1nfUK1jW/ft6Y9ndAoK89TyEMe9kFEi0yGXzTkDBqhf+BQhMSkPgokUqJ+NJ/j4FA0eY6gu8blPrc0pgeRSodpi7ZQge0kymHLAiqaqVLdj4uTV9QBFVT8b1rt840Yy1SrCFkPZN3QehJC/Ynmh5PCfapWpcfFOXs5uypJPbfxWZl1i39QjLVc+Bn2pMC/Qn/PKDyZloJ2N5H3k1ChwoTOgC6/vgczIO2DeTS7Spd61eSSl3oz6uFieoquamXBn7Lpx9wFHDtyMPjVCR7nDWV+LRq2NDQWEx7fvcdo8QNcMPUzhS4bN8ZqIsa1QhDGuNaq3VSP0jqAINeipCtZ8CEkpGLx3fPnaqV4he4mYu6PTCCaMvd6XJ2SHrfa/3otVIZgnq7RRsAWkINzPKUKTNYpnMPb+gKnhmETORr5DOwyusDOthTz94mXFCBlzCo3OZIDPFHvkoxXBtS7m3G0aCWpOfaV0XFKhYNMAxptsYJ9iskvkKJ0OvSHbxeHVa3avGoQMVK+FUHNovGkNBaTlpQr5wW5j7xAjlAZHngEQfeofwRBsqAsV5iMl2wNt+xU5V7DLJy70G1/uv8aXpfKheg32lQrT+M3WI1nDxJ4I6UgfI4dehI6ZLHfjyDzCtbE5byG7CgEGbxePkjMJ0t8Jb+Oe3RiFm+geoxVejtJ6PUi8yvI/gkoA5k7YgONXKVzC8QRfdXn/0jY/VhTagO1Fbr6QsiDcFbkdEYp+scqZPzrWBtnw8MQM+yPyMvk/jFcS/EcJb+I5IUqU5tNq9rUloQJxhE6q7srCqqi8QT55JjthyFe6B/xXL7Ad0wwLIqIG98iOcC/gRQ992IJRCMLgM4MyC+HkFU5nrQNtv1noOcSGhUcUzBoNlcc4DBsnPTxlPXlID3DmQ25o1zqtQrqcBdsxGyMjuZVLoT17f1fxI4efLGVJ3FwM4BDElfmtuh9kLVtkyY8wjwj5/5oF3YYw122auP4omUqnBL9a2m233D5Qd6svvvC2vw60JJtI5j3OrOoBbD0Wi8apXg15VBVLuowoWfZPww0tw77Gmacsh69gZy3E7pklDlkqi8KXWuhh3G55GbTjoa/mReFeKp/l60wmTpRJlYF79Z0GvRr8pGBRjPoRPua+yyaZmWyidaIqEmFfVZtn6KeH0z1k8xw72104L5HUt/yjl9pqv/5il7n4Su6UvVURddtfRnSlR7SoxUGFlsKfq7zuomxy42v24OQF7x1x3g2ulr6Gzo/coRKLrU/ruLhwtCZHV/hbywvYkTrfYjXqutYDERsFBCkxUTc/k1CBSFzt/ctz8pgp+7sZNn+l7Sin9O0n8lMJzrtrq2w01ggaIkBR51eL/qtgmPHe+dCFlSo33m9xQ07N6PFCCc/TB98Wx3jDFXib4WmRtFFdKFvX6s/rWYkfst0123m8Wh+HZSBQ3YEaglSjB2WvT2r8JNRXjDTzjBSIddlwTkmxP/JUAYtB6ltwLEKgUG2a8Exrx5DZJB8Mz53Vku5rj7kl6vYjN0M6Y+2gU/jpwzFtEO8pwnE47R3luXpkZVpK8Z4lRCh0nA78rS73g9CKNZaIV/LcJ2E6uOK/GiT9NcEW7X6pWVKauzUllW1rFZRBL1ly3uraiFGK3y+ullES+OAGMQPIidgvio6XaGEggr545kBwwrwvcqaN3vMKm9GBYWBcYDIEDKJ96t2azAfzYiwztJ0pWJfFMCItXVNsY7Az0i9ZLudSlPWmI/x74Fe6UKLNFz3hvn4MgAvfbFvYlCTUz+z1Qe5A84oy6M5N4XjtYFZqhGlZSNfrfJ9rkraHuVicN5u/eTEMMAje03Ld5/wNjL/g9GI8YAHxFqvSR8ukfMrQXbxAndLQEu4gHHr+Pqev03xii7x7Ozck+vu0olEkL5cUIF6dNO6+/fF2KRc3ST/rahEFDzAqwbsXN6Tq2ii4QmZWiH/g7ECLegqgqpAS2nRT36/Vnphg85AiKQCawpr+mLwiwJr/yQLHCEbZZBCcE+EfwxgExI+Td67Uew4leW1bSP/mxENfuIYR/psdauCzAWqo0l4h70yqJbcBtmHX6OFh2OOf60+7wdj0FTOAOBAkf8Z/Y65YgYd2uYTP3+pxn/sV6utErEbRK1SoVRmgaa0u82OSVqXq//7I6ZOfbgFherN+ck8uDdzw+jY6mUsu275iMwQwJqoPad1JWjfRcmIKhsnWacky1+vX3Ee911Tuw9ANyFn/xjQ40IW+9Od8iH4vqmkxl0PAlHKUH0oY8Cq/kVjuPRqDkBJYyYWzIty1H8Mhy4KkSjnNHRUTUQFVtcDCrXwjpI6SbYG7eRn4iC25Vfy9eucYc0ItNSnX5d00hRPfmuZtHGaBRKIA7XodqJtFXVN5cpwaG32vSMVnzgLcGNZklW9x9VoMKqp1jygKAQzGvaPuQ/rmwgW5Gz3rQQ7opIB337Br9Q60Zdp4RITu46CXUb0kEXcKHuMf/BiohFph+QwJ+lrv3cMqifxVxbetj+QWQ8g+gu8s7wJwHpoUqY61G8xbuB6Pn5Bk0S2TuFZbRDWS3JGCFtpkltkZ9+ELO7kCYgx3iZA+bZUa4YIbKl1Dkqc19S/I62K0noYMkcll+np8AHlkyKYedgdmPXEyRYegznqp7EuLzveNVICpF+zDih2CpoMfz7CBGBI26szSlKCXcROl0Z7U6nLY99uQRhG6zST3OsDgai1mn0870fdNdwvSFtFLlDHbfvOu+vfqqfYjgSozLSnoVe5H95obuf2FECFPSS/xivETguenflxl+vfgMIGfnc3XWxRIwW1QJwWZ+ldvRNGj4xOP+MnMGD/1EbQ90jYq8lblv3VNgfGqqRNnRd12hqUkSmzOc0qjS9PH2xdI096DJw6sRQkFQIM4Ho/C7qCkBsLftiSqkC4DKCA2KHU5wst9k0nY2B4WNTW5i/+SSwvLCJ58W1JhYzP+XwrPnrBUKM6gbIrqhoU0S6Pv1DTibdDBdvI+yi9ikCsLWQEp/xBZtgeQ/1epLd2iY+muUjEs8Lros6fICYkNB0p1ZnaWUE7dxjyk0XFcc2UGTxMJizeQV7E/sntyohb+6gMezhOjk9EEbNRNcdnSt3DLT/ckO5RF3dJzxMSB0QeBR+fiWt5J340O3dbZ/6w2CTNQstlszs8M4bRw1AVkElbq3v5SqxLKKDKRxqc6rPBkocgIH7ITHe2EGd3WYZMqGlh7EPD/KNZwm8F0gft38TToGURFSfDSJBgAYduWEA0y1xOQECgxEFm4rLGwB3rasqxBnp8OahPi4qyZGkJI2wwT40AGp6bW5bj+ZL/lU0/i7N5hiqVLXjtYI4KKyJtaHg70IUcQRSqL14Mrr4ODuOHsDwKu8hBF+hJevXw/4rSC/zVNEJ8MiXm+5ExrD+qwA/H6c8S5fBSIDdXnYJ1qeoxtLuzbsFiJXmwOWuEZ+wsjgRc7bKxdEi/IBqgJzZgZdvCfhtQu5urWFX59k1fVU4KRrD2GdF3bgjxuAVKNrVTZ+pbz8DIUc0HllaKCH4xUWOLV0v8wk4+9WqgmW5bNvSoLGGWQqH+GHEMi0zyER/RCKwIMxfVBXIdt6CJok69Fjp/PvVbqPbruq6oP2a19yVZ+M6zHvevYjSvggDhPqsRMRnawdPAztiCGRQ1MOPhu4HTOVPGp6vTIQzu9B8fCK2nDOb4350up81wvZy4/+kKc/ByTMw9emREFy7z62gzvVZePegYMuZvTNIPN8Kir6mAnAi+xXpqnVuPxOXfSsEviR+3s0AMRj4ZFZPyMbxN6i53NHnruddzRL4s6JaaGppk02v/20xDzKpBy2aTcgsMrYWZZrTkOA6jvLX043fLCENCH6qVB5Vq74srg6U/D9jlGOGRMLebFX9b3ELvik/mfpWNa77FDYXoqqbWAvQF3NXI+2rFwjr6n0Fo5gSg076fP3gIGi8roSi6wWO64WCPWR8yKi/ZawOzHh/1jqb6QcfnthYlbWMjaUOnDCAtlXocS9wgzf9XBhgrzrkaE6atrJuWdFbf104HzV4ovksc6/J8pL7L9b84YCPCh4fwj057A98uvsSNQ83naE6u0l9fU4b58tCkcQZbn2bnlJj13TR0ZLGL5caaVzIOYaiTDMiGxJpfNqrppbF0d4r6SWm3lONNqPJ6zSgdzdsGRj/C/D1GNXlPT9A9HBkx5yZZXoCcLzi5PVoZ+G84U18GiF2HhQFEJXRppVtTCELzv+2FPceFsDmZCAxJzCGe1UcWZQYOzSCMnLH9lJb+bQzjWTzMaLnMkxVTMxDHkMKN82gbBekP8rCdIF693vTXoUwsX+7NwkQ1ljCyuQzTPdB4RNeDoFRPTx0WWdhub0eD1vnnEQZwjGWyilC086qzzp+f7eGf+QmWcLSeDb7skMad7s+r0O4OW2IKGWUIYWdLWRgKP9GjYfJD6Pv4ulaHl0ftGkgBCH11G1PIX5rkj4sMvOVcSPdb9N2g3ZDAcM/zFjEGYnlUdEsCFU0R9PXijVh+jESJDxGtEDnTuXGKNrrh92MioBkU3Xb22pHBVPbQXmWFU2mWwah9QCgwaP5nw7cnCUid3zFES4jslMcb/hiul/9IXgBQJY5bbwwGLOSPZVxrqP105K1sPuLPKoaDNKefE6YzoqzTDJij1IDHNMn7/DwMQvQii1f9bp+IpAJXXu+NpN5I1R9NdlAEr8Pm7ZXwLqKgMKFQIR0dDxDGbont4XWMB2EzTdDAsJA67zWmUalFjy4ViMtLWt7b7ShrBv30liP86BOTffaTIwA0TnHyoAysrVpAcoQu/IVexFY8ZhG2Zx+XB7YAs8ydZa3WvmF9qKi5sp+yh7C0CbTWkcoIb3yCH0vC2DjkiAB91iVHA0zZ4rkrQKFFmL2MsczParkxJxKNtIL+S357bUnjclVv/DvGLGuLdvdr5c9VxLRdqSukcTR23Nyby9c3ldXU8IY/XXPIsvlkHN8p+HBUqVtJzOYMICsIo1gpsb9yuTwIdvDnCkF7gAdX3jBx9NRh8F4UJx8YxH/N+zhW5NGb/WG4q+zYAQm0qC0N/Nth6TI1UKq7eoIAT5ZN+Ozy4bxtqZu3W7GjOTerWHqq8RilzP2AlvzBumGLuxg2EEcEihrGg+MTKScHNIf1WcPooVuzY647ohY1CGQIRZRf2DCXFXnfhkIpmIdkz8c+8PtrMHyGZ/y+XjQ0DlQzpvUa05cX1MSspzLISGdu/trlLGXqKmaZgKwJPFSAH7sBYEhsmldYhUxJs3D+Ymi+cNnalXFIKSHkVgp7DQun9je8dsuKEIgbpQcGzA2htBg6htUXpU1HNXSDmLKLJC1/sG4knKLlj3QXOfrSMQL21v+fZFlSBwOX8DSiV37RdomezNTiP7CEWvi501/zsg3h7iCQKQ6HCLz7kHRdoyG72gTQcECQZMBD/70GDB4564kgKDBGO2PeNaI+bd0eA4WFXtB6c4QRvQ5xb0ZhVg1mBiExcCNL2m+WssmkcJNwFsfjJYwhk/x0edJ5ueh8wCl55gaymutFSE4oswFawIh5sbCHKxeIoc9c0lnvnkdNLZKsdBHNGQBDgKuq53v+xqa7uYES6/rWevvn6TkzZYifOwPfUl39tb+s040Y1k6ToOQIpQqyfra13f2rBvULe6HsOS2DJmxnzirY5ysCf/HYXA1CpgUzqPHOZACvG1RqPNKhY/nogMEMV7WAJ5rhutK7UIZ7UjB8JPCzbavJ+rJ6zBzUATq/1/DsoErQCp9qxXcXSwv5h9KPNBypMcW/t+uhtWx0l4kIvE7QKBEO8otMvkMzOwXiXMeQfj0VwHNUOCbsqaxeJQeZPNOYgixLsKfg23byBkXBhasT0uEH/LhJYgbDvFLP+MMdcdJx5iNFBu5oh1NCGoMLy2yE4puLhOcvAF33BVrU5nYV2LLhbpgcYOdqFB1VJm8gkfvb042DN0pHXyNdW7rxrUfM0M3N1Vr5SttZtnPtiyFWzu1BvEwrLeoa0wJtf9aW9OvWU6I6hTa4J0+39/kr99Bb08CM0x7IvfISPtsNQ17Sdb2khtXkGXJaVHvWl+arNjB6xBBnNBrxvFHB22sb23zryESzB8JUYHaPO2xMaWWBGakiSsy/s9rzy70o53rjj3JY7M7X/Mwox7Qf6Y/P3xQEWwlszibxCewTEXxug3qbMIta1lKNYxb3hPak69zA5T5sbM88H17avCrgc1QU/e0Z747vvjDNWwvOEqhfUgIkUwoRkVPtzvbK9FswSZF8Zk6WpT0blnBv+Y9mZoTWKCzrKQoSNYRSiicAmgUf7/qXWy4z/GdEm6sJKoEzgCSxbyNjvDB8O37JW3Fz72QVrwgfDVWr4jIyrGEfCNxCJRZ75BVT4ray+TlV7hA+SsVt+d6sDh7OF7S/Y7AYGxqXckj3VN7Dudy7wJNDqdRgFB9eJXD0yXxNl3Zau11S8ZehzI7GYBL0Q0wXqR1njPYOizASxx3bP5eLyJkCu3iL7n3v1wrHkn5cO1rPfsgtl5ohFJR+NjBs2jQl3+SlIm6pwapy0YLMzN9gzcYmfObKtAGCGr1O9YSFHGvcqHR3zv2bKjFIl4QW1YJCirjc8rOs5H2lkq7Am1JsZgV5VJlYAgXDIVZJryUTELXGsxmToK4jgRAt73Ig7JLAERhDIw9eSIeh6mLkCMtZCsmJoC6XoV5qJ/K3FlNvSIbWSxF9E5Ae982caQPyPjgXt3DZmrQo6/CaY8rjQNh9RyCOQPJH4km6q7NpKAExUXzn8106GvgctxQnnE99OlSToUYWje0oo4dn1yjzGwyLYuFwn1k3fyyDNN/deKQqlpI2rO7YZKNz7T8Q816CP34xAJkcsW7GNdp8A4qTkhHyd/rJA6/tjv8zsxyjNJTIrj1UVpkviZz/ezvkWjNLDXXYgDwgjTiSdHXGmvR0k5F8hQR4zwV2iH1I+6ESPAcFiRU5KsFTWFlNh9tQLJzbNr59zjY6D1GpLBv2uRadRU61vdyuT3agOOJ7wrmqDNMUMSm+lM9yAXle/3Ehbb+XuNyj9yR1MKQrwi73Diqhhbm5XwzgZZXikZtFYlNT7wQBUjFcn53DC41LnFoN8rWuAN8krzyqFnTmCwcZ+6zBqysZ74b7UEUKT4/bjKF/21Zl5svxeRnn7BfdXvcs9GMLRJum+9lsgoRVX6FQqbID0upbrtnEdnpKZcmy8vqQMhLXsiu4dX6B6jDmUAD23siLNcsz4Ud+uvHShQ9mxpinpcH/A4uIc2HTfzRK1hnDBXbUPIx3qzadiUy8RdJKoL6B4+Z/Ke/0WzpMySzIqqBF3cdDzp9RULebDXxxDEx89Rj9JtWBa2ykWVL+ixmFEH/VDuxTiMvNQgABt59WYWx1qBQAobKYLffbQUDoKWInMs76eSNqqOA30kYvTwrUHCeodf/Qhxoz1wG37twcc1uZf4bGZM2CUxrb2mJCfoWF0NsJ7SiNtvlXpkxICDurIbXRh66aXrmJykBXFG08/ZYydcQUppj8IMDs9/wEd1YPuaUJ1UmJmhpLZGgLCfFDKP96C/l6ByCzSNAMqYPv/5kNtbXgJSjzROJQ6KSZzujS53GpkVxLbX/0deup5UADXxEdJcsDNTfp2/1NGzOxDTo2mYUkmB/SUAENEwiOftcBpDDkOBuRkJMX6AM45KELj6EEunCr1jHl7FPQbHWb4m6rDa5EmE5Zi+o/jlGkXF8fWYQZ8oeH5erfWyheX6UfEG7M2RrVHyXms1JD4ZaHQcQirWZc9Y/txVvbuiF/5t3Tz98EHzd71ZdNn1Sqb7X4JbteTfyZi6zI+Oi/O8msHAYxzjeGdOHH6XUmb1KC31mexOlS1+jwsCyTkZzF+Fp/DmUGGOxzSqUQLVhz6e1Ot/kTxC2VuTEplrGbbzfza4eoK8g5HtcEaml5RLAlelWYAZ8ZbEhBDif0ThevbToEIN/VGqBGsnmvaA/Nl1cixReU1FJndbxuSWL7U22fGHVdasiA0LPDK/YOUhWkKfTwJ6Jkg2gTkLGZQ9kKcqh+pX9UgPxaWwbk+4j3TjAAIFyqjgUJQGEYC+lfRR+1JPT9S8plwLIc6UUItHwA1t9vkf94LjyPtGHSfb1ugazGYiY327zaKJbRR8cqd+XoMP1W572f0T/lCYGQDijpY/A6N6lQWRP3iOnoyvse5SJSEt6V0QRFe050tZYYFY0c1n6NNsP9q7MS5dc1GEPj/BYWFxCkcBRf7RQ28L6vSV7Av4H+7vyCIwF6qi68No1tKdHZcY5mcmrmopHA9dFCXChG5X6ADPY1zVhA0YIuo9l81pQ56aUgQX5E9VMcsNEdQpKmpxnHUlMDE30pqoIAgbpRXzkUJXnlqjmhm8iqF3/9g6IPCL6SkoPvR59I6JL7SuGDG4mofSSbnha+n1ItTcK8ebaXGfD4mOjMGnkzegXIUyEdfEq7p8VZq/rD1XnfCqn0n9gr1UDOVmfu6fqbRlxbmXTKP9VpDEkAkBB9vQNlRPKmlWdXi/A2YexX/2Xo366Q5Veoe7T2O4FyukNvUuiV3F950Xn+WKM92Nt56WEqUBd8WBsY8VgE8SXsmXGFO9yq/LrItH9M4lqYhMsku8xj7ANgrntjWF5LhazLMB1zkM23SYDp8cBpz5KdJ0BvV9V9o6EDf11Irxu4EsZjl+6E05qzDvLIfIATymx2BqqQrnl3R3sk9ghq4IeVQACJJLDs1HgT0GVOiYvh+I005p2kAj8z7+miYSv43XPUhxDIDrulaNwAER19Zt1H4CWZh+toCvdIzmVeY0xGvX8Sdoz1rSqm8QlHahDPAvPsjqMlgwILK6GUuyUC/uaytC8zPC6tXnBZ9A/ngf5NR5bNDIwN0vMoIKFFi9mQKwzLBXJmsMJjtKUbLYJvGa7WjnYHwkcU0BYsJ5Hp+c12bi0Q0vWndlEpZtRj4ua3Nw7JeMcsusrJkjwzRmatMNmK+x9ucnTMzImLzY6yt5mOFe/fDytPGnDTsOxSvgKRtQ6Lal7C2+HzETPwOE/hfmGUF4DN0cA5iioQRlepxGepKt9HNvE9x1mIWKizP+QunyfY8QavGHwa8D5vaLJZUhAra4vIY8zqewUfzxhb5F6FYxyiJMrAxJEUGVPY3aO8DxROaqS88ew79bN6nIoJoH2a3fQeIQbq3Iwgaz3bxakUB9xrbefG9+jhyqcDVEtX6nWgj3QqlwK0+GWoevms2ZnytiZ27Ij++BtIVWNoMlhE9UZrSEc9EnKBstURE31TxBv2l0kjgB8lQXog7byaLFTELIhIcmMdrUgU8zZERTcoj50OAQOMl3v9ZXzf0GyY+QcgaCTnvi7evMWl/W3TBwKhkwOxFSqVqu0jQ2kLNKNzpo4L9tTbtOX7QuUNfxKpbxzqlmYI0YquUtu/1NVbwLy0ftoMsRExP+g9bcUOWS4FWorV6nQHK3Q3rCYPROGIyBSYFGNnOr8NoKkvDz6tCRs8K+r0pWAjsPaH1x+LuKxVftadMgT2Mwz+hl7Ysz2GugfWaKJZTT4UnNBDO6FqDtgLzqlgQ7nAdmo2tJyb351cvfczYpiEpL9p5e2c0YeIRfIr7eLJiweNIlfQhdF5QoUapKrGygmlVknu+jt9GRjqLw3/9U+snvxUGLPvc30K02zpwkLGzZvTPbyJThLi4t/pNLlyqc6SbmKRju8U8BCXN7UobiQVkWQ5Hwbv91wPa9Rv42HUU/I3iTkMBqQQjJbVClX1URdfatzIveA1M3Tu0JOtzD6J1O9S1A630PP1XVFS/WeLZWNcTvaT3oX+iPAAuCJSCA+shzzrxtJWdOHwhF8yubEpfeT2/k4lF2s6ayiXnlBJtYVbcrwyaH4NLIGti9U/QGCYDQ+QD3G3ZJaf7aT2Lqek9Qhhzs301jj0Gy9N9KlsfU7lo3PgvAl7erETqpcox1QGq7Ft9mf2jUjN42DIW5aW5yU0i0Oiu3FY3Qn78FhhSN0P2INBobjJ1YN7nzKYRUwUFOF1n/uVItDNJz0fAaLMl1r1uNn23O6UbL1Nzq3Rd5E0CHHWbbsB8028v//8o5lAXGeS/4QL50UWGEqlEW4nVd3+2JD/NjSCOlAnb+y/mZL2oSB4LZe8V5OWi++5c6JLQJVb/spZiUTe1JOWnAoS3TsfSp9r7aBfYKJ6NuAIvCSeeQ6QdSyBUQgXA9dCLmAej3QKvzKnHMohBRL4jeSoAJYs0hVwTNT+acfu8XOnrY7MgFDLcwBMKFGBC1UOuLFPm4JsLqOr29C6hFhnED8HjLaQ1/Bj8hGJYY7jRLFeYo+hzOMEsw0i9TwzNrci+z0TVn4rz1ynK9Pnuhzg8D23ues77DSBfX9cVRl3CZnUKAe0x1G4rLfZrpzmHOvyTyplF+2ddKOz8ZDDlK75KkaIMx33HuHWvXGvAMot4hAM4r7fy+j7PbTVwwKRWSVduIOIdD7rfSzdG2EpkoSwlu5jpw+iFHLKZpsdk4BHddtOHE6vtyV9n2ijlakfJnFHaPFE1y4NFopjlgFB5HiKCrGEZLUaEqnrRjUXWNVnVQneTmBbk/9Og4Ia5+MJTO1UR/VCP0IfbzFIcQqLdKKiKjSRZfu2oNqRGfzNvSKigEreICz3JhjmrUKXCY0iNgDtyxBavBum4kwGo5SdSxiPKi5zhXG9TQggzn2D921KSFFKcP7mwrvzVBnwaV5GdtizfSdTJq0m7uIPNpoAPONZmvKLCpuDbRE20Y0C18jLgcrPFVa8PUK0G/LGKycU+Mp6eces09WTrYajfNgCuuK7Byzml7OcHJnBSe+ISAxL0HDMsOzXFDgMHnmCzO8rcnH2Xo6CWbTW/JhK8iM3wNGZQg8eArhu1yunXVqvRuoc8zGyX1gslKch+IMTJHUtBU4ARDwYmCyCNIGVr48gMiQVep76k95fKbIL+2dT6BkqDdhxPvX66S1C4WrElH6XmSFNCuJyqibA0pxmgbjeVI1loqr1d84pKCzZpFeOm+nGEydzIIdlY1qlhY0CEUzNFyVjFbT7sopsccffRFVa7lnvbq3noEXlcxr7z6uum1garmzwinR9kQfxz4oRAqeghcEzlw9YjA9lWjmKRH4+wvBih4yRB4ap39f9gWdpIvqvH0ehEbdZV2r7XY21UcZkPE01EBsy89r6b7w2oYPcnFZHok3QnthNI02oFO3FXdyMvFOY/pi6WPb/J08hMZMku3FqVx0bvrn88BG46UEemQZpB9dUv54cbsTlZpEGPsTcK+BCCXJupSOQib0SSGep/MQ/RQpLFG4/h60yIXw1KxLj4UIJzzfHsgtHp2+7Zkc3fw9UxE+q28ZP2nO5Lf4kFhA9O1PYnNU0SpXZBadZNbwi1F7/JZSRF8iIxXkgYyPvZzigPvry3iIm6rCSgIY9+6htRWujsIcmDCY5OChGr/q8U4T2+4Q5iXkgVeR9V6s1U+Hytgp1a1ynYljWl7pgSlMsOUrEj29+JyDcXkPru/r8ICRowrXfQWIp8zkr+Fy1A9AY8jAUJ/XrRZhKvVz7NUNsI1qtnxIThUuN2BlUwLBpMurZBmSoQdnMJSHCjnMqtX2C0GvwN+Wn6g3DMvfE3JGXIyzsXqQCbd23FymSJCrTaAXOQFtgGK08U5/k6hHun6qsmVOuApQm+2cg6wmF+2rELDdCOkcA1nYUDDJRtcJF3F5krW2Wf2fBTOyx9tSkp3IcbNEwJzJfNS14ko1xwsfNSoN4IFuTFWVhkSv7M/gF+ledY4CuFRENK0ci45XdFfI7X2xB4yncEUK1qTne1stDOCHG7JUQ8JsF7PaSpvTc181IPwPovorHjL9yCGYmVyd2zr2TNbqYxCxX/1fejxCsS5XoMAQFd74DBZMEygtB+iw2OQMOMV8o2mTBtO7rL+jZ3oiCuxPdmm2ymkkOLjdgiCwEVtidSv6lqZS/NqQh7jSIsuP2PAOss44ZYC+1ClBVzqErzQDlw5NBh9PG21f7Y47o+qVcUJj5b4qniDP0bkaetEo9s9NVUvO1kpM8XuQjrRqt7F+rI2EwSpMWjKDDKiiYmDq15F7i0S9UJkYej8zVDVR6Dvyq1lN5GqUeS9qn7YvTdCSLEFIH6HrAuxkRQvFJtd9irj1OQw+fabktIcsXGiDnoF5MhvaIctA9+q9cxfkuyUAcCaugq6Mq/vkJl0EVnSulq5oBolc70/REnswlOnn9hP3wgmfXkozHGT29wBWoMgxP2ffMc5x61G1BEOhcDh6Guks4sW9jXGtj8zhRvOik31d8d/gF+a3J7st514/8o2GOP8TxcV3mkz8JYuCSj0hUX8U0/oOJjYtbpMa4blTmi0AXaEIlIQSrAK66dzyyWsrMgCZ46618FSpSmZD7vbcxDHh2wENlYZof6FKBFMpgBowjhxhVI93Jnghn0cLbwfNK8qYOl9scSIbo0wfbvulFaxDy91cw2YcaEXVeNXERJQs5ACjDW4bc2is+hi5pEBEASB9/8G9zaCkzeLwaY9QCcG8ICp8P5oVAi8QPmfznfmYTCzy/0FMywMmt5mllrAomXtBB0N4O5VO1x4S0VwKqhp1BVfbydwiatt5fSkKwy/lWdhTc+AKzFGkBGSzIc/tMHQTj2NfWy9tb0L+yxOS0FQPDhH9MytbilOmGVNJroB/5KFTzo7xFRCPxbaWC6SdFDGWBZb/JZBQx8vks6wH59BdriTrokYwlRbGaaboDonjUGR2r0zUBRD6Z3jta46aHbL+wW29bjm20Imvd+aVVADamxIvc4wItS6U9wSncjpUs8GXBUcAUER3tOFhpx/KipgelpfnXG8kI+g9PKP7IlERrghp2l3n8bvIZKjy1RYDUKwj2bAMF9JeCBcXA6YLYa+Ci/Tf7Xb7900elo9WXDi6LaJ2Zc9LlsACrD3gtr50l6oaKUeNvj4Hh9rIchSmAvuQz21hUBK3tz51OlFRpi1po67yxFbmB25PyKMlfqMn/UGejYer+DqAGF+eJdu0unb46LVbcyEOSyl+Fk4/msSQDizLlPW3lhSBa07ETE0ls/NlkGAUXxywhw16y57zw2JS5/MmerMGY/8C9UuI0YlGEKII9KKLX/WvHjykFFrISCjpaLw+bJebiWPlMzVxY9xvg9iwNucPpi88gSVajJU0Um2Kn56cuQsnzCvIlxHwkF5RRGV3h/ngsQFRT0F/m+Elhoyj8w6cNU1EoohnfoNjiQrNuUBIjM851bsYlxMKuaCI0deGTVOmxp+NnqHX0lxvO/WGeClRxOWpfCsEPn4LMR+PR/dHOSwtlOtqN48P6LdxmJFsasWxmTLA3trtMv54TRGQo6YKRD4+8d6L1HBsR4xfAEBjLF7HUK++u5hGzFeUQyL1IZd/tPfUX36z/y5sfiMrhuW/KsAAr86ByRM3/MpdZilru9ZfhYWUOgXF3hsbTtTjOo52yJTvygAGGnxK60dCJ3PrRqy3M39P3zx/ar9Vk9ybgsXIE9k6QEiua7FEn7xt175y7q21urY7bKnBZPGYoaXNUABcxaRz0qLfHka/Ku3wZUm740NxwrdYmh4IBqS4jSZVBn1T8G6TUajV3uUEJNg5pqdjznAWUYjxQ0d/Vqvs/7jLnqqvz1pI+7H7aFh6O+ZmmOABbVxHrnPhhQsx6IJa1on4XPepliMPUygp6f7plYxW3XDGg0PwCxyy0+yh7p+lpsDPEnIszkDTJl5UGUc/Op06cvU7sUZIU19RYNV/J1czkzsw1QvF9t4mcFEjjVrwqT7Pan8hBgDlZTaCpBNQPDY1pC/qzfwQr+4lHxpU34FbdCZ1XeFrHgbGwSCJ3ZfKMWMaxaaaYBQ5bTfIxSKZR8WUkDJdKdfNxluD17cPLCUbXpDJjqJ10JI/OliVxB5mUYcjRVJOnM+uwTKd2s8hOCMfWgLd+uPcZedTpAiGWzdUfJToUVAwox9DQmvYcRBdHlvSz8gczRipgqpfJ2VsKH6AdqV4zdv2Smw22g5fxfUv2pt9hUQEdIU3TqzvnE0YzC1gzj3TNMTxiVOFPD0VRO7Zl92lLHQ+D/Uu0SnygLwyLQJFmDnK0R0G37/SdKYjAmcH63OBLYy1X/Sy1mBh4uuTbUHbNmZaDq9IkCApUALzRXahGC2xcI5UdaJqIBHpBsMICQOjOe8LiLiYtvXv1+xI3y4THavuCnF8bmI6kaZFtHerR7LKzTJQkSTDPpP4Lp9GHD/FaLt9LKEIiK9WwPfl4mQ/VNIOWoGMSxxjVGmYQhFHHV0HZiSvdZKMr+Q2lf+M7HNsJnzlNaG6vxSiyrWa7mCdvOwldxs+Q0GlCu1HKm77PE5vTtn2Vjfqw7t/8Uo+S21gW2ZCouTrTd+uu7ac4g/aWIrZtnSzLUAjWLRidJa6eK535EZoqjFj2vOk7pzGvpbWZniVQhqm/rhondKCj4DEE6YC8flML9qaQ/vMBguL4u345N0AyOQXm/qKnwusgUyZSrOGyWYiVLTn81asPUwDQ5tf3EjJT18MMxKqUp0qbEO5/gqDzpOpb642bscLABvq8GPtJ6xeMJrtlbJTzSJSqlqgYU5PduxE2FcE/i2C5qvxhOriqEVXjkD/4EkiTTTE2vSUG/yYvThfJZQMolF03XdXH0HZvLpjQLCL07ycJrMGOOSaTCRaLZzXG3CoSJC5RLgBFg4TZsDmmp6dky8+juhQ3qH2YgwstFbmeTn5jvjSVD/YEm5/Nz1Ng0xRiJTjRYrkDwCPHjeWO04AJM1TcK6J0lpTdSH7qmhCqQfJbEvQ7StFaAvmVrgiHYKUcvreIGLcfNIRBMsT8CJMV3rTHHjqskRk7FuTU+YlbMNG1StPCjgFvZDbnZFtQhHb0ZPRqbIR/MwAfxpEKRy6bakd2vPxGpnTigPU3YOu9Qtn4zuIdFOTObr37mP7EwXw2lsYCapow35NUvhbYZ25BYot6/AcbUVgdwu2bIrspbzkEDbpfYpb3697dRcsLuYNQUzV9FdIkY8PSDYP/w1BxKEcZur0Fe3/yH6wPVBP5QerILonzgP7FdGfip0hl7gPnAketSk6V/7KNWdJDWv26sneTfOLvi6bkUxUHJbojqrgMEBL7fKG7xyBBnEFR+nn2gGEUrOWio+G75d0DB0HbrBo6RtreHnm0hIWRbwNRcK0FMClCH+4R6v6eD5E88acHvHdWQpog1b9LpWm3BQBDeQ2epDHQyiDZghor//nTxF1TQMrZG0S1Gv8lptkABcwiIJPgG+l+FZ5Fc17QDtKbLMRKlKEyTMSFX/SxY9Cydrw3+k/jQg4dSH2AnBv1rlzFlYd7ezdYN8LXjX+G5GTDsHvvutYCFY8CFlUj/C7VP/CyVWVedEG1XLfECgw/Ahe6+yAvNUBM7GLtiqEt9zjlONhSDc6f5DTth2UgAYYKlz6UlcfdSSvHByne+9nF3hYKoosqSoOcrMmDZJDyVKFx6FgjSzprXD058b4vGyQKEoftp0L/4QvuPoBWph0x1tCfM7U+qDSZRcUGqqJL3JhE8ExIkpuHMKCpzn3kn3VYxZFffPoanlPTC30a/i5jrtm/KLAwS5VAGeDYEWV26CtfEH6/TJuiEsza5zMslQ32BM7ZrN0539D37FZuQb1JRPuLi8nv6JRleyTs9RuSuMzSXqQu056+PkjvTyvW6k+roJiACfCO8WsCz8a4Yy8KYh1roGfsnQmGGjQf1kBqqsBEVOlNuqgIDpRU6Q2+rw3KEKqGsVutABvQfPA6rR8JAlPknqzY5HRzsB7poyK9EV7p3MIU1ad0yYQMBcowb4W0R3EBIVQTUPGdMy2Brk37AKLUbF3MBghYhq0G7u7n3saCZBjBSC4+bxiHaEklMPO6aui8I1b+KmHGRNBQTt3yWTekigUfcbgq9H3eiEzC/d2t7CbwQkWgDSq9wWpUrX6kUXjBmt6SKoLuKziFP7rBjdkqoCMfbycvTozPhVHG5aHfWyw9ps2y1Stm9mWU6t/50uqCylRHtW3VKFIOumhr73+HhWjzD/h9Ekfa7tcZQD8KaRv0k6RFfW54lAjjF1nrdad4/Dv9EQirDtG5CVQ9n8E/mF1W3D7HJj6LJAvsylO3EWJiRAmfp0HA8oglCO5jLgC9mWaC0LJPlZ/PJUiEB7aiyBzmQ7BfjBRnVRTrvUX6Lgv7YH6UWv2sCM1YJXI5QZateoxCU59jdKyFFWL6Jwwv3nqFwtxXOWdnh95Pj0TIJACItFY7zIgq7CCHFqrJGxjIvTiKVBPwpkcmT9xzJ3U68vi43jwMwREbF8UuYwqac5AErFni3DUg3bhIdqvMhq8dhq7xJZTKGHV7qrX5dE+BUXZ8r/KaIJBKrX1IF6nYVicwHo5HhYSaHiPxuUOUZ+Yg8asQnmV+BEL7R5K//IZIPAI4jrPyPB8knjZ/wZrsfE3Mam9DYgoQOHyv19l2URyyo1JmwSmm6bDZCDTYE4NUN2G1FGnil0YwBfV8FfBYOhuc2xc/alneo4m0nVupKByR1H4DW4QoFN6/oZ4g06MWf7EF/9Ctnwzv+wE4PzpNC9PEkyi7RtFNsOpRYqcmD6RMPXmGk+g+jZufuraCS7aRAhqPVRIYwuXbEQ9vOw8FJxBXiVlvoXUmgWDo1usdmDrIfPfguQFgWJ4NI/ebxbYfLJ8Lcr2MkpZ8MiJrJeVzi6YoPTa8USsOlKAlP6B3CGrgJKutjGXh89lKpySEBILoCE5/y8RxPbILY4XHDo8YtUDtQHBwSDh8o5Y5Kg+u2ZZBM4wosGjBIV//tRfjM2fHtldx8x2EeX0L8pV72xJ5uWmG2WBsaLYeP8RwMq+Qu9stRM//HgilTg7dEeoyi3+7BaV2E3sSfUumoWoxV0Lh5ZApp9DovPnCtuza/yl5DgbDBM732yrWvDoV7nc0DBbgkZeQlorgZYsU7croh7fgB1d77a0V6/qpBqa6QKpIHm9NFiy8vTccQ9TcYVT3eUjBGqcY6/InPGPXflI3BE40LlQRBPSl4I8tVFzidxWAfs92amMv1L92tquPO20Xi8qUdsHPuwgFVb8jPCpX8uS8y3tIAAtInXaoE+h6QnbG86Bpp7Db472OuVPXA1rxDe+4loOqyjdSZZUeOJ2V1qiXaiDLJbS/GUOK9PhXdV8YXFBnaR6WINIExBS1/0jCt8MqKuE2KcgD4GZsHOT0rUrx+3tZEn8NYLkpcTCNFYVBZ7lEQtyQdgimfDSWUTKLsJgJ1O1zof3RX8MpVp3YweT4c0Ui9y/WVQfaLeABkwNaa7rZ6SgiT2Dqn4tejRp1PAdsAicxpVjXDN3XVYwY9sF6bkTED+DNh2xH65ZqUJY6BnXKYBENnsJWv792rAy13rI3qxiyW/3LMZu15OxVlz2ljO8/tLmy0qe3F8FUTQ2ItYXNEYOwO6fhriQdFeTFAcYnYYUl9ENRXBJKxdvnbYp/2AUHmFVFkWDirpnYHFi3wO47GPjWoi8KhVs8nqh7qeLOfQiolVzihdmVPT6p4TEBBer/uXVzs88PolIiqzi8LQKIi9cDZLSEyWu0++OqvlXGKxHd+A9CD1Ell82xXqExwhKm4sx829y0O2aXGPSjq4B0FODi9h5CG6rPs63DxEI/FnXOOmQE999tcS/0o42VI6mbTTVSFajMAR6feduzOC+0ReuNuQVfBnCnSj/7qFFCCvnrtLn3KEv+7u9brhGM9ip9Y0che1WqhxXi335M9Jlg6iW9C4UUM2zY4wQiL0J2W/d8Nm3dQg0lcAvu9YoX19cAeygD3uho+I6hMMjzMdwtwBSBxfQSrU7CGSfT95i9rzYRNxDaxexgMrvcYaRhoCzPybUYzR7965Y6M50I3auAgvDjv+UrzvGHqAHrGnc+qzoJDjfq50jOMFVwfWAzpzV+fopUFsyeHsnULlDO6Y6TJIk317rHSdgOmII8hAxnFwIakFfLxroO46l0+3xqceddxfkkUnys081Od9VkYzPwoDunlX8R9cLnS9BkMRtFJ9PyNRwOayzgPnA9RwvO3p9IwmGk82szGMpTcdON36/+ZjuIDaS27XnF2oa9UK92PkgdkhyIireCjk5smrzR15fkwXBbhTk5WGK0vB0TYNOiU5M3pxf2QiWnP3nfqAXum2M4YvCKHHW8PFFcS5uYw6ef8h/76pYb+ODGzYHoTkD3jnkNtllITeV/uz9WfZcJVxw/qM0Pj/e+SsdHCcFhMByrS7VJt6m4cS3EcLL4714X8sTvRrhahHEGR5QSjXcBK7ix7Nh3rUYDrWKtznch3InPCnNEIQzvR7NAm54Eo3/w8aRyeHmQfA++ETmJ0gKfzqYLxB78RK/aWDsNfG4pNVOmbf0LAWkiMeLMle8dALJzLjkN1MLRECGirjBT98VURmt/Yd+/jA0H9B/IuJ7twyM/iLp/xhECAbareAGfMtbVozLjWP4WvVrx348XqvQfaVlCDR3x21x8ttANOB6nmhxKQ+DENY9epdBWIA662cPI0AxO55jgDLotqImLCE9PjyEvY5+356zrXwj/5Kf1fu8YZjNfXP7t15oEowBuuMx8f7POfnvriiBQUN8r2Bozl++gFyRgc98iK+kHWmexLwAKwgMUaSNsRFQksBNzWaFkg4WXTMOrpB+n06WeiI3LgXwE/hyZvE44azWzZaQacq+rljgBAnLYC4F++efowXumaEEFbNIjnz6qFZjV+7CV0Uywa0ao+4PwIGHhhHMM1boDC7I5bM7w6SPNNFb4KSjrWE5kgPjaqmftAAw7O8ucwAs85P9zy4j5S99V7D0/nhdl6o+nsrGaj9HmUjkSehjEjcs3fCt6tyifcNU2rgg7p5Vo1uNNMt5OHeGzdPwDqx52HwVA83Qd9512LBsHRxVTquzymisVHHO7MESn7/SB8inlx3/+WCVBLtdXs4akViBCnafsESPs+RQ5lGhA7bm+aVS5pJWZt8LyWvSWemhlZWmV2YBkCrjEd80Fg3X+fO2LC04AV2O+JNSerdaMr/was4kNb6B2mq+YxY0sHPG09iJCqjdMPLwwl+RzCvRJuQeJIOvh3B20sRhP7UfHC5mAdpfRugb3+yhwhQ/aJE9LUK0Nk891ZLx/tyDlfwYsEozM3CmrKk8GqQrnm1/hQOYzQQQAA5OaZNzykV/bOHGwMG6HNqIKtSZpr/O90PGB8xoEdYTPVpIoBaxtjB3dQ2TOFVeaDyEPj8agNPDd7qnOfbzqH+02GqBvf/dydx/GXxn4kplrREgauaemhj7ZyX7K5tJpmnZyw7dv2Z67YUzdP2BsZcpE5kDJRxhRqjK3/qMQEJe/8y6GdX5hbki6egmkyk6snar77NfnSdU7rFWz6eSWOGPZp8/fgBFHR31nW6aM65FWZDDidGX7lIjfI9V5+IsbmEqdcYr8SIs4LmXzd05Rxgz5SQtiWdyDjRrYVhHQ5YgN9vteXsVqkBnD8PEZ0FH0B7gxfgbkdHIv/24pB+7Dwc9SXa2POTFN09hS9axKwFUioLppbSaytl29ZRmzABC0W6e3690zi6nU6VpmR3IQrAT42XRoSO6B38wD1ZLyn62L6gHvM192eIFjdrTnL+GPlt6m16PeoeUC7mOBPI6HOAfnaLyzabhiqRiQ7VNIErxuRsh5YKYkq4b5t4ucBasPabjA34Yz6S0L1tUC7hMsETJqiME05QmwALgb70wPNrXeSZCMSy6bF8J9h227WH9rSeTGh8YD93HR9yQbECn6X5QpUXv0ua/0RFzEzIH2opUyK10KGy4zRpnFa6/6seQqy+w3U6DzEH5fF2DOsgIHgExs6Xb+iwC/jHE/OaTDlqhHIsFlTHdCL8kQBjYk/6FB4vNOeqrbjYWLtxxE0Nrwx1uW/CQLxg/shye2aEko0AtZjMOeJUT28RLv86dAOKdEOl7r/dcpGedFpA+9PpaBntgTUcoE1pcMusl8Fb2I4SP5TaIEcqumtE7d0ud6Hup5+b7gsMzgq1C3SExjR6qD2KC3N56hSY/EMlsv77vCcn6BqQ3q8AzVCkOQDlYwBTzOw6YKxpDYCkBLle2RKuIA82COfXrGwWPnx4cMm1u7Xah0bwyMw5FUxs1UzM3VFsspnIWB/03myNLSOyVJRXP+VksxtlesnMazL6ccgXB1bFRoER5rg14f2kKv7RP0XXWh9VZ5NqibQ7iNIPYFttpgGBZX4whvOQfk6pLoW12J2cbckfcSVYLcAJLIKFy8U72NX2Vh60cYzM09rKRr/7BKRGP7qhm0nh9gNWJIoooq8CdJE0z03FhrwNE/vJ8Bj9/bIaAUOtbcVU0ztaqWG0hYIIXupL84+UnmzZFl1cc2uSDRmz65UZg1cZOHZP5EV565h36fnx244iM5EUf1LBemfu+6rKn2GEonU6qclzxrC2mYOBronglRyAoS444bIppHuvb74LAzyyr88/2gdH8o+oubYRee8Xtv+Jq3HLDY/g9kj5aq+x9Sl5hd7wXxgdR8OSiByV35HHGatfZeExVwLK+x8RJ3dGEjKu4c6eLJ+eo14OR+vwt7B9RNEWaHyHyCdm02sJmtIVMh5u3k3e5cRwBchRugvRcOP+RXtIjxXC67GBJrn8EkOTuzwqZcnOdkiA92UIXMP5vqOAArpiYbNDeqximG7jFFADYTm+zTw58zTx/vuVrzxhRcTT6jetN7hGfPK6AMdlVQjBe5HKfb/ZmXVmvWNseZJOin3l36lkPnPGte4ZEpzsZ3mSxudC9iZ2Tb9+lwL8ZQIMBgOzX7iYnOlOURznZW98e+5fHOpGmmyQTaO+XqvpOtKYEtBkDZm4qI4wBB7EQF1/EwFyDynAx7Pfh2uquTCWWDFbr8zgobAYUHR9lHkSxsJ/wW7LAR/IxXKF60u+HT8b0zyfH44srLy8/k98XdPo8TMUI0Hwms2uDBTN/251c/A+XHRCIq6Um2xM3mRqzPwMzEns+5aGNAAzbwqFZ9WQrwaXIQ5fUqrnqKriKDM5JKfyIMF2IeVzCs+7o2aUCaPqHXK2pAb9SqWxRRdsY86BRIs8ztfLABxgHq9BKUE2wC/3+05CVCWk45SbTpDj74iIHDCfy8YwLLus26zTGqY1v/MTMRdVz/Py9sa4Lcvy/u7ZtNmvA3Zg3ikFspfolKDnDS+Yz5PnvRqdIDGksFVFv6nWUdxPBVqJhw099y/hu8d2uMChqFNIHHXFvZoj8j6SXVFBk4v243HQUNSo3uUYe4seyP/RH2IBfOD1sIsVdmYyKbc0cpKrsNR6Iy2XpzW+eqfqQdtpHVt3G/I2NtygTSe+1hiPFmzyJekall3ZHcfwHkUH/gwuht06E+m1GOsRjJvn7BW4UXAj9VqDIEu6mCG9Z0bULI+HZAf3XvAON2i8/3PzAFwmeHWLLGRKNdoPYT8+yXhGQnw+eYfjEbIfK9PxxMdZdlTR0OG239PBMy0ugq84HFnySvcOviwE2kehr1Ca0BLn45C7WQmSNvijeNptk5Idg0zM4xBrI3XU/hJ6/qv4mgrLiHfPFEDPy3/oFGw1R0APovLd4XLNO5iGbYfnTJzAr5jBSbC1Yj2ff8N8Eb//9vtmOHFgvEheadtOsbOxLbQ71JtLs3OQjX5XsAho9cfXbkMZ9Iueo/kmqWiWm0h6T/sguBEzRQ3tJpmwF6e4wU5xKP6og+L/N8pTfsBWeCfWYcurjVPRZhzMkXEdBU3razPAlHNMnhuCjXAaVB1fD8QBLIHCI9PbIe9HLLBS25vC2FnMnFW8ISPjlgaIg1C8R8ufJtkSmq/RYQMBgijaB8K7mLqv60cD7eieXGqYOm1x53mM/eIcCjsr9D98bbs5leCXd+jvGd391SvnmfR3Rg26nV5aO0b8H5tFJ4Qfj4p1USd84wqhKOYYw7J1tkiWefwvgnCp9D8Uv08zwHNk+K+R+qrv3J9zFnX/5hRymGbzDtY6VowMbOyJxKuyPu1l0C3vJHkYxyjeQM4ITEX1StzuluxZ9uC8Hs3RXHQBxe5O/Tf5f+MJyaoY9kD9meiUQ6xINI70UhYez2cawcyfKgYCJMmN1keIiGIDwdTpW73fp1xs5GpJcjHIsfDBoIRcwdSYb+PYWMLqxaGj2fFS7n3wbEFoIVQt2eO7l0egpiu3QaaMBU6PBFuwBBBJ5mjdwdFGeSuYBKWf6eE+gGiAhlSoNRRb6A1+5rjhh1Z+Zcdz+pM9ZwModa3MHfByM4n5QqZAF1lxDnrWpTi8P3rzTVT7LLYgo9lZCrdr6qYOG1k8OteA/U6DnsZ5JZ/JEQr9k3AtDowi+ftb6c4cIEVyfwEX4b1D9iHLAq5kYZz/n7NKaLd1qW3zXf80KqpqWhhCesqljAvyGOQ8RI5AXMPZ+56+fAdUTaJpFKUiKGelkpC3C/4tSTDl/AluD11xyfeBylqyFQSaJZhuz4T9BfHasL08t7Z0YxjIGtaKIvxMrEnhSK25YBO5sevXr52OKH73KtQY0/IQt4H17mBmmUkzK/cvuM2h678aqzQ1YG1KIER+NGL2yxJmI01WlSiZrpl5l8gBkioxu0e/OKaGPnlF6MT0jLH1XyLLbkX+4ZbziyGdDkzlDuYELPEEgFpUMR53nQsS7OegWkNeczd4rUNH9KjRGjmI1NLR40n8+q5onMIuCmWbBd3mcVg4x01SrQzIx3T34VaZNemY6n7a2ySb4Plp9ncpUUAqxmRONo1s97rhY2ItnPFy9gEaLIwh9x+Yehc4aFDw6x9rcxAd/Biu9soLoEYpUtgoYySegttOpmSoiZw1D5K1/KMFhH06hL5nDLALgHneJembEVBqWN36h5uKSVGR9VpnrL7BlLOvkVNBXE2KD+Iyx6ed9huwYjZACpecFcLl7nWFHRQsXXgr4m4sIQbbHqm/o/C/D5DEqvZ9kB1roj5fHDCZ8mi2ORKjPDIRhCQKdCTMN109b87DWCMRVta7EWO4U4Bww3GCiuCjKwg5fq5Rosz8KarqGA4gTO+jU7yo20cpGylcTTXdMJqgwVWmc7Wo4N3MarHi7zpwTthqGEjk/PBnu39RXiKm6pSYcK1LMRpAM1vcyiQfLiYhFY6oxsX2yyDaSwBgqh/Gzxrrwqrf9DhmPX38JkzVa3SOXokGSlrA0CQr/v/MH5ohWAOPsxiBzWFXgZ4gxP/tpLd1cGVf91lcbyxEFFhs5phwMcrkbSQYFiJ+V7i0P8HZGroH1nGaEpqfohB9lN74A5sRM3MzL3k10bZ2D8q8mvul6MV3b4UKXJ/MNLkkgDJocvbMsyIwpzBhQVPtjDw9XUzQtkk7kPgMLOgn8MjSpQP/cq4R0GKp4szcqenEEAwd/BLZVYfItM1/Icg0RBQm/Ix9GdOD3C+6RKCoAf4KgkahQ5Fun9npPf+QMQ3ahkL0NEpzQBUbYKGetn/PVBmwzcT6ng6mcz8V1FbQ54L/J1okY4BJAYOwZITWKg7uI0Fq7jmJGF9Qwb7ylJ99/yBh9cTJsfbxZhXXEfb60qlY12G36wf/2eiAtQ4FKvXmiz0YmCWv4+60TjrvEeAHKRpnFLisNHebSRF1WHss0+94y70J6FJsCNkVeMhcJe1Ck823MumbQKJuNOs2fRKd7cXGcBmjlaCrjJjBj3Kb+Ol5kxLP7pHIq+vhQ22ehZDdy8NlUdFeOsJcs6/LzCVSj4CATnaKpBZ96a/9OEBdAx5wKKSxOjxDULYnyKgjQGKUxipz3FCpk+lQeQ3RwtLfB16PaNKYY6QHmkl1odEvJL7W6kNjIEpEOM0IFaDddPBoDzUdqPBVtBUP7ySUYPjTmfQwF7ZZlDWE3aJi5x41qtqt0jN2VdeFnMpiyhRDVaG9ePB0EU6rSTWh6z5fMimadu4J+dC3wG5U4EkkUc3yiMMRNXE64oYDx/MEh8fSYfsEXp+F7QkZ70W4vN6NSi+jMw3hfcOHnmClpDOYQzdqDL7UAPSdY29NHa5TE9NUsyn1jNWDqzSSystu5ba7L7XkT4BIRMNyMvFU0DouZYILvd5Vnm1IuKQx9jDL51SC82VObnPd88pAr88MMiEwS3Wqy5Sr77oEr8xKc4QqLerNHYfGrDl22F4meYhB3gHWWJhT12KRac0U6RYQW4z+uJ/9/Wf/vMNscrutH0v7xl1mPT9o7eTfETp/mViYg2DNlYXM6gjjw76JMHvxO1vEOun/ggRORy9K42RXGrsXMaQrLy1qni0VC+SKiegYguTLtW3Sb7Dzu/SrQZrxeOxo6k7DWPF6pytTbBA5b9OA/EgYxR4VDnpZ7p5dTG5glzUOgrLUqXdjTHnFoxbNjzzIdur2zEhjYSQV0NxevDCMD3w0S42yyubi92oiuVU00bhiLFNQlXmpuECrpW6vPbIDixCq1+Bd2HEiRxAVsajDDr7+whTahjhIAxDQ7PDDKRi/jRZPbuUv2PilUl5gzZ3t+piKZ3EJd0BtQ43Hapv720AC146eY7tmYw4w+wPW7mZlJSwpDi8AngXLnXFNwXr6/gfYn127nd6ptHr3Z3Fp1Tdx8AN8Drvd0+gTRNbxooS3IJUpnkcm1IL3lA2TgrU2cQ13g6JcW267ZfxgV7JCNCkzJh5NXcjRTJt2moZr/kCIHH1Keo/ATxADYn03wwBnGA8LZDwxiRxJEn7ON677mCIqJ7Q5WYyREUBOhsxSz3tV7wbiyW2oRdbFQ5AG0lYBCIXaqblgKgk2CGDJkMlx/Zf1vsrjrJ+uoeVDVSxNHzk2KX1fYP30sYOhTKfAGcYN6hQ9rkI0TN5zELpz33uP1qYJlAtOly9rSn/S1JyBQEQkPhG9Mt/tqjIOlZF+AfWThlYK18OxFy17+2Dk2igXvzewWPqFXPCbQdHZymSAodcQyy2Wxjdt43Kv+XJkIontKJSGPCDZWC4uBIflClceDr8KEy80ACv3Mf+I9/5ndhlMhX0LwqoYAwoBQ65cEkn/B2IDLiMKJQGIJw1CEnQD8ZJGX682uZT1w3SVhhZfYgk4f8W2cUwJF6Ks2TBYqRjVpeouhIPqJd9TdlkkCeTioH0cCmmmnpwC079sdfqD1Xy5mn3OzHiLtkWZaBFiSPJTOlkkhL4H9S8da+v4+SuqUXRTDhTMT6/HL+reZVRFwaHhIgPmNdIQIUm4GTd5+wE1USlrPCseEwFo0Hq41qGpnxDW3barv/ga1BJKjuR7tXyd+aMQ70dUeaYkJ0BKxlrMrWieOXdV0vAUCxvcM2ghK5zSj8YgFRdeTEh4sFT/sCIFjrZBgbBDy2Wo+JYYJkXZQAgRTZIK/WAs+eqiq+p/Lj3BjfzIW9NQQdtpxuxFFCgbPp67FmEyVXita0XrGjMxhjRpr6s1oiwPUArYZrFfeRaIxaHO1c/2OhLbL6ARF0QVIItGUTAQZoH+ReO99R5IOFXEG4o1PCiJSIqEknTOPd5hR5ILaID4OhwpLJl/xS0wvjOHgzwR6QqEg9Tiox+lG9u6aWCBsILtw2P9cIS2rgQDQ1MNbGajpJOU/gKUC7xVwYAuJ8RO3rjsHIhQ8n2U4Gc/AWM+4AAliaLImTyxRyWdR8ITkrJc+7Q5vO7n9PTVnokAMd0N0W8fQ+jCspAu83OEsI0nMDKBocvl987UMs3pmIHuhRw40uvvIjadUJTRhYgx3K7/dDS6XTZTmGZGntR/+RJ3zCb5MQu5utnNhaipBJNkMIXS+VyH9nYydgEXcaTuJwIxznBIONMwaowuafpuh4anniBfpOzgbcV3RbWfzpOwIrBOLhqgfG1LHXBrz3Y4LqTveJZMWTFaWxNY3l+7Vytstx7JRE+XcblGZ+7o1psBKWumytsLMqdNOCYGvMGOQNk0uH5J4BAIM+GnVcpRKuMIb86knoEa19Y4F1Setnp2I4Pa4fMFDw6lvbpniT4dUt07yxuSjyfbi/tTQSwo612T6dhR123lLHRnTv7rlEPATsSKbx+bJ8MQ+Gh0CFjizDzzQaSYARQ4+kKOQe630TzPGyasaaj86M30OH1cI3ge1xdLf9wjxlbwvefZDyheKK7UzyjhhqWeAG7UEgbbQRuqcFvlQQnWYSAhSpM8F+57IwAOxJTDlMd6caHEd6XPO0Q4rOllHsYYGfoOFi/bDiGn4RfMza7aGN70gOTnrly9ganTmtYuwciRpAU3dER9s55qmryS28UqmPVKE86g4iIN5shqNpbXer/R9R2JwNNZuHPkPfQKCHMlq2X6qHlpitW5jsgp4VkBdyYFR5a92BsujIDrMdxWvOke4BB5GoBxsWv4Nd4fyh79BDTuekPt3PojsBqQJ3Q3XqERSgUZb0L1b7MoMmKd+rutUFqAeAkmN04OAH6O6ErVRcNTPoCAHFNfnLSwz8fEVxcD/WMIUDJVFbFV5SXozCVkfZ0QQ2X8vVIHIon22FcitnvLK7FTlWWs9tNv7SBn3dRJ0xhLGQ9C0TLSacvIGweYFue8GU4boXu3K1YFj9bcwZy2Aphal2Zb+fR9t9ETZgGQv1z1rwyFJk6c919e/3b7Ga6Gi0tQogl+X9ifsqcYC84lRBylZ37mnoh4kQmVrRQnqulfuu8C9iPNB+6i4EkwCmprYFZhniqk0EEhUQTYqCtpAajCBl9TcHbTeWiDzLViG5dQkghL+s+UxG58xtJNd2xL/3bG+cRtZNKilaMAWeJYhru+N8PewLBMM/179eqTXrfDg8gXgJ2OaSJAFZ24Je+D0+jvIoBTsUPWxtdBqjswt2M1zQ3e6g6ZhNbJXv7ic93+OZrM6EP6LrWWOxxCdsXFBeBb8PTFlCgc1PBheolgxbXhBGzc3Ar78KVjcoCi3edQHlmKa4QivqzAJRRI9xfZx7jz4wspRjjMf/VFPAr/au4GKy8yV2qcrbSGAr1HehqlU/m2u9ZFAG839gP4PvJwb1EhNAr8GFq0jo2h4r0tQ6DXkZRwIskw6zlJ8SqQx97K+d2izWgCCzXWCJGJ+9JWWNCOHEYa4OEcOqdLhcb4IWTNiZPXOar1ScSvWCizKxYTx5s99giwmvRoeyySvQk5RlZwheJlOzbOQcoNZU342BG9LA6t1Zavx51fMcdW0pApsU7x9woxrbuQXT2CVbP9zHwobv1oZUY3IyPRmffNoZSamDfkGTOl7RSHSZgfUp4K6QQpubRJrHdxUlpq5AcdTvTzKdMASRcD3SKRS9l4YK+Jzmb6QrPQd+YHr5G0NDiSt+D5r6GOpsB1JLk06d0wksRAb600k3Gge/SyCiMNyqSE9h0zCiL4+9Y7qOSMASJh6abLJ5k6T7/n5oInywCjGHGmFJDZ2qrNqcpNjCoyP2PDct4xyMQDbjVtcEu+aMD3K863VdUi2vdS3CixXKMP5f0uYRV0BNGaI25G+4gRCjN3TAqBwvflT/vSxauTjvTSwtR+WgIyVQUEA7UjDWrODRFIykefrWh6ix/9gOk4+2SX3GpO1ZDx3Yg3cp49aamxT1QiGcCGHeMIVTZzfwZGXIEdTZXtCwJXfF/UMgCGm5MIKdWmVcSzHza9xtn/LkC20EHFOtHefaJdJQRHCrke1Tyfh/Lmt+DYa1/SWFaoOOsj7UDE0vES03kDjT3NQS4Zr+nW/Pk3EMmGnAMLixjetNCyJ5QXSPpY+dXpfUHGwzCBz/JqAT+yjxHSDblj5ZnRhsPu5pz/Vpf1Pg3BOcvjBMfdKY4y7RaLYuKryOLIPD5erbxIAD2CN1Wj90CZF458B2Xp6pGrWPVrw3MvGON2CzR0kkMD/LfdRpuMf/GXpMD9fhsNl8RQv6SNDC/GmrxETrpXAJ6Ub1aQpugzUak2Ayb1Zd+sfa/1YL75JqgXe8mdH7vmVPS8g540UEFpPg9D8qZgysHzciKT/zgsPhtSNpP1UuUfPbiaZQOrkn+MpLsKTy1lAr90AZPm4E1OmKP0ffqdW0LtyH1truovDbqE2hQiIRA49j+ZUK/+wV/CuHuW874K9pUWjhImelOIpsZjqr45SV4RQPDM2JeptRQxzr0i7RYkurHgyjX6iPlvIrd7f8iDRVjBBIgUBa9BY0SJVxHw99lE670ipL/pQ3qESFOCU0jbZ+t3pW0ja1nKSRQTIWKteUTb2Dp3hG99AUwW65AV9lg1Ej+eiOB1jgJ9g9BIzkmOhdfOevq/uLXux7MiK+AIdriFWYnOXKDnF4iBavWkAFmiE9Rtw7teOLxorSp+q4bzwy2Dx0LQhAf6RvlzyqXRjLOpaaCHf9ZHi/kxIzadUVaAqiAcu3ZVOq1DaOqK+Zv3QK6GFYav6yQSeCZ50YgLXUIG6P5hoHFoo8vP63jCKyHA1EwLNwCKIKDtjJNswVxMn2aG8NFTWLz0uueuZIXXqsIQ/iSzk5JpkFfiug/DAcf/YNQbkILvPxOyTiCFPpXaCtPBcFewBbpa8OGoFpbuL3d8U4QproI3yHxSkL+Vzjs7Hzm0FAbNz/JngsRH13IDDYg+6d1gdoZ5sCpOfBEN8BFxdCUrsKQSmXtKeT87W//l/pIPQrsQVIfKJkWX5GS1jPKbZGim/xmoEPxlLgfhShmQ6/PDCbs9N70pKKgXqHT16rR16exhSaCEqGsaRPIR5pldTlXSNJ3Ze+Iq2mEChd5BpATtPO+9AGe13wbQMI+f8cv6ZrtvI331fgyIclhCaHvUrG3K9yYssvRG9J9/fB34EjXDRYNKRPXIl4vW+21dNc4iUq5Y5r8tCHgBMeMFP0mEW+UuP+ceyJDzCA/EFcwJTCGwQZSOFCPKwOoC6tUidpHmvszzTfSqUy5EO73Nld3FjXSDsLNr7TkFb1srvwbGaUqzEIZn6IuABTF+PR6T+Y6aOcysxLU79C4QvI5KmS8NmnCT3/14sQE0QOdui/VrtR1lFUJ66MHCK7DymWA0wQYBdZx4wdU8HBwX3mV2xxX5LJAJWc2Co4KWn1pgJHA0Tj6bpjeRmunGYQmSMRwUuzcNPR4qeKT8m/eenQF933gA6AyQt8kkHvJSErpjgSPfM1LHvHfx+aMIANSRPrIXboLP1o9xahZ7+v30wTC8wUZ0fnvQ9TjrWs9bO3JcLbzZxEraG7v/bN6wVBVE678MEQTG1Htxnzn0uTxc3I2MCW7sdgZNtyzcin2XhRb9I/UkSdXzKjr3xNKqBg2/vohBIifcmNPeYkv//CxZKIRtZoTKrudNw0UKE58beVdC2nsICWBRptF/I6uFMN9MVUEjF/PcAe9fcHhBcYVLyt7+DgvpDfL2WgOxazwRAgBqprLuBA3silbn2Nqh88lNvKyNLUMvEHwtjVftH/LGHVFCoL6q9iFxU/+DfIp8kKX4LuGCwt3sXSH4Zi0UUbCEnX5tI8paRJf4PeHomNjAi3hRxS3ifWAFNAAPeGUM9+cKzBolxQTii/JW3Ptj2EyvqeFY7gFyqKhBVNe0R6eZ7t4EMv2xNz8qRKgGPETYyKCZFWxxDINq5x0x3JC87M++p4OII4PViAmZQMpYJajJNJtWkrP1lEp4ZR5ckJDoKgRQkR0t/l4UxEDzOkHvv2a8YYvMCEBWNu9/uRTsg8goOyvNUVFBwF0SZ7VsouLPvoS+oMHsQvDT2THOWoxOcI3pylleFK4jPl72AyWrJueWxtbalny4S3XLj/bnRU1UDwmP+BpSVYzvhmxHDAxZf0Ww2XA2iLT4Xew5i5hy0/pK1mhxd/eKvBCM9qNolw/1VothKxElvbOhcTP1m7fWTtxrlMCwQTmAq+VGqlD2g+ckDlj4mfaIq1kSquH91D/TYoIYV75SA7YV4ihvoY/pGlinEpfXpwDKzccbTJl5cxQl9nQz+daf3TFUTzLG1zgTe816ZPLRCbwss+aS0BCrenvHnm0EhzkwCO9iNMkz2isDy5I0AmMohkH8crw4wRHRzMzCPxCuJ24M8Zkpw9RUzb71Jz2X0R6qNeq7/7DLEuIiMz9Bz0cPM0lXwk/fF8/q2Bp2CMkdtDpkuAkQk23L8EtWk44gxOfimO61unH9o0Oq2BqzIZmsDSKgco+gT0FyvLVE0yftqYghFMlC4kf7zR1OpUWc3kgoJOA8lyAoVFIM4r+Jgp819ps1IZHYUUDwqCguhlPbIXdd4KPl8m33U/wy/SDClfUknQkj+JPIM8AaODX+U2T1Ijw1E8kIWeGpV5Itr4bStCZNCJ9I2Vs+VlLnQQnZpQ2GMEx/Uebc+DwTcCSiOAyvcFhAhFtWPCz4g2EQvZa+MfswK8BxAFl590nk7TujuU3enZ3C/dK1bEIO9GRXo2jJf8rirsnUdppsGkGsIOPyo0tmoqDvt/ul072mYBx2SgSQa2BcK2FEF3sxQjNLGX+JADFlymNn/zCtakJgv3Z4IkScpfx3D9oVEZzxmkT7Shz+JBc0oPTH71oZeIhGPnd/qgzl2F6JgT+/AZ9s8SskrLix3IUwPfEfgP/pOKrVhj8CK4k+g1CEk2Z5Uiew/Ia5GTW7x7kr7FIta1DfRllLKrf6rwEZ0dnhOqY7pYH8DRieBkxFk6HrklWlGRA7S5946dd7WkooxUxrRKgv4UzxOGCsX01aFBkzZCHaNeE0Iqhh4HL9NRO3NztwLN8oKDySXZLhmZPk4eeyD2B5a65s/+U/Xp4f8SBEaPZDerqJsDql757WDMV4ilk2FnkNolihAxrFlt4KaY/NeuOgxd+lU1RehWH0991s9RT0NX76iuD80yNxK6aRjE3uatDGUWUt98SS5uhPaGKv5Ci5COZt3pJFkFfz/GJLznsZhq85zxB28HbBPL0U2D/6ctPXadf0ZOvn/qraH1rjNM9O7pfIM87l8drLGrX3NXw8UvaSyc6FCZmU2s8F9npH8xw8ZvI3xKCeSvAgQAfcei5dN7VlvTp1QV7PkQFn0l43AW4+O12zzFkJA3DQBUTbg+JUUglqJm7mvq+gJ3/vIU66rbTpKQbHVUfIvs2ljQODFZ+7e2eQgQzu0pibN+nMs7haWEnLitKY5FvneAApTtMgFrBwmoN2U2z9GwGJazDYT5zVUSntF5thxtM8G8b6XPTrvj90Y6fvRV4UV3yAmfdnjoBRRAE3qaQGbZBHQgbVGc1Ft8cogJ3smWd9kAJU1doVpkjPlmGL35HDlnniW4T74sNu105PyDoBKfnCh647lwjtH5znLLAkvyBjHPLIEh9W6y4sBs2BjfH8em5MpSAZCnMNKWE7szk9PXKxDOo4Soc4mP35Z2+vtEN9y/JhJtWL478UNHVehDWiTtbaAarptfNSNjA9z7c/4cHxIQ9p1AlTfWlpRa/OzeyjvVcqtVbPEvnOXVQqSp3aVg/BXwxrBDrbHX0orfx9WPq18zRM+/4BJGyks4Qo/FG3+pacyVa+jIpPT8EefTkLOb3EKosTXbHqfzdkscNH8ynDoBXathhbRF1a/+7tqPIFvWi3eIs0GJFcSOVfUKNZ1zyzNIkMqb/F8T2yy+x9KMMxiEotAKiRbE60shETWBDi8FGtcQRCdxn4lbv+jkfxjgE88fotIXbpMsmdUaVzMElTTRgDVeyZmLKFYA16HyqTLekFahBUibEx/d6oFJm6oxRTv85PSUsBNf9r4PVutPn7E2HhNZy7M3bpVqmwokU//Ubfwwe9Zs7o87VYMs2okO3CpRv5/PyTXaZ4ZhO++10/A6BGcoAZYU1+NWNK1YCNQnN2E+R0YKRid6HY32CQNZoO6I2NfSXmFnAuPbDzW2o3MxHHuTXYhzOFUa1Bb1SZRd+MTVp1jYNKEk9Z1YClKX4ndcIAdzNAL1/ACCny19NqJlOALpACQk2PIB3IB6luYsdcjwyZ7U+useAifgtJnztEGcJKpf2r73wtjRzxCPH4UlY5BG6lG/MAbRQI+S3qCKvJqTBIFn1H1NVDylLZjbItQ7PxC5A77gZornfSzlaOC3quldna8ZqRxIaVVm7g2NHKjfMkSltmfQ5hynRx8dTSFxdEBGp5b4iOjTjbuoTme8oU/wicQ9J0Hdf2HcE/1KljcTfxb9nlqflN/bDst+piolHa3IjcbLnVO7hZyyYuew7HKPkJOJi2bhLLmtTYo437/S2fjwvLfEiMPo/hUDet3atwN7rzYxy+zYUgXvtZ3FaEu0u3qNvW4xKz8dDvKaaHsibQc16m8a6BZY1rfD9cibqkWclgSbpWk54MvtXqaFpt0fSNiNraOrQ4pnoAmSjpgmknRBSkXnlvfJeodQbHccSOa4BzhxiaCBo1gdyql3OkW2PAKse7f3EO4CRv+LRMcAe/+5TqbShaaYmkRKxRXzIDDwGfk1BsOxP4S8W0ZwVPh0F1Vkhqef0VFSLHkfo9VwsXXTTQmW3cr6DWJY4F20yNSpuY/jNrDFZ5wKk15Y+tTIJWXdNiuzvGEq5ePKO17QoHyfzbGSAzInf4LCEgWwfQ+b/J6mMvZ6qH6oUT1zclYOKF8S3fc1UMrQ8sB2I0PWz2Lgi6+NRnCCgENIjji0l8QJO5peZd/hejdJclfEtIBkvDP9SK81xB7tQBRDQmN6iFN4EGav8Y3+iXL/pbERn00vYjuhzr4l/GBDhkPWY3DEchvwepYDKXUmHFGfz/n4QfrouEnB0K2Me7xFDgsN6nVjblLTIK+4UhjAtBl7Eb6Z0S/+xtMR+4IrHkbCKy8M5ZFLrxCJk0cBUaXCfv8J2qDzwamR11XPskqd6FwyhMV/jL9xbfKcfPI43uDb5YHeK0mXx32sH1mRkAM2L8mSnzApBIOCnNEPAQq3J9NjUpungekPeHxipodGWHaluTJc06BogxMxgSyHPuF2jG3BNJLesvL8w1EQnLMDLQppsyEYJmcTJ0vu30tQUPT6sisRQkE0/mExQzO94o0ah2MwVcVcq0BBET4howmBQ6iEyL+N+KSs+NKww8bbJQYy2V4PN+seU8DqSd+/HS99ZYQx/be9BziSq5qXYKBvWw/HJHVPvzuq8XCbmDVec6/g1LMqiq4tSCObmeOjoODl5TGH/tgt7qz6pE1aqoXwdR1gEI8JM2205qCkezeT3IdWDTOTem7HHVbz1mLNDb2yGupU7OacKM13s5cC4Sm6ceEIa5sSRD6Pr9Ki831lW0j+TqhspRehHvXqW2aj4PlLUxi80cDHB16KuO1/gjwigc1OJS5jViQPi4hWn70pmapvvZXrcnPvsOoY3X6w9aGSJ+9LG6sXyRlmXTE5eFetAKwQqQJrKoZ12XA/gxc5zAcN2UFj//z8EAiZ+47F0ucjesI0p/uOabCOC58fH0AP6gcBIg1LjWGjs0m0GL4KehK/GKsvn3aUFE9f0Vk5j4B87ZYS8JJ3znXYU8fP+CG/Trccka/z333f0BQ1Xm4+dfix+mVUYNWhg/spBDgtB2fRQAipJILtoUkCuBYSqBb3afRbbZw/DdFwoBPz16bbyKRbR6WoQahERALAoQJVJBz8VTAaFffyYNS1odcK8jsEA+nNJbC5CAaELADv16S/x1d45H6FlwBWbxKLAUBsqQcVw2xQwZ+kfe5eLkj/LRzVsHM2qxzqLPJ3VAgt0WtpL19rnxS3YOnn27vYB+xdqPUyKXasLUPhP3ppWJefKZc4lZe6mASOlPsjikXRps8wnNu4kcuCGvYVN0fdbt3i2fjh4j4HKReO1kuXqYVI8XerZh6Fn3zIenH9JAVMh+Nj2DkF3G92KmG9Ar9hRQhnR2NroBX1HcTdJT67r5sIuMUcR9TUU4h19zglnTOJfLX/WW3NaqACEFbbvaFAF1+CNBp4+3O7HDPbwgtnsl24mBYJb1nD5+iSSu4l9gQicPqdSnhjgLOpv3oKn+EDVQDrRgaBmmYonFh+kuTUeIk4J9CxIJXSKS1IZ81NMQI4fxZDmP+xDIFjk5FEmTkfB01p0aQLyEWHq7RxZ+OpVDIfXBXjDlZDnLq8XDTOQWG/JQuCvXZTK1yGibOiJKhdJKXNrVg2GB+m/mcMsb3DvLJlL2VH31X4A6hzLHlp2cmbCKRXCWtBJbGzm2icm1Skgu+FfCiDHic70xBsaDWl8y9zNW05l6Xv5bZSfl1fZr+Jc3Y3U9MV7sDR0kBGHll+nknIxAva3Im+/AenaYH+RLdIAM8DEoaqDg0gP7zUCIXlGLjR7YVZ5lk9RFN0cpUkTH3U7XccUigVvrAH1DzK5+gptAmfB1cN9dkkp5I1bWG9xKl7GBinAhqR2vMPhuJfWTiRFP0kfwcxCQEW6VwH1hqyD49tc/iR6TFQUBCSSaIdeobdMNDG2FPtgK6htQC847B31NG3Juo/dItiUlSahFT/oM+/zLyEK8UW/VnoiBTiaJxYG0W98W8fVH44ie6R2/jcf+NktyZ3qjw50O52hhWdKLpqYpqCLZWE2Mqf/2YZPi5A92HlobxB0HkWjxIIRsYVV5a0r5FZqp6jH6wZuwlGav81sMIa2gpan1Prj5WcuosdEOBdGoPxXrkZyoYnjEvaToFbd3qU8tLIwkrDW9JLl66H07ioL2IVjBiI2MiD1jtynrKeQmKwarswYRWTA2iPI16IZLlxR4hh0MfpmHJCN6Jkv05wGCjJd7GPRPTNbS0cTceYQ4z81p5Zzq8MBIIq77aYEnEnwDlu+05G9snwFFN/N6N2kG1QCRCEw7tCH1Ml5b7T7GKB78hdzxkMxGoXSkj8DdtFdkCF1degN8wkY+Yclj7qPIlm2AAowNwlUQ6kO/Gr06KqEcAGb50Hvxpj6dvPGfaSJfeG4B9lP4UcpRox8GnenZOhF21eEK6vrNMLWSdzWKCLRbuQcRwkuib4qe1Cz55vv1ik1ieF5gox+RvqfuZXMR/f0JuAvuLFmtvHkVEswAQPk3sKm2azCpnNTe0GbeHFUq1ZjYxDO4qlroiW9ns0SjXRAVuVu63YHtCY2QlxiB4Zc572dmBlYjReiobAtD0umQAIIPHprPjYh4VOidHzOAYz6BeVi7rx57HHH0oQ9QIdtshn3yPknzN12nIhCQAPyXvYQhfsBCf2zKyrmC0QNSiOHQoaMs1VPP3JJDu7Wh1OBYe0K/7m0EwMosCjlGlh1sAWcojIgw5MaOx17MaXGmki+uTWuv/ux5us5czXk0XxuyC4rIMxX5Df8AtiA7l+ztiiLkDd807spJT7clL4m1AeVY2hI/i2Mr8sbjD8SHYDuk6qGn+VKnefztzITmSz5C+MVAzCZc9xYriNrKEJN7L6WeIOeqqfB6tYJ6sGmnwvu7JrnEsgn2KSKuvgYmokZ2nT03NcE4gCX64aFbCZtfswAVjV/ds0KCeXq5mrcnXcfOOTqv/glHU/ZV4G+3VZ3dAszUw/4n4lIoYr97D3xbeMm3FzXElGC81D1eVdbv2XQfnch/isAWaIHyZEZ7XWpL1VTEpg0w41U/2SXPlg1yIOWrNhNBiXFXMDbsBx8T98rLI3JuYdXrV8vE+uYSpE+E5Fmorv+LkkxSy23C7xDzV1XWTAGnTOBENNBzmvKu9v0sWVQuNdrVr4CZNW7TJ8cSHIhX4f44w1yxC+iszZnWHMpTpFTSFnbJddKHtC8ym1WT9YzcjpBrTQ/0gPSCXKAWAy13G8+TwUTZJw4OJ0LQSkn1dg1+EVHu+0qeb6Nvyw2TkJr8pnYzviK612t372xBEykHIsH+U7G4DlmP1a7RFjNDeRp5WmWBdCUhGQGNKCjLwwcDXwWVsjMcVtlUKG+v1rJr2fX6CEudN9JNmkk0Af1PpviefRD8ldg+Nfve4XA0JcUfr0axsg71wsX6y6A9cUrz5JNHCpFGyHLhN+vy5lnj+UJPbydukek3Nspqa/0Bl/KN7PgxJXioW1F9h31J3IZeNB2EwjbhVzd8waGW5bPtoxD3r1/x9WVdI4/E6tbFUtCmHhNhMLBmQI40n2fisYwEFZcXMmJsInMCrw6kYSqj3GhQ+7ITRFgJuh5vNy/ziKe1/72ec5q1yGFPyk8HeyZmKfGG0CmglSz1gRgahXa0Pdj42x6ZL4e7iCszvmfUwuWubUl6cNoSYYo0W9Pv1QgNYL6Bt50+3O2BTg9Hyv6wuW5Ec34/OTehTQ1QHB31XJnFz9+v/bYRox3kgXlO+Gja/fIu6ZdrsXzGZPagcgTK6xKQb8ANd0qKWH4+/G5wzLr9wzVSzuQiEcWx7jzhP4isWutGWkHcZB6dgTRlufVW9W5zzR1wEwgR0W+xE8OwHYg3dcQlWalE5oP7qlkAskYTE+NaJGDDkj0jBuvZ+NjXJNXA29TmzQVdDPdo2Ox6gC5OHc7nmcAcR5+eWn1G6jcGegDMEf9bPR23fhK/5PoNyp9vTPETbHmL7ddWY5Hx4cwNT4CSHTwD0g7w5rDV071NFIiv2pF0Gse9M19BYAS8PjqyoByj424Slc7Q8RFcBi9AoOKfe29fHCb9M45pIXZcnsFiOfTAy3st1LHXYyJo2vvtPwIT/sEqP4RwiE4llf6ifgJCo0g2ARexsA43AGrG4qPcYG4AIMUrzt+5nAFZ8bibPmPqBUID3pHRVEyq5iWYmJ7fWA8aPUoQPiurwRyhIikRDuIqclkz4HFfgqHYjBTha6RbsvhF2d0mvEx189ieQaX/7E0U6MNRDxbFTbP1KlNyH70R3/xIt5/hkEemNyKfLWOrgyTxqzjXfa648utjsexOoDb1wqyvXGkwlUGVUqEEkS4hJuxWYSc26+x5RYNH6bQqGrza3XnM7NkiUmImlHFis8zD5P+Stfbm323E1jpShgJvTl9T5zMsrt6ej2IgM4REQPg+0388n21ePXClwWkCj6xdaOU6Xl/4jYmRaGyUvLN4yfTDJd8ICDjJD/7abXJvIsuvkRbGIONZDeKPf5gz2yuyv3rJMGiaF0fNijA51fwyEylXsygyNCYZXFGtMmesRKADukhUeTB83CEuJKoQR7nbZbugSeC95L2K5SX8QIg17jD+GN1u4itsHNyK8PD0qhAv2dOEvzfefCeZiGLdTXtEg0sDi7WTVDHOMS6n84zFdzpTkNCo5AbREbptougbp6XaHCNNhAbKYUrCZ5EJi9IC/4I/uAXEZ/WuW3vuaPY28Bx3CM0pQrZQ66i1CNMoukVe+CcaAw39AY207xYX1oML4S6ASo76kvmoRii8L8pNjs/XIdd4JoBCuNxqhMiZ4Lbfz+Nwm7VlKRLVsK06LPP9Ti5Fduwpu3Fk+7dn/GrPHlWB8cPyyNwb8grM3i5Etb0ZhUjo1UvApkak2vWdxnp5UDfADcazlxCoMOh4t0xEgvdlSYUJkrkeoyitQRl9k/hlq3mi2PqOmiuGa8B0OCWFbEhIIS/7LORCIZJqRsauGntNtFFycKKhQeR0jusnipngmhFJb3t/0sV7CXyP9wYOz/zfCEQemGi3MGksB1mEFlF7SNBpjmv/egiE+FhD9TTw5hS/yDTkbYPKxmvoSdlkzlY43B8rx26AJP+ojl2AXVBXs6pQqkAYxiFLp0+y7UvkdNMGASOX83vtsEWrHchYfKLC2BtTtCCia0HmBNNq5VQHaLmExCYLLWC/oZQ1VwUFWR9lWs6CH0WPaL2R5Q/iIqe8AOTIRHvB/ZvzduKVzdZViYyozIz7yT1jT2SaPEZTDm0RyypO+a+fumQ0cHVyfFS6CWC3ShslzYlwqynibEjl1MvpN/Q0xAZofOxUglIjoOGB5Qj3KtKLz+XGF4NcYw5uyU01E+QMiGr5jI0LqVP5ONtSQBwBSxjosmAiqp9nefkROY8j1C8EvUM+dbo+Z2h8UXo31SwH+xh0aqJL3196vChqKDzPF+kzgC5X0DY9u0wM70uIyj71uReAt7TXnwX2voC7I+PGhm8ft41iRQVSsa4CMh42+LqEmTq8OFqg1s7JdBf/Jv3xxhu01ggUWe5GtFgL3OoXRyhzbD7qiCc9HFKNkQuoXF3BG0nckli1gYneWt22bO/pEfQs7qfV8MaZjcq+WmJ+spoSUO/NhNqM4au5p4ljRtsU5oZjK3olW9tjnJTNRlqac6poRr1MoH0U+gW9d8ZMXrALs67d/MdoDWvrtbib9hjMWPoyYXcZQHOto75dQwUFLFkGVxJjoBXX+7chax4UcyqfV65RXjdy9lLuEmo6Q0ImXTUA+fjFhZzKVQ83F85tHnuiJ5hmKVRhLDkcqzQNb0pxHdS14au5wDiluQlEAnGX1MlMXTUAPCka1V+jBElPIQ4Rg1LUlphBKB4aAeuTLc6zsONR2ocPp6MKPExArGoPxC+BLINpIkv95uqLo1fhB52GbvT97vEaeYeXteZESb0yYa34TcbjY7inJ0+ykT4gpa/PDTD1DK7SVRf16NyvJyyvgi/CYM63V4N9flAtedG2ntbPewnYpCkVWbQaXJ7SwdLIH+PEDpl83DN0g2BCRWiX5XZbSwZo0W37004C8jxGboeQOFt7bed2n4EVBTIkS12AXRY8GuIo6/PuNRNb5Sccp6uBmwRaLWBME7hlWFVk1k92v8euMDcS/WmR5TMc1K77p+zdOYh+LmU02Yh1kFy+AOtrBzHJ4eTkKtXzoNqdDOdPCp9py+IeLwcvIR3Qj9nrDQRTDvJTpfyvQa2djxijISQ1zliuQigGGg+hRR5Plep/dQbzVdLcZPi5v7bwKS0CIPP8mk1P1CwtQJ1QP+q1rSdehNInw4L+M0AIYKHqf1edwstMB4mliaRImPQzP+uQEdEL/SX9H32DNGLioh9vUiKbqNDMo1iQ/o+wjm4i8i67xkKU7lUnJWS4sMxOvsdQsuofFpvlBcHg67gr+sRsyKHnbLdpVRdEZXQM7bTltQGFzpqz/Rc9I719uE2uglIrbLsBujzkgoPl59Oo8zx3TNLVp0rj35T0hVDkwR1IcudDwljT2zAP7DFpou0Zm+DYVcDYZTW2NgxB8WF70E35OC0trGbmZ965dO+f3xGrP/xgx9CG+2Wn6wz2iUZihQTczBQnEx+BBsj5hbtzYd6ZgPmgpRqQY/drCI+B0h2g8252iCG5QUw08L59vwogXP9CMnMEySx96nXCSRBIZnJQjmdsX9/RuaXwCOn8tuz/zY5BXdpMWqwyY4Z5M8+8Ijm6y2zhFfCie3fNg5rNX11L9vE+/mHQrXkXSw6nAzijyZz8Ax3DneqfISh05s69WcZ53AXcb+yIRn4X0VGCtK0114mDDB6sQGu20nDPmY4BEpQbLb/qJfw1ocBjh+bcSMI6gpX2051bvCYSZRgfUjnXHDcT9EJp3ZoEYTGA1jbLAaFLTcgGUb2I8e8Dp0uZ1ZCxwbSMye/q4z1Vhl9QM8HM4NRtg+jeld+Dm5EScWN5kJbteJ2Hr9jKxtDw+nGzda+nD1in8CGQsy2Si9ieplldOrd5LyDRqyao8iT3YOa4PbRg3ZHbZxS4zbICb/EFZlVljd+5B1J47sYLXL5nNON2y3PL59JrdjRvteLohGE1cEamMx5x5RHgFzJxdACQi/dwRJlZ52MERvakk4E1Omd6x9T9RQMCXWxmOqHPDgHC8UaBLprE8qgLszTMTvz/EiF4zVlrKkYlxkUzYv7HcXoC/+GhYukP9ugNh1NtWAFVGdfxLEgjR44pRGgArifFCndVZ1Q69q9W/Rqt2H+oj3oFfNDCJmCBFZJCPDXzecTTmbw3BBubFZQCuwV2RQRE2tMRsraSoxeUt0JSCVAt3Rk32Y9/HLZDD2mVl9jBayKOXJSWJ27H/xAvJ+vwIuk8FEqdeI1srcRV0TW3/ZH+9bnMWXiQTOhIbwJdLLCO+b2Lv8BZBT6KUOC4L2TPHbMqO/x2plJR7082ZMNnk4yBFo+wttRRpVJ9KsSNSeo2ZuUi8AOYQbhrbR04IcZKJIGgyXwMpKnX/mTa+iNOHXkrhGGN4tw6lL/13ty+5mPXGz0YU+Sp6ckP+v0LIjifYCU/6qIpBht5ybEBLKHcFu8GOvLeYedBJI0W/6jvMtHDt8wzB5KhikpRi4tday8cfG4dbNoa949ZcfXUvIJph1NcJquNEiDWU/143RlchYe2HXBTormvHGBoFOCc9bBYqZAGx6MDCSAJPtOgSKPo1D1hx0cXGjjbbC08i8jo6kxtvF4wqlyQwqWevVDbxJ/iTTFYc/tfyp8SKUjUhvuJyxqQUYNM6vdkvgTcv1RIQ9rzthjG2ljjQvo4P6MQCUl+tX4J0UH2spyS/76KOc9V1BxMo34FxQgNo2Ljej/fcg9Iwfay1CyEHQXzEi8KYXuOJ8L6dUN1PR4K5fpxNSEfUNqlqBsKSTKDdnh387zMjKlo0IXxrvgTHpSSVSmHCZOYq1kP1Ak12cv97gfGxhOZD0SfF7JjWkHvi/li+EhhAJsrivZUo/UJI8e8Zv+AiypEfGD7Y809ObaBTK0AtEPYsScaa3JwuTj/20puWsHTxjKYPWvDPJGim+wYOVZ4fZR2glT0MZ2sADXCMVVgU78rZLIMERy7SWDLp+MnRaGD4RbaZtfnjDCc4ibDkXCH1BbOrIHEAgMOB2zy1PYPXIpTcpLgpeM6/kBHKLG/t9at/229DjwTkrw9whYhaK+x2DXJBHiS5WtWM7FJqXoPw1hYnjyJFjtVxaNVbBorD/kZDDHmHm6IN+wDbrL5N2Nl02v7tMToyexdBjtid4swKAMWQ1y1UoY8wwsj8IcYXVBVYpvZqaYw9llZtJNvOFftJPlTDHxi2KZKCGv37YARklX54sUFoLqkAI975bsuYcrGcDhg2ucps1rqH1sEa0oCouMT0VabUN3yDd56QW0/xxr90+1zySxOGuOHx/fKI85XrwMyLJb1ewIPZExQA3uwrk7LUex1BuNB+4/y8x4592Cv93WKDmmswghe478bKhxqmlwQGjwap3xJnsgcqzx53KNCYQC53F/HlcfnphG7WqSPE7D3y4ve6Ovw4wGtebGL1Zb68zdgUnvuTRIIOMJoqt4uQYR+1KUHbGigry34o9/z43mDHB9XFQw8lEUh25QdY0EZoMDGMBg2DFev+Ik2o3H/eQC4vonIXI6A2xt2LzDoBSPV3OZ4GGLypzeqv9+rc92aIAZtixPcVVoO+tdeQwG/oKIM+5KgEACDFp8j/LZs6QkT6K3M48DJNj+d2Lo8bte/f10cWXUcbwi+3PlM+YTZrkCq7CzKYXd7dryKI4+xA6jwb4c8/LQWyP+EUw+7dVfyo1rAhtYQVfHp56kdBvkZNddRu/92KoR80eHDPPO+j4o0cvyarSZ4UjUtmEWlzTRJ7TW3ieQ3xyDqGUtm4OWEA2c/GsvpOcAitSeQPJJAtBXq4gh+FcQI/5xOm/IyLpJDCzkkCJM4/4FmSoqbCw4Ae3MCWXxqzCsxLIRLruWLxyPM3rpsqPcKVG3pZ0fFz+vvV//CvicDKtBPHXqc9oeNR/ilduEPiR+LJjIzcJTBGtAZnOcxFQ2kPhMMn4PwJC33LcBTj5Rtkhah2ajOpZUBJAfDf9TpD4ZJeQL8UT2moeSLrRLf4Q9Z0e911uXPJLPsQJHi6tcDk8BeQib78LmvspsLi2+QyvJ03nUkDCnPpgxocsn2m574YLossKnYzjXv7fp5ssa5IENRUdpXdOWq/t3R/HcFm47PQ3zv7tHO62YzUyRENU8/0LoHtgQKyZeSyZNSoyFasbPKnAq1D11c66SS2ikVyMLGQj5/TheuuMY/EHTopIyiC9V8tZa1/huQgIi5KmCWJkZwbTovrnhFDgD9LRfwvXEBLYeif+yDMtwSxLiiz356AWLQMsxDjnwd+2WF4OXrrZgHj6H1wY7kYNbiHf1c6yQETSkjXQNjT8/pkXJs12zlG2KEFMlpOz1kV11+4+6CLllP6sqESGg9C8rio7tOwVPTs7LOeWXztuj+/Ovampf99mq8nXMRQYt+0SM8MIDsmLVGVqII2asfXgKlGaYR3+3pVAMBFICKrzMlgUedthVznzXlErY4Gkty05emMtoNFIJGncPxD1hwQE7phPhip4ag9Jd2ALzGhC6BLSW5QyZfic+ZAf6mLsAArlMX18DrBsclNqirkXgUi/I9cUd4PdVruzJshmxl6STFVk5jtiOrrFLeaoHQYtVFyicd4Pdzk08PfjNsaGsMgYd1jzq6zXHTkCNFlBg31RV4yL0gntOlIJmBKvpijWzs4mye0aDjJIwyJ7LzYKko/lEuraRZod3N6cUdNJnA7v/rl9jGzv5b1XyJHHT8XmA/dV2izloE20i/GLVH+D1nUvxX3N8usSD1A+6BtSlZ4KYe2GmyhzQ/P9oG+53k7nY3t8mIcz6hC8XCrYCbmCUH1doWl9JBhdSfW7yFONAnHYQaxsoOTPGl1JNkOEcoe88mvwZCEBu9nerfbPl+v7gEAzrsXzhhIfHeZirLSbR6Ra1BVPKE81MLCgncNlisDlfxTrJXTCR6Fm0eUDfeXDy43c5nfOGQ6tHJEssHwxbgS/X6wAr/jDWoKxpP9gEeZLeutESrKRs0s+yOg5pSQayiPfxr/CjxBcAG4SGIDCiO69ewZP1r55ZIGpJzVT3CGG8Vnyf+qC1TwYr07dJX6IEAbOwf4O7C84M8IofCiSMa3NwxSKi3UU8o7KjgMPI44lM7jN327C3DXaMtXev5fbu6mdJlulWWU3VoguaaeJgdzMSOwgIe3A2N6KSZxhYfSFObD3R7gy1vgU/S4Bx9cEl2aCvYKQ768MUkqhJYszgdcN2BYsW09bTqjwCi/Q1i32L2QZBz2ojLEaX19caEvsh96WoqbFJYZtIdjTWcsCTe6Nt4cRq3UIgSHk8jUOsNRLL6IIIEXzT6L3Ugjjo9OvZILGQqmcEJAi5Nwu8L2iDVMcJZ+5FkL3gWCF+AOVtZP9QoScITMcF1RpUkdT3/z401+OO5ZzQINKwOtzBfKvcxRXA4RiaFohaj4o9EhVVJBif9Es2LUJTsBXSjl3Ql8adjt+hsyAQt8dgBQOrB1Q58DTJTFDr89jx20TerSexQGeLWlWEHuHfaavQueWw5GIaq2rdLxI9TVFlw4oEDFTSp/dGLwFTQJgZvEwx4Si0W4ZT8pcHZqT2sbN0vk+k4bmUiTciAt5xzLtyj9AlkfbchGL2jd/yALOrVW+o1LDEJHXxNyIu/hrAPX8i1+YhD00vZ9NgKOytRa05UTeThqu/fxiO+wArlEK5SFrY+DZVO6WHHwVDgllMr4Ty8M2rDpXcINpgDWl4ZyydK1JpAgps9ny2OpUhuwy31qMB3+amUPK9w73RErZMpccr9PWj1JWYiDyryEcb4k+7kJwGCd8QhOlaEv50eghgUSgTyOFtvH6SJCmYJ2m4Laj6krkopgtDup2fcuUoDan3K5ce6kACFRkc+9qLgbyUY7zorXRd7yCz/9iH3oYFyH3LgW23CaUiqkVxXT89eYSJAPH+JsfnJN9tbhl46Ygf9RLYQehv2EFp8qbaZgrTanDV+fJP/TRQQ/wFxv0Lr0EQ4prkXyx9vyQN3VHXl+2eWSusL+Mx8ZHK9VkZqxnqQyKmvHTAu+ym9iwrXJT518JqdRDYag8br9ohirKoDqvnKK5mcoJ+mqUj533PvQ6N2cAEcqILyD8+8Y9c54uEOUaBUMO849UqbfAiWXya3OclT91o78QGSy+sZRU2ayKJmJt98tVSJT2m047hyUIoyWC0m5CBsN5WWFM8+uts6RqXRcNrQEjrMuO72jodv46DKLX+O3yD1RUOWXE76MSoo5xEFp81H7jzrNZjW0SHuas90TitL4uCUSEznj5iMxgFyJwSVaCagXQLWx5EDIGoezdzu5YDpGrpboAkkcIaCMJrmdClbVyroCNSmDFwZz2ssTaYtHW8QDv26ksCbmMojSOYjeFz4tlUh7oQaeUe99vadshbUjSptHWigjV4WDOmqpDLoG4d6chLGbhEU0EFXxPfqm0LdEY9mPP2JOaVOrQgZ6M2M2rgciMPi++DMxH8I9zAit5KC7v2EwwOfilro8zle620DrC3edPT1+aci+zDatxQCKhjfsArDEjjh0+glUdj75WYvaKGnWmCyZOdri841/I0jlSx9qhtDJYhepcPwPtBn3kKufoXcoKmH5sEq1czFWTjTzyMRHZ0lUnLMVokCHZTnCpvTXPcmv3QFVyO/gEMrrW3Fo0l3dnPW7506ZwVLqJOTvcc48Nrz+JalKGJ6IsBbPE/JGb3leNJI+l64TcT/xTViZaebZ/uvrhSozZcGc9eoZGB3r1BbWXy9bt4VjY8R3aLFDjveWE0nzUMKKzgBJUHzVnVtuwKKx3aakqiCdn1UjuXyqpJvFkUdYGBdryYvHE/CLfK34Ow7M/nrrvt4Q9DZtBYu9b2zES6BDU6USYNt6ZpuPh7ryw/1aOOYk1wth605+IVzcZux8lRqQgG2/hQIFX6n85qKe3XiVFOdnT/UdpWFBezo6bid663k+AiAZxfD3ZnAboZvrdpvEwGkCGqOyVCRut+NC/O4QHRkWQDmS5WQ0qHtPanf/+KJj+Ad0rkLSwyxj8faGI0vtjqXuGK8dlPdc+YskjcwwmQlXQaIKTzJZ2U2IDouQCl4rGMT4KArs/S0hTpUaZ0i12Ijz4Tm5XWINNf+HIhLdHRJtLBxnPCquEb1k0Fjp3WWhx8YRR/UQTEQsXeoPmVxOGHksl697RgdtYWZZAy6F4KN8iT/upmmGJWH1S1QSbP+yhabTDAfXre20cgOcRgVZ3dyWfi50E++xQxPvHrh42TEvoygc1pEgcoBMgGKRrTvMgJWBI7uBiihK3aXG99nZSaQykM5MFSHkhR5nocEuOuJUQLWjS2p1uuNauzICXEWOaet4xu1PkGxzP4SqqSlzdcF0too77PgTBgT9OP9Afn5CFwRd683oKuSo94H/H1OQtoAbNWHL9GMduiaIIiDUH5BVWB7+qvFUS4X9ZTZ/A/+2zeW+N7xg41fEugBTjHqjq+yIw8fLz5TJBzARYnLK/7g4y9Vu+jTMjU/eRRDIttCaYN7PZGckFVZQuHK/abCn/CL5h0VtbClCyfViic0lMjGqZt1nemk+DQQBc7MaheDzEpO7C43TmdgOcuJJ2GILk/X5VkHjuCFLIxSN3CI3gb1GHMHNF8hoIkznesfUakcXrspoPHB06hsmZMlFHjJRA2tLhJhZ7okPhTyasL7ITeyJGtLr68GRl7KfgMhvgGdAA9weIaqW/0eNgxWCZE5JqQnCSvV/HjrVTr01YnI5xGOJ0P1eVtZsOleZITz4IibZIrHCIYe9iIFZAittmfHuUBdz/sfo5DKs9GzfVd/cwNxwTn1OuZ2BmhDKLDUOXxhNl6FX9MaA5bQRMssF28rNNzeKxqBGX+RSKs5c7Iwfm0RA32vMxzCU6tmSjYCa1LFuj4ZE1a6HdNMdVMsaQ0CZ2pxYhkN0UClbv/HxGPWFRi/MRln4UZrvQSz5QwqC4B9szF0ccHpWCPw5YBf+Wrw1z2y4syns3ZeuUfOPWMFejTyJVxiD7noY2lGbA6VHKLPw5wqf0mpoCg4HJRjxgsJdFJP0ibwQCxkPasHK7dFY1P9wvlpISFoYnjUWXyDYAc8q3ZWcg71ms2iumj0pl7pF33w7laT9M2h2tleaLiOX6Tv4T8km3RC2zgNXClBxW91l1GoLOErR2oadmG0+D95dzRe4cU2DUvihaSFUP5UwynYE6hoyq844PV+cavuL223MtWWnYnMUC0W5iqylcdlX2p6pi+eUWGLp13XlCu3hYvHHsdEOxIvQXW0SG9vk0feDjwRHQe+a4VJ22msHAZHqm+uhnQp/lZy9uuy5tzW8qZSIBpvh10jSaoUKPvjCOUWjALCyloUt1Po3f1/sKGCOnfj8/W8ljo1vtogMhSVi3jh9hkWSZhB7XDvJO5XPcuAyYr8H3qs+I+e0AtsZ970TuEN3gZ8scTVQCAg8unF4HQ0VsENubcNSydZ9DR6TkOzOBW1dzBfB0gndT5XyHkrSFDD8ylMi2ELXJZx85rK0mUM5lDF/mUDXIFluhodtc5fcusDqB9nYyoG2YM1Agtg3Qg9oo4oJR+CmKcuK7vlqUSjDwvShZcuD8azTjjsOK8XtbznR49kv1Gv0cjIUfNmDBHPNByqfEEpXgO38R4gqW8rjvBZJAFJO9HBF8UBcLCZh2MKKcsTsbUHOZbVr9ThWpyBQurh8gyClaJLSCboO/62fHHW+W8m2x310iYw+iG/6KX4qB37C6B3Mz49mwRir7L2dqR+6I0Fr0nxbdVTrn3dbPxA2AjzlSU1qZkkgyVJDW+iM/9i9TPI+b3CumJxX2tcjc9zJdqJXhHxRAccnUECnB0cDN+3Ry9Ri7TXfMHaKV35XNTosLCWbvHSI4cTDc8pbiLSEc1b3MQaDiLqd357drtd2qsDH4LOe9RMjZz9jdib5GavYgYsHE/ruK9rlxjtY5e1Lt85MAdvKFYjWxKbKkVtmagTP/wozykWFgIU00AyIrAo2a2tAvFW+FXOtL48ASOEzz3Gv5CEFl7JRr5lzYNOcuJUNMmTfpWSE2EOjSc+VF/BXF5RX1BXAcO6by+JHdN5m50n5hcGx9wv+0IIW6St6cpZJYu2bM8fPLIDCATn0IYIb5aFtHgJg/2m+RCCYGHxPInBcfl5ZLGLI8wkew028mYf9nLsGIGOF2YIbPZQTXosX8H3GhV6bL0CyUAZkGs2nG1dPystbNc51pIv9HRtRObiM3iOMRWLN9fC+YMespHT57V1/XCiEEvwzcd6Uf6RSLMDFzugOEvSFHKwAqPfWXuo36bbn/wJlZr3dUbnB5xlCOjKpLrHvsSX16ANgCmaJJI8Tdb5CWiltUYFaqH9IXRHPWK0cGvAHpGedWvZSqfUJCwNcIr7KkmogsVCyuoA6524bksYS0cl9V/Q+A8WlR+BT0rxJCJzodY3JIoSLBJYctQgFXIntRjQxF2sckGFdZ6HmkVjKYi4/q6QMHowipa5VQ3MmMpR3BhFiqEmiFY0OR/YXH8HRd3t7ErDhPBjAiDvAPluJJtD3yFhdJNc6IjZhxCTQCcp6WpctV+OVE9AXUqZn/XXkFQzWf6G+BAhTPTrLfofxAgy8YBSVCzZIsAw0rmtU/+mkIcHGxqH1jr3ibZagl8BiMwlQ8z35zZvMFwL/QyQ7P4ScNzM5mTNHcROtU57MnHGvhgXNwP4suORaePAyFZ75V0zTby+8FxNIRJNwgl0x7EXwElMB8BvcxNCiY1VDpddXI7xTY/G7EYUDPdH026jJ+lhkxt1u6X4jqgu9ZrMD2Ybr7vbQrfitb2tONzmJPVuGKEzlj5iuAT0mH/Q1r4hwDRkWSFyKTGkgknXGb9q3uRpfxVbwfh9GIF+MNL/mM7vlmS7vBI8eWBIwbCRrIbfgZdoy3DmGrc+2gmGJO6Gx3Uk9v7jJj/hy+efsvSLcj6c/JApu3Lf7JhgtORr5DfmD+Mk09+84y/9+WLkhBu0mmX2i/PjaEJK10ibMzjQWVE6fVqgLHtJpviK7DNBYJ7PRKSpQ09vVRJ6AsaXI+B7W1DzvkSARfc68BGqaZNZqpOkCwsvPgrDLMu3wbQfKvJpJ3aBJyE3doiOEH4QZXPxqvMwixhmMcT5KJRB/QmvDcBW6E3t8dfAw15FPQjhbACLFQmL7gY9HLdpNBi9xrNvkgM9YsKZ++HEYgSFuHwZWgkn4ON3YPJNGLxBNI7BNw2mhTFuRirF2cgHT24rU+V3yzB4eLiUht3a0ivs5jgLDheju6HhEOiPcLEjMbJ3hTc+C+Np+A8ufsYUahcrJcLKL3FgGC4Qr71WpUgcpOIE7m0xNrVXBuCVjU2LRaRY1flqKfhBATLP9gcA09LjMAZE298MHTxDOQ9m0qGW7vOyIiqkMu6UZEy26e3Aewmw9ReQsa4GppQ6QpdUGU+ytAleYsdto28lZsc4eqd9kRDFwx9B3prfZ4itT3fAaxfLsTa2Q2zHLRe93DBh7A6pw4mMeKckpsKRy53LfVyvq11R1kf8KPwZoDyRBH5Eq7s0BlDGHE1wBux7yDYuCAWf2Q1+3TR78UXCAJTlf7Fs2eS/brk1ZSZrpw+tY+I3pB/1D8TflgvE/cmwsazJz+jEu0Oxge6aH4RQzRwrpfc5hquZhM8tGCdCVIjNPTpyEZNW+isgrUUd5MOoO2PBPBYhpR38tGqae2vV9LeytxmmTU9KR7GiTcxOpVnKtm34lecpt3KweEGXqgKnhrl+bmGteBUjgBlQNVymjunacqtSwiSOZ0O03MFL2CvcM0qhjUPEap743ajy30pskrlaRtrs3knReKbkZMYVq/gyd43de9Kx1eYcU6stTm25yGch1Uis8l6ySwMsKIf5PlX6fxgsGtZzblHuZjERw0u3tvGMFYX+pfTdbegYUstI42YCslBiO4/KBhA484aBXdu0bWZQ7vwG+/HgspDwP0gv3q8xX0UfR14OOe1TscrbP68SaVEA8GUMCwsopzQh8oZKoqxToqVtA4cYpYOzf34NDDLqgVnWsqXtNQgRc5j1S1vADAkanrGXCFDmDGZVg0KeR+qK8TaVvhPHFQRUTcJ6olhrzaq1RXlnMXLDntEK+woXEKdHprHwlzmurXwjmjqile4fkGbEDWNZQHqoTtlG4JNRWHdELjBXg/Z2C6imZ30EeelA6GwuH2oV6XmPhZqTzv/6OqSaS2/rZolUmZpED1l51Q+f/5HAB7xNrfOwwkwfScqU5Eu5YURQBgYfnszyuIewvaHFzw/cmMtuqGEIG7N9UJ+FAUHtMGJnQScn1tGbXAG6dcP/PzWjlkrnB0DxftvdsuA7cW230KETrZjrKxk4X2eby79RkxaCXAr6+kxUyzVXQCYP6gGG3rPFGWWCTxPYOEAp34A7AHyYxBGG7E6AmlPMzUwNNyQhS2GAiivRckiwhXdbc/yHK3M3nT3b7sA9zACHSicd/asoQozhrrMXvp7MMG71YoHyqaQ2mx9qwojspS6YPvrM3kbcq5dKGUhvUHl8I8sgQ6GMuWYMVGSR/Vpcp4W+/Hzll+W8psuGnc9nnAvwcKfI1czQ9myoQV4baPihvvzHBPRAvPY5e4mDmlFndS70N+SvTutXmq6Sr5ryO05yLgaM7xoYxPv/Jc+zMJc/R7iPtYKHZ468ycjwMnfjp3mYEjnZ8N4bCSo3Cvz6iW1UfWp9p4Yl6LYOQoonmUyRW6bfHo0+1ifvGQoYj+uE6GwvcXPykcc3uA62O1Bx7qG9qnLvnVv9slQUjn5w7SY39pzPhkvZWN8F6i7XvAghg+0PwzHVFpbN8Mi3xEZi03Mshz7mE6Evh0A8xZLKdxXLIEdEwQdiAk9rvBroMRSRQqbnyLDcrMm6p7AmHJAGrT+W/civhfPThftZyosKkpHBVvd3jI5sVxropbgc+HN45VhWoJBuevgd+GIl264UaoYzJ6J7DQRhZovg1dkfV13moalfEbGPDkMWXpRKa/GNN0gWTabfptBuR8VSirK++MH02DPLXQwKzXIcPTrMGzcL9VzAKT89biacfuPmUK4k7YcgEaAPc9EFtIbtsTRW8b1d4Ly5Kr2bEf5XOv63TiJojDsK0wnLsb9oFfdQcebZHCaLhCv25JLW77aS29VS4TdRMoQVozL4z8O39JPJWoFRYO2OCKEoVV4W0OBxTH06SCVbC1HZOQLz5LzKgN+SxeZjSYl5YUq4gmjTany1qcchZZgZOPkUpXEjtSbOnpULdfz/iBE6bhztaQ+r6YrpIHORNF9ZIC49Ju7yYAKnP+wlHZVc9TzLmIbs3Jkwv8PFjM4LVlWYsV3dSw531lXS/Bk26kKBwSH9wEr2d2Ry/hNY7mh4IKuV5XEsaZUU70zD31T3W7Fnst3e+xrk5NHz/1eqdurROUTjINzMwF8GD6qeTfuQeeN50jsfSMkFl+ZxpE+rlDSfzioLfhvBtfls6OLz4gNch1//3uj2gM94JD0eWAMPyEvWXzAyir55fLURsjwda6xivXJGkpOMCp9+VLEo8z4TUYbl7U/2llF0ci+W9/aL+l7cJc041Mx7B64ruBB8XezSH/aNy8+wtYGEQnux2ixX+r485ALhCQAYvUd4Dwp92U6j1SZGUPAbRWayTUzwvKKX3BDlqqlQ/LMj0InOIU7ZtHdjnelTvkZbKz7fts0p90BBR5s2Q00dsivrXpe4bmOZjNxP+57wiSgXJ4pAJj5zZxoAJsVSgP5BfDY8LH298Gnk7kmWgPCFY8odeSMmDRBVqHdS4tQbXHucvXaHskdIyOvEbg5n4FLvvGj1sbUM5dVdsebeCAucDt8vf82EZBd5MUCTVC4T3T3an1o8FY7vR0P+9YrZWUzPyHGWc/vii5nWPfPmeA7j3GbclJTKUn8wiwb3nS7r69JNxwnpz+lB3gVE/FiuiN0Iy9u/8Jyx1WlDcC0A6HjGpqb+akkPe0XSXirN2WTreU4+uAB302UC3Ot5MqraPzH7yNQLRvHWy5gU3BamdjkvXU4lczZG4nFMb+nZKvokM17DW7vuyiO0EgSeyODMANs+ilORcTX5UqIo7jkOHcURvqCtEChU9TmsPj+F7cgRHkGObFjuGRE+2Kal/kLAIbd3L20UUds+S3CkUYgtaWb2OvVZNpcCaGqL9T8TQUYybinHTrOWB2yLHh084/0DY2pQkDeTNFJI4mOipE5pPNZlopLGGlCAvdNuHdr+nxYtzem1Smp6WIoaW3KduC8IV0qpylrKe2kT+XtafJUjoVgJoad9xfdWrcMlQ/uKmOPiJfABMIAU5bVDlGdZJ/uYJ62GJ6Ajj9c4uLX5eCZFTFAwO/MkrX+aFNUN7pKrJZrwaaBc0mO8cmYvFumh2uYtszoqQjNrvW7dvHVO5oTx61ZKbBzxp1mqkxOZWh3Rog0r5BvhEacQloS9AzUjdCoj/vPO8KpwR7XOqHVUQqyJQjEEQXlMe/28qkRaTyyCLwmX+uVPkTCqUSb3D1PJnueBJZq29ZqwmMVFjqSgok8/w6RrJEoiVS4DoGAXGtkDonWLYhVFuOnAbaGI12tuWIkILFZcl83JwRk+w04Xi/xT920oETw3WJpq2yzyrJjCLIUypdkWI1zfHiR+/bmJivG67mYgOjhLHo8ziO2o1U7WGl/9aVzbW4YFqNQ1wTci+Zn0MbFSs64GkaUpTp8/QkWSuTajP7Sqcv7aJJjkLfNL9bNrgP1kqwTvPfQdb2JOUUgDso73we0atQ3WCMQxXW2X/aZUk2cJ2a3xz9VRj7kZt0kEs7RHheFHwmCsiNZ68gomTCV/i4JMRkNFWKWISkwh5/FICkBC3XIyOICVi42I92KAWzTnbU8DIWnWwhxFZqN/0NxMwMAwUZRioSDSk2f67pLHGev6DEaaQitwdtxQ5Pl9RVhhGd1b3/n1yEtkEs7n9hajQliyiFNlOp9Uz90cRNQFdYBnRsarHrjfBC/ZTdzcigBclSGvniRZgTX2fpYMcZ10FZGC6A7+j9XmuIm8391tbtOzv3dAxIyvWVpomLZirBoUj346Cji4sQzos/NNOmKl2t7HqiPOR3mCmmZVsUih7rYoZkFONsqx6iTZQZCMkN2AIAMs0gBxBeQi9vPc7zBHe1EzZAge3Bn9O0m7Y69botFcGAfWNImy278iyFO6zRpLqF0IM3bWFO6KVAdijgMMGFt1EDx8FTZbtrcaW+Vz3ZuWT2xIrO9wRWtQcHLLOpvFw+Na4pucZsfCYUvICF8Uu6IKnfE7pkkwSJ7spCVR+vFAix/X2tdSBBT6uWu/THsosK+wfAvSbb6WUCuEDddF/AxOlV6GBGaOW0kzNLPr2bUAPYOwy5DVTDaCjy7qago+RTDEJjHeiQ9O2BUS5QgMXXlOEDyoETwNV0oOhUOswMna2MiL1T5QNx/n09vu0TrVhOSjOGSr/xFOGllHQStEKO6a+CL0wxVDqz5solhwfmcQZ45fgJ6w0qy3e1Fbg4EB/42wkP3L+KfhHrz43vrEmhLCEPcXR8LHi2KUXDni6emxHaLoJEOA2BBK3rtOoIIlJ73+llBsYkkhrmqsf7t0/gYV6+kBUn3nmHZ0oe7a/9dHNONdUV6nsgBtO8nvEo5Z/GIaDTqJbvVYGIjCkH+6VyN+/rAbw2d3+JywDIt2MXTr/pq6XQJti7LHHy/IHM28e8LiqwYV7SKa0l0BIHloVlrBpybnpWCjhsjyufKdrPkS7MfsVPMz/u7gCplEHpFPJErHIqtToXgpnJpeUvbLF8p2VMnpf6eLjOGiK1hGTIwiULGsy5XYKZEUGG7HEeaUA+zjPVZ9um3dAZm1IsRv/2VCJz1jvf+H8gXjDkZ5NR7RJg6WOD4JwaPbVZWSEgw2JGecmJQBPrihDPPfH5wDMSqrGReBvdjORtT55MQYvIZkwcjT6fy9Dr4vQorl283jwOjwpBjlI5mAc31pqoIGszI0uXuHL/DMeOmYtPcR+Zpxz2GjdxGSq5CRU9ZT3yJiaql8BiCWx+07bw/LQ+4C0Z+MQTFYL6JCwyM8QdENtGqNip1Na9PjE8YL7pOG+8Wf1Ur5aBY6nVGdfhEAOslCQe0SuLF9ozoPAyJQNp3fuwjq13OPzUojuJIkbBFYOlUBcq40SGln9wv1/49rx0V18c4GqklR4azMyxbK4SPNWlF5otvdSBKmrWTYrI7cvCeOPbz992wfKEV94C8rGCSXcQ1uMtt/P9Zs1kcEvzz90sTLuSYchSscol9n/2u3ruVUc7PwbQbjbHtmjblcquIGgyTgNjSdbtfpoFpG9cPVPb+n9IxBvE7pT++IL9xMPBBDFH9VpesdZ5y38i+N5k9sumlyw5f8AbVfT3vgOSO7OYWMVD8Ih+ZURfquZqlwH2FSGtcdPu68Xk/x3a8IFJMwILAgzbYIfiBR3laHaIiS4TBMgFYKgCfXl9kW/hM/f/nd6xmeriiM5O+myAYsS6uXYDWZg9ByYVJWEdNe0Nmd14fxJBnE8TlOoKIp5GF9Fe8CwaG3KHOZsEGKm+EUeYJkTGwlprL1CYCVuV7tDlNL/nVdikNLO0qy/SeFOLwlic7tL77uTrNWpeY+uofJWiOnzC5s0iVji5mTvY4L6WuTkC4ArXQBt6DoaRZczznvRr1B+g0Kcvr6G3e3Ji4WMjcMYiQHwLaemVFuqmlMJ7VGR1pqVuYnw7OIt/C15XL7+vCxMPk7fP4lpe2aBzEY68KpuhpyS3yqXQqODEannUENO/AFywbc6+a4DtwytC6ghWOa1TUednGK5Lcji4QWxY8wS7L/OvqDA/dm297gj/6oBfXcSKFfFFHx17z/GR7oK+E3qefRHQM3PWiYGaYOt4rr1RiRmvjc6dE60L8c/HhdZcS5gkOf0xahNeTJvpDVLFCrwriUwtp3yDB1zg/BicNH3o8oJ8H1nZ6KJ1y+TrVi+8/fnWefIJxy8/JU/sCMig2HbL5D/EOu7vkYtOwz4DmYcF7Wg6nH35cfy2OG2LFyLUnQBTCH4ArZUjdxdNpqLUtwJwqUGKBKq5d0L7hMSLAq/pVBgbmWTWT0/eLfpxnpzNSWA5fiTiE7YcRpfB4qU3eDTEs/t+DKoz9Bb8CxJtJG950YjDYyLwcU66KJoHYhfTfpOPigoQ6zvjaHb8kQ1eJ/wnvreZt28uQiaIMuH3sfepFeLaXxphSyZNDLSjrZ6flSqnm+N9TM19r0xeKcbTMuljta6LA1Cdr9Icp5E7/pdXZqRcPsBbnJgi0Z8HqoTeHCJfd1sttuXxbTL5yV/Vfk3gX9RiLn16g/1v5iuDn4hVtLuONJvjKDFDnCIiB6QIkleMm93l+uDU/ylYSR0GgXLRHRBo3ygo7FXgO1VTnDol7MQB79OXCGv/AcWnfyea4HZDNFHi+0X0e7jKYd7zLQJZGpjeLLc7J0ssMeDjYIRZPlEHOI6ZI2B+4eQEZwDREOJKba8qcZhcPnNgJK+0RskWWADw/Lz0vBTA+eALXce9QU5s3+sHzxYgT2fMeJ22920Hg0VfwGpccjiEIAyJy2pn6bWXSfjH9Dz/jSGEVStmUOM4g8xTtwWVX+5CaJmv5fnC08OLxT3CXI/YbG9YPj3PuNOQC/jugzkAUSYIE3AX0/ubQz2WyiTzsmg5zhBowTT49NSAq8UaOAaD0ztTdOKvzNcgmyzvCIhhQqfz8fI8nxziQ15YcQJfLqSGlH1Mku2yw6FSgfehmoTqsIwv2217rQvXhHQp72HRJ/5hAlmsMfGr3T8RAPXA0QK7zAzMmOV2aTsPNDdg6U0pAyIQPofd5QmHZT9ou8o8XYdGxi+anl/V+5LoknAjmWnpZ4Kl9iqcJJSpCmYOhSv45Mrh+CCC8l2tzUdCgrOSr0gSGuDbA3FJmvONzus8n3ZYWf3fk3DCF0I+16ug7+BsSim7RvXqRQKaqTg/qEVitT/5riTnaBSOjskihKOKgrvovTAxyBDhXSEcs1ZXQTr9jCCa9N27UqEkhD/JtBZzMF70ZF2XIFm95Ucl6lCfGG2fSyLoFu1ahqJJU5+518LmFGeAmLMQ3iPpxhPQ/5z/eqW5rhlM6Ixw3Ms1zttURWIevwMBZcVN+5iFoklYaJ4v1xNqHW4HXRNWe7rDfE4gokmnki7DYodBKWZtJQq68+ItHFVcvFJd3nBgqLTX3a5tgwV8OclLmXqESLLpmbxQXWwVdktxwmmA60bSapiCQ53Hq/AptFwVT0K8k93COAUBWQwksGw1aQ4vNoYRTTZ1ogYdjzg7ebAHj+vgUk8jx0Z2Cim+s1XQwKuKyzRsPmdFH7VtM2lenKUk6BypK8ETJ+JszKKhavrhBGtoX0YuqAxx1G/fbnHHNCCapR10j2D/1Bsh7pnXi5ExkSTcy6Dl9aEBPe3BesLKYYbyOFhrwPa/TRg4BcyO8c/+vXSQedacQ/HooYM/bXy/eW1wtvpqpTOK6E0w8tu9hhg2TXLVkqWTuVNGfIw9Khv1YnV/CC49FmD1c/Pph2fqCTMe1tzgIVs2pphy1C3TWDkHqZoi/xJ1SdZXhNQwV26A43rvpVaoKXzllLuXivQbtucl9j01/I5mW3mmoEeupuv8Lya2ShKoGt1oeFcjiGonl3vgiDrGDbBuQTDVMyh1/2l3f1aPrmNPbDYu0NGuwjK1/q63YUTtE0nJY16mF9cpDALtXaXxFcGyDC1hhqIRXur+HB9bRh9MJ9ezivb0DDJgknDLHL49d3iq9QqofXcyAvFk5OI9DSW7CNwiDmGpCSSllGgnLWp3iR6sHyob2ZKsSU7cuS4iNl8BtngwICJknHk2158YNZz5zuz0OVwlaoWu9awxZ04JhhfswnsqJohMOuqcapsjCZYaYoWKAU+kKuGsFS4kSzSL223wKPldILxFB3TAB92a5PCBWe8NSp84gumglXNq0MiDfAr0yAfKtOwk6R1Z8vfJVnKir4JK21yl7/14ey4gNHMykwh6qBvpobPvQrEyqADBCR1K96sTl+D0IAjm3GGDecJ7HNrMnBvhhCnz9ZlhoODGTjWACh0ZZtW2yGIwPHOAZO934uiwf9M8/5jU7dvUH7ZT7v/v5FmEuo3aZhrWbStmn1jicjO7lXTmgeazdXk9nfpbh37814huaMBxkA4siolOJ3o8Ob9tKC7kW6g9i49MCHYG7Lxb95T0i6m8k5B9F0i9A+ONSUn3Qjw1gEA6DSHd4guAqUrAk1TxdvPJxIOpFbHghmUNzJHs04Q/hIhzfUi9Y+D28JhDbP4zFLTAH/VZZYragOi1cHdxoLNedKfMD928M3CtvxRsEE3EBelHyisWUfI3goV7z4r2nteSuFsC7AuQcNgzjPjrJvhNyvNDJa1U0PfFBIbrkEALv0hPkJw0AuBaEGlzPY0MOP7fl92Q3PW93hNAZJhdg1xaNmtdut6AvR55ajowE15n22cgK/2XYN/Z7EWG/47UsrFnDZIT1UiyLwIq8yj7OEs0BJGSmpXLXOB4Gn/aPh2TJJkC9IAAhM0if8mb9Y2T1V8aAAQS1R2mnE7a0mRmVpnfPryqRPcYTvW72zaE2e0qsDLFodm+X84CIdGy7cDgdjHmcbPFPiJGXJqOB19OvlGa/Er9EXLbEKwhkLciPwte0CW/jLEIcnrbgzTn8acaEEhdq3Z+VMvGQSsl9bd2gzXVph6ihUC3hC7LbR9toeZ0bT+/AwU/ipvTMCG9QBkaHrQD6n44JRXKy+02Hj2wtqxtbNmkypGYkWlAfYv/d8POG2G1Yfp0tbMj80z5klHwXtL/AshsAzh/owOEO9IWDRs1C3g4LS2asseR1nLOkJd6FKS0XRmV5p0h+oNNkqtfWQo9729Xvr0Z7XQsn4aeUYouj3a8Jj7GEp4pkR/QoHWDHeExTmLf33gD/uAmWY2G1CtEGz37E9uIwF8b2rmBCWp+zDiQuRGr7U//n7WJGxmlVSkFfp+4x8pJX3TCiDBU1Eo6QsgwTQXeWLq1pjYgcCegjqOnFo+AqJ50/GH8p/+oF5ZdyoqvG+zFfHdXbp4eLBYwGjlRhQ/CUkjreuOUj+VjsgMDDUSXVpkxbkM+zY6TJ5UJj0eJzUow5/MR3m14fM+J9q2SiGmSj6xu1CFe49QviMxoPxPXo9HyGjD/bO7tDFMFgdG231JwSrJQO26VZhYfKC8pO/4Bl+r+vx6hnUZ+mJVNH/Rb1snIvJDatOY+dulGijSCDqux9USQ34/2Y6/dH3/j4OzneZ/hMddLmjFLrw/QZDba7IYyZ/RXauGG/fAG20tzCttLbDOihUMxE2qa4qqZVDqY8U+gSf2JC4b/JdeB6umPBxn2SUvwEPTeiWZo2fNLcO6TXQyA2xSpv8hesA4na43AS3VaSz/TTqA/+qfWhqUe2Th9xlXX3SnQG7SimohXeeKTzjF5zKcJhnT0p6qNl35a0lleeMlJ5OzQIwZnPLramTJALXU75aZq3ME0Zkc5oVtWrFThRhCA52lBeKUAh3KDul4It1PfZQNcKky4v0s9WDYTSL50aoKHtbxmHDfbLetvgG/Fh0gFGXdvzlnNuIbFOBCPIIUyMhhvtYSa+V25AU+bTkAsYPDZjUew7VbpwiRiNUpc3c5ifutgt6kzz3SAlIpZSlcv9mrbicXQhdHjctYeS/GjkHZ9HVWUMbHOvchMp8DRro4wfZeo6AGT/nOYsjLfowBO9Zrj5CLni4r8N5/MdFxk54WO55BIWU2wpBR3PPCQZmx42kwso1LhMTwK+MlXb/s6V1zRfH8Iurcqxz+jbeQDe8wJtz2T6SA37MCpdTVMpwO7qUPm0nSwIHUuUVxaK27wK1acgB5u0bxoG4L76CaGfHoHvQzGzdEZsZjHqvFcSvp33qMUIqwPgdoV/6HsSLgBfjhAuCSPI46StH+/VB0nIBLId0H1mw3Zy7s0JsLftUDlqvJo/x3QK5mHHXyMV03FnbFyQBpCQecz7iZyCMLGKncwCubCb18Z5e2WBGLIUEt2LoZFj95CXL2XK6dhcd5NOCFUunH/sCq9YNX48auJsdt1rdjnd1GR+u8n9BT7FqkOnu0y3MxIuix/qRCCdohSMhk0QyzgQ5XOkF+o8G7MnJk3BBtSrsxprb7Crm8npwdEE5mZKIg/vPm1NtZ/7qZVMTDaP2aBcGwtKMcR1ujkWSBnJ2b8o6Z+gZuWg1iiKPh/qkUEDZzbsdzycinAGpI7PKOAELqBnXSof+gtCtsoO348IKqo2/eZUX8FtAGQSx+VP5SLboQZBin0O1jwzvwcZgrRZXMpGwYbmKTH9rh9XTzWhYnNqvpemORtCWHP77cfBX6w/WQ/kMjHWOfuUJjmV584omV6uGMcVJ9xp73bcylQEvR8ApNeu2cCuHyc5ErVmxAzjfRdqPbqMA3HnM8aWBvyUZcTAjboxHdu6/jCxhGUVXVwDEvwJM8AhCtDIrYobDEW+ItuTRIdn5FneMFRbnmrJJe77c6pmwWpEtkrqZlMdjzbLDsQjcys13GcU5jnYkH7aRl2F9jzzIgrWDWC6bNtKCjmdRECk/ufda2ZbeLd5nqhobCQq4Uus7ZOrScN/tyByLt7E3HhJRLyJj6gI2NXq9HTxIkiQr4O48Q73tqdDGU4FKkAuWXGGvtc6+dbOczyRadi/FRXjiQIANZ+s7z1B8A79/lko8CZcANXeuVG6soVuI043om3uVhHEOCdPZLmt4doDZZ+nV/2Y4ykNy8AaRv6vsjmkYWDYG/YleJ1m9s8bwk4T4+Orq1qqvO8FUEgjANHfrurnnn4me7MmrR3xuJ8KGCjHjl4Z7Wybcm73qw/bYR/ajj5bF/ylG25npcHThdgXGSWG2fn/w00qd6dR9v/ZAjlH+8K3E9VzZM4ul3X201p9A0Bbv9OYDTc9yrn5lCuw/LlC8vT9EpsoSiW+ym5e0r4ycJ9F7X/zTTqDe3fkiQ8tvhk0lUeeru1j3uVHjfkrxCd5MND9/AbTP479r+V3Q88UuChyp+Z+Vmj0kAEPmTBCEU4ThWnB7jlqBZwQaWiKuOxLV1mWiO7Nl9HqyS6VqrmdP3L9A+rHf1xtNgC2+ZxISsOfJ0WV5feNZEX+bAzqe2RK6QMIeZSxFkeltCCTgAcEk+izFmOUNrD47XGUKIsbZcdGwjMzzUQnTHwyw2OQvHi60TR5LBaDN67+R+i2jpK5TLIKUsTgHHJ6HFbjRSGAPEahx3clPmKfI2mGHW6svxPa8raXH3Q3n0ZrO8CuxrsSGoO5rzgYf2PrQRux9+v2TB3OnKUYm8lz6XFdhInzJSmXDu5MteLczaZ15petCmINSFjJCaH9XkxUJ/SXxXlxtccR7GUjSzmE3JVqpeT0CiBrgXNviONXSMm4F5w1HjF2ENUKc0aYQT5l8sEgWDsiZEPOdo6fdv9BZJvf3Gjxv6JwDQimJbZBDNCFt2KlG4zO8OPJ11M9/T9RbGT+dIUc7smERdBiWFrSQiWDc+F7hJLTJtnbHCGA3dESZF62snpp6ucdiZLHl7OD0reftWPE7ga/ITUYzUFWe2tb0imCARvMT+s7cdHCsoFQguYUWHehxOHJNSGqa5/gobtuNLHtcCEexrhzo3bYTtQjCl7geDAWFW3zXNqW6wgHmpS/de/AIGumWAIubursqrjqfyyfpD+Nk/sv4OYpNsjK5iTDBhwAPiM23AjFmurFVQc7oAhV3O7Biq2U7HpiBj1NEeTeN5795TfRTekGlOK7E5cPKAY6mXsPSF8rFwht7HzJhSACcmPzdsQB7y6Gh1Ptz8s2+S7jlx55E4rfTSgC+Te59xLTnf8ENLvUXvm5IzhrrdasFJJvkjLFAwgeKuYUhN+g3CHCp9YJRn+X+sWAsAcd3ia7eqnq6ZGz98gg6j2eStTuCxt4kDQIZeAv/Hr92QYV/fFIaUM5mJLPEVShZTFCbFgdwAFiY/mh1XOB6c7A0GjRKzbdhPU2x/zVIzTBZL4P1oAQ9lk8Y6twgfvkTvsWO89O0h951gu+JbOG4GsDmR6M5xQoEFopMgw3wHYoLvqGyw674KdI7UCc9U74WkGpxgcel5xdSmyCoZRfGllTjW83nMpQEl/7kDp4qqZxGwkcF6biM2o9BwQakCL/H+BbDIXFc/iwqtvmXBsC9M02dqsgKm2TBFy/jB5s7J8fuHnbgGpnHfI5ufULil2jPMfmAcIbcWwcH0dTJcRWL8qd0hW4jYP/tuwto8r3mNRJG63V3laaTiurq2vKqSwGdiSNcpS4KFqzx/hVKaI//KIO7kzvL9GGEB3YHlOcZAQ2tjzBK3Pmjcz78OS2p5wsgd0sWNY0fIMk04EbUdr9W3tKtA16MK6k84mZuO/vqCDN3iH5zCAuevRuApmDBRhQOeoYUvlKAuD02KAMvNtl0EzqXqjMU6zBa76SEvRuSUUNFF7gXymQ6lkZHoZb6NkQLcJhgiU2rFiugov0jJ/rO92U30z3xoHIcHWFdAn1Li4V5F2ZxxBE7ZK9FT4kS7mB0EV0xk0AJtN29qJptC1KvwEIHThmlUXr6iWzdXZ6UtBmYmvZhPJaCEgmOrML3Gt8D8CyZdbTL85ooj+RTTnK5hQELGX5+eMcfJ6/9HCSiAfr4qnvcCJ6jpA/HeDSt4FFD5p8s2NexUddvQhHIuWrMiOVcbSIv708TcUkYJqJi8m5PJ/CVx7CzQCp66La0YlNibctSsIpKSQCoEPbPesZni4SZwu28cP1HNqWseqkI7BgtufZQsW3VhegfvuGTZ3GPHFKqZa2qpMgTKEXnlBqdFfMl9V6eKZAsmStisVoWU2yoTw9bZqaWzSpa7bOuClmlI1U2Kx40tce7jNy3w++ps5qKr14arDsKhJBJ34b5kXPBrittirzS2KUxH1sNLtxcjJOLffZ1y8d1oLMnVkSq5vn4TokFAGVh5kCNIAUu4vggksBGGDfKsF7trYBE/9FUmFPENuKbyLiC/M5gWF6+jyGWYHfpDOwURjKyHtg65HEifbCFuVmcpxXQbOWLrLPwldiEKlp/y1r5EIY8lAa0X7ZE2SdbxNISNDGaL9EyFejCGMXThWBDryiTIXoTXYkSdjoijCU9xli9bBTI4veUjZoQW7sgr/Orcj/LJsWIt8r1dJyIHT6aIQMj5lRZfR4gXNJ9noupqmiKDyRnveVh9rYiPo8nf5HrFF5C1BFkNka4//mcun0+35uVyGqKWcua51/GLVueLU8Dy0aeTkqSTHQ3LGOYBs9Ny4EL0qNArZp3aDK4xd/VATrPcbe0kzUrn+rxvy6SZY85aNq2j1eltMmeo914Q1MZAd647kglWMMIu2Bl4hlfawdscziiYsTBrWvOOTZwCFlnFarekQef6Ox/JCEjqmqGpyoScUR6vqzV1AT+yt8iadCHCOJ37wu4X18L/Y/pZK/dswgg40ttYco/zNZOxrKp94iciTCDAnNSD0CIU5t4HH80fIyVf/g9z2yIgZGImo5c6IQs6dZbkuClh4TtEWQqS0kb2S8O/or+UjFsm+BG+PPQg/WrBfk8Z4ZWRsjp3l6QLRXB3EULYrK83PgglCEcFHdj6n9zDrbACcBx/lhjl9zPIbj1Ul+gOvysvXHc9ZkhD5BxqclRT25YCiKvpwfToKIZ8ydmHqTVp0Im10vv0hh2q6YyQw1Wb0fN4o//aqpZWwsMZBEYPG+s5+Hs5csprrZzjD+aXaGOqAsXIiH0ZN4CV2Z0mebPffuRxQ4GplxJuLJzhgns7GZCY0vsONbRQ4VO/z9jL9ympwLJ9MgJhtNTzG4ts4HE4RmVbuEiVqGlsoeMdJZ6i7kRvIZchc6FpCLsPuDfphrnDnJwsqwqFoCFzBqKdvPASYg9pirJpwYoRTFx8wn2/PE5hxTC9PQ/NjK4sdRoO7sxteVQBivERK72zzRwSvNCGuDVZ+WtaXlhSfKz1kqOK7U7lNqGfk2c+O9mp6SXXa8vQxGBt7OTx4UP1kzBUD7Y+0PyyRJ6MRPh3kleMbmXuYxRcgC9urStu+iYLj8Qc43FS2UCoyOUdjlg5/CdG+JVe24F34RNPnJDhv3Hfkt8zS7Pj512Vq0yJW0BGjDCZPTnOB2IumADyUju9nKo3xbseLuPAXsTRzeAh8TePd9Smlrfvv8iTUeU/AGHjAiemA8+5ShhLyaEQPXbIW59/hNAHLfXxcdEbcV1EdcTK29PZJoWcP9jtkGGyYYaPJ5XU3s6j3JHivRc1Q+HxN7GU6hoQdjP7ywNvWKD98f9OYF8X52seaPmSWTHaHhJ5G1VUqA6ZzqV5PIiuwpAzFb7O3fM9wmmorSvfTJu0IWMeTJ/pp5R3KAmtR17lsTCH09EMbZAAwJKBg/POQPf9ltaX5wbFWXh6D5rGSDs4bEXaU2WTK5Xta11xLTgztejDOjI1WYds0XbHX0TEIRqylBcJTl0Pg0mNWfU84O5dC1ONr+7nDl72sN3GouMsX84mH+Er5TE5Jsfnn43Z7JQ7ImLLW4Ty7goFslHZJHdQcBBgrAbiFi8IqDjNlxEYyGXJanLbjnANAfXardmVDORl6gm08xdbIyRoEmDQITJ2QdyVzAnrF7r7C3eUY3qxncYBEMREZ9u9BqzN+tILpbBO0FR/FEmB5rFZBc/8qXX7DHEN7s4XR/nIIsrwN9j+oBDViFC8j0+e92y3J0humJn1V7McKuug9WGCoj6QAulsNLJJcfKxHMROtu3Sru5dvBnKxkWNQKZCwWHv/SKMS2FcXg48eerSX+lEq2z9llJRVtV3YUXwl2KEBg6m6tZ0zBhNUAEHM9MEZvFMz0ru/Qk8D9dqwo17m09i7Q+8Hrj+6CqbNv/mOeqhKGq5itZH+N/GZM7zCkz6q6SMUZohMYBmrYzO+50l6h9RB63rS6yHhrHRSCKJC+1OCOCop3+W1Y9suQ9LXgGhq5WVgr1VYss0GnK+ShHwOZL0+2doND1L++UB0iVZc79csTsBhKXPwI42iRhJvckraTuz3FRZIg546jrxZI1CyZ7W1CT1BO4z9m/pTFq6BU/rrzg/iwOed/T6KrOwgLcAzNbcnXTy98nEosfJPdRXOcXdCNKfnfGsHtSgvDd8SWtTVH5FPxHU0BTmcM/8cCmKR1xnXRIBKUpvNbTI2/0R1MHqCut2b0KroLB6D4Igg0EIJ4AhKasrVAopWC9zVHK14RtGLzAt32njjViyx8R1jjqdvsPmsKYFg3MT9nJxgPKX3m77j8nB+Iz6zowH5pWwsmgei6OvbIDLbMLvtP73IADt/9sW1vzVRXPjB1U9Rcx/k+e1SUq8gcAP+4nWY01U/LSidE4MNPAyRLYw7T7j3ZMHO53mUIrMCiRPyKcQvJ1DFPFdYFsm6xNErJ/eNYvzgQC0PUchrgMO/7wjOhDMHX9OavFqF+SP1jKcxBFcWyi086b+x6iCPjKrGtxN5wcXCACjT8H7fVIOy2gD9ofk+W3ci5s3KlgBwEhTWEgItWfaQiLiLxh04DC6vsnqcaHxtwIfEaHaP4WY7YaxWAyE6/PsywEenLc8qRFMcOXvMwGrYHqdumkIDMQtepUGyajmBv+ycadyGWOF8x7G9qDEx0YMRa2n6beRSEcYasSV1e+ZzK2lVR7R3ieawA3BSDSgE0trBgFKifZ20k4yVv0ywhwFIen56VeDWoLcb/3hjdAtNBFI4XC3nalAi7acqTTvRy1+HwWXgNaHXgBZun8rPtETrHKQ0mfYx8OuXA0zArZNOtsitBLFQGo6vRk1yQN5IuQOFqRnV3kOOQU2j9+OKZ35WLCqZ9VrfnLymv9hYES6ObqY5I/ldEKHVtyaJ5LQSHpZrt/bG9/2G1oxRARqFehc5zhoy2J293KYheM/3KweIRm7xMQi+SgEQfAV3LieW1fg3BH7F+nWfWc/hUM1CByJNksodI0ie8bMzyqxz5yukLs2owU54Md3pKj6vyYWairofjoqGokcYE40wbvRiCAjgjG3FSYjelY0vs6ComnXYTrKFwr6az4wvNj8Md6ei3FeEaK5anuNVMK9vWTQ7UxB9tOZHrhiRikcggcPxp1ZlvZv3lg+qLHajtI1DYh2YMQHUU3NLtu6rJAT1Ej4Y2PP8EW05H+eskrjAXfd7aaBpG1Bl13j7uEDjo1ZH/CuFjhK9DBvPRBsaqe/w28QjBmDBspzNf72CP95rURGe1qk3Qo8MaNx92/PH5pdmGgBOF7Zlo23lncHruXViXY+CPN3ugsRObQIjvJgetqx9qc7JGxTSZ2iznqw8SlmKt9srAcoZgquJlHIP3utom8D4UNITu+PfmFHfwocPLIbTH2NcD3uysXyoCQ9+1qMZIeOHOBCZNLX9q8Z+JX1HN5wFXGQYHpNgzbd9nboK0KNfR8Z3q65MlJpp8XArcNXHYaXsIkdCYMQolNGfO5ke5QVS0yLmjOWjRMAVD5gSpApBKwUSxVHWiYoFe703/70Apxb4XQW2cGxtKq+E73waI9u2YBI3Uz3JIxt00N2aBLIPqFuxVjjDYEOU+/nLj2cwEOMytoQW3UWkSI9kNcgqMSWrjjgHyScch/HgalWdbOKI02hHNyF1BhvGLxlB+wZmk/XScVvSaZ4iO7chcB4/uV+WvB+gKNDIHOwgX3mSASLgJxru5YBbgEQDQECbRt4wrejzzgo/aYH79PMm81mTLqXvA/Fn1OCacaOgXppcZhCw3IiA1wyCWVjImTM0YN7NSWuhfpOfJUKo84sfYrIcZEvyyNSazvP6vOnvAuPcnDRnYXNctApy8T4k3I8yqIMlAhWmUszvn7Qud8Bj9y0wXALeC+KY7kp2KaeBh8mWQsuAykvMvbNkNYVXe/LwfF5t3Vjeo3JyUC8zL37Id+bbRpaXmgElHjuMU+jsbLeSYrdW9gmmkFlboKC1VPNcMe6XTndJpHdXbmiZwFrtfOQ0dqphf6rnVwPgzQ1v7E4eq1gUmm7yzEseSqj3JxWNFfEHghQoDn79UjzpFuSJ5gl8M+FQhYnXZKh1naovsnurHLEtWI/6Yi8VUpgiQJHi5s+JcqD3PyZGeW9zjPevj3Jk+/O1lEHTK3GfHFrNR/sFpZv3nbBJuiEraaqvf/pOSnkPDJtZVv9lvjduIR4jh6qBb9MJjA+ANds5W9txSeTq/muaWMWDC/iV27RPnSs0zFguXnKCVjTUJzPMKvGRwAn5blTBJcupU57cMj/3zK2RwQWIsuKWea0cPHDusueErvxRFU2IhNQG618BTNwQqPy8OcpP5FNKD3fayLY8tM46aASF/FUV0TIea27r7ghA+i0gKDzIKxvL9d6cQ1DNr78BaGuBzGayCzrTzstIblOqjZeYJT7kUqm6oPT586PWHDyaFkALEt0kofkR0AiQ9WlQnOtQUzYjFIsz610C2+cFAewgkgmpRX3sX1QaiRigvCbk3XkJD7tsX5pQnBrDkmKB1Hrs7tGxxmbC/5JtqoomC/dcw3CfYR8c1oIVuvy0Z17FplpIgXFuLYORJPdNQPDQ4zlFk2SzyEarZrVbSl8YuTeXW+HKH2CDeze3gGbhdyBmyGWTva9VKEipwyaFZmHTOTfXdE1nl0XOfVccexsdW4uzv/9VWAaNjjawxIwLwBdV/zGcPdOYypXm3myeGzFfvrYprfr3dqX5Kutq4x4l/V4nzyIafWaAm0y0YemE1FB9lxQYyEdlIvUsSNPQBr2lZuSwJphMjw6FK01NgC9FMogHCUWH724/1oHYWDSqJU405cVxIaw90koVUwNBGV+gwgg/rhc2cRoYxA3Cjs8Rl5ZCGK7H6HUJTJv9I/kwAW86lvNU0aNznBoZg4+8DtnLbFjgbZuEzohWVuWgial8VdcpSNCERizmcSd9wogfMyaPvVQ3uStcEzIaBWXesyFPptnMe69l8tnZxRVS9gzYQYZYgw0jUejMdKDtHiaZHQWAKGvMe7IjmIlesMeVIJKt/EBagjctptyauZGX8zaVn6/w+dOEJ75re/8+qCUCKoB47F615eSljnscBdMs79K34lzUjS6HXuyGeAxPgJGPm5ypAX3IUQ0CvM4b/4kJ3vpcG27iJzCyyQmDx1NBecNlDsrGTKpYBOSjWo1STNOTnct2WttUokNh4Nx4BKS6s8JP6Qarxgu6EuKZ+IrxFcIEbCiE3NQ3ZNnNKUuyKtJQbpEJNMzrMBOs222tx8+zqTPu53Phg9mj51aotJOuWIeL5fa9P+fKj2EOz5vPwGE33Wr9pmdOsuGHK2yTnPhRPS1k4skrpofbsxHN1TMcXi+G+Pm/rT5K5w2hnKxAvUlLTePsIwcN5pQU//pf6pErT1OPWqSUltgU7hCednsk8WNvzVzfPQkSuo/c0T6TPE/uwyVqhM/Fu53BSC00vwXunrNO9pPU3zV4bG/umBjp914qpPdHvHvUlmgSAtIKdiBEaiEX2wL57MnKh8paMdCVmHhokpNtB6JMxCaVSu4KNYRdlPrUkC8SQpPAR2Yex4aWi3r3UjOYAgFQQc1pLO5NxgB5Ln9tX4cb+bYIAKt0B7UykU7ZttYe7VmDe5ZKblqes9rz+mg3gJt+ncGcDDT34SOD7nilT8EVU/vEkg9OzqDdgIFrGDAPl4GMuryuFtT/SrV+Oi4G4uJxfytBSjFTbIkrDeXp3AMi0flV/TBgQiFpZTz0OHRGve259z4IlrYF41Mzu9MmlnSzB1kUUdaag+XJYEpsb3y/+pbiv1qs4WcXSnahADn/naxPULqFcWZWHVcq+rW+YVsRrX5iPKeaNwkHJ6WmN2+H5h92C5ysfdIJnEEOxf2C8eFNtGadBQ8XPNQ3kuHFnLrWBY2MhZfYRtCB2In/DPG86pHGqG2Y2oCFkXWySmXakKltzKSK0pZ2WgWK1FrwueM/qPNRBh2sT24v7RfW6Rwng4hdvZ4vOiBpXrsUUj/6lTYhBKg6M3bOx2k8m5YGIIv2ynJ0e9wBpO1yMgAhopBbt6VaLZ866hEW9BlULPIFzwpwoXPMagtbCIse00Y1k59pe27VVtLqBs/ips/r+tav32WpyI9DDFfg0U8cVZkFxajUWC6hPAFlAoURzXis1zFQwnKbQ6f1xocatAzyLEhvUmmbSMp0Jy2J6rKWZSq9ZdS7nbTpIQKBoouZtRRrEE/yFxSGmeaehtEKqxboDgY6UUyRsgb1S1IKZmnociNWBwywKPKu6bmWVgfuqLWPXIWe0hd85S/qE6DkC2l/aHRFxEOj1bZw3g5zFIF5ImRBCSctsW8ZjhCTY3uKVQO2CRE/TMqXlz+OpA4RTPp9S8ANZr8coLtIUpyOWZFoH+5oG+fxq25dEscRgcSxUpQyYB9TdUHk2/M3ih4BcIl1dm10VIKL/x/qD77+wSoPcLEOEU90PILihb1BJTJKlsiIlEXqrXKHk1E23gCOQ55LLXJeccMH2G2SAbK9mP0pC4MYDwTOUSbW5hGz5P9eX3SEID/Bgq7MWO+1SYSnWJ0lHA+FUZY37a3xJzW72shrX1tAMAez3Q8WHcrEgCMuwqMsA/q3MfvjEp4aAc2sfbJgf0Gkdhk3NKXTCoNiIzv2PaOUF+AvKiq79TAGfZcck4DY35YkbBxqAhMcPAOwx1ebP92M7Tu8WIrkjv1tgQn+neGPe8POBTJR1/oDXj7FkiEdI3fqfALW0Y9sv1pI97n7fyFQweo+1y+ulnapHSMfFujB1okZkeMKEPo/XvR48UPKs8EiezndVDqpnr3l2hKT2plocO8al+0Z2zNIyfwopjnFcHHcdGDsshaZ0BVGZZg+mA8cDqVDZk+K3GKoPuNr7FcH9SoaGSbkmMiH+4q0E57I3ctvXNGM0N4yNXx2kSdUG2wFhRC7ZIcdxPdjI9E7NmpiGb6xPn/BH2PzIdmROGKb0mtETO+TmXAjvNslaXQSIkmC67LrpyUgOJGNGBaV4ooRtidXy+0wQZoehVTsNlXkH78XNUQkEknXt5r9TCth73GluLpsQqnaVN7DXSPSkv/cz//MqyQirCph6Xsy45q0FFN0fQTgLSCaXDODgjApjCBgstlY6W8eMNhh6aFVrUrMqQi7o5l0Tu0NyEaSIQlsD4lTdCh4+Xaynhy7phBicTkETn9j0ltuA0uA06Ryiy/46I/+SvEFvbuMBKnbgNlrFL2c374T+fpPduFZ6zrjIUzn6q8/L39JUndDQLAt8qE92kiFLSYv2tBGzDPx5tHUTPWqaGjhVkdiPmsNWFjmS2JWH0K1t5G5T+OAO/YAG9OaP+TDH+ygqrcebIJbRww1o0bKeCROkfamY770d2hepVs1PInYQVSN4FaVlKzp4Hojj2GVYAPket6SpATALk9ISol2kHt2qDzY5XIBSdrUwNYhaGqRS+Ke8L0zx/GiZ0gJAyNVn5zP5Ax52ezaDvcpL6LrHhl/O3E8//uWm0EtwXXI3lvcjlqXiVFc46Tvr0vJjPrx/VBGpLZMUBFIhtjCRURIOaFWaCQxz9ursj/3zK5hnlFou6x+CAnqUNxiiFeEqB896y/buWvdelUkXyRkgVPubh5l32rq5kmOvNVul4OvR7TAv/mT05U14ewx849kx+wn6Rg4GI+P/XWhpqL+KxmvxWngIRpZZhNuCoASzYLeZ4YLt+jMurGsLzcvswaGK4+a4KULvcIJAXWfhfFOoYVpB8Ya48VAOecoqn6SWav+yfciH9/2dTGd6JxL/fPJDKIoww7UQNFuG5AbWMQjRlsf66CQs/RF2fDPiK97QjwaM0MThYzzrClpUCXmj7Xt5uGGvqWc/n0Yeuy1o9yYM1d49uMdBwYS+7SHZeVpLXAoKCJIoQ4AjvifA0RLWQ87oN8FiG41AoG6tUjoPe6Dei26RYOJZWnglOxN06FJIF+rq0RhzwRWoA37XtEq0PznymB+NCjRtOIEzeU3d4lYd2K8x3MAdazIgf6CC3mLxNlGUoLDL9yHYOC1PRW0V4CL9dOdtEb1eaRxAjR5ThRFU2P04b3aj3chdX25tL9FGsdSM/7X5h4nKM1LQLMCLnQZd2e0t/iag5gAPKAHCHeClNN2dVeaGm2hfCRVat5pWvJt0Z1UWzY4UxeT96usVlS2o8zD/eHy702lQ0KPZVFawEHfAlTfSDhiZd4b8037ghhdVkAo11P829Z7fJ+t0L/aKzZuqGMlVFU+etGMc4Opr94K4GPCnTVCnTQBEpP8+DVVRJUL72/0XJYRKSIpeYhZppK/mrtAN+GFJvygb4Aqf/AYyY6dxM35T1HGI2rs1ZdejAbQYiEdtCULLpOC5xlXSzMPqZx2Iut0AQuWtlw+3F6FmLNTJJgqVmEpll09x23Swo4ijbyaNK5E14NgB7ZH56mMe/ooep2hQ+XoJ4xpKejJbmMlQ4jho6kKiwXIfa/ODCMAsrBTIaxrn8LjZ1DLan/thQtf2od20LBjyn9Aj+GdrmmNNH8B0FS3Fi1+WBOB/vy9NEATdXkXW0sy/hjS8GR1/jxNYt3x4i4fJ/xGp3v9lY11nQnW1mzFrEhGt1tIUS7m1jrM/cSgzteIdTm6ZaR1xDvOVbLF5pA2GM4/uqZz0lClyWBXmAp+Wprri6BnSTrzHYYWcJVQAH30841/8R4fbDQvuLtbWvmdilhuwYc/YAMWhFShb4bvQz8n+MXmJVNJljQqS9gNaw/+zoaQELrWnCBz1p8LO5gRvno0oQXx3xphE2j1voF2zarUEsDxFKQhtrs6NezQdLhtRUPyLUpRcmYbHscO9GjHKu7ywsMDjepfVE/vmO5DTdAzswY7t588lmP+ywCFXIHMfRlYCOKUm7CJizC6C7twgtsnD2xRuX+C7Zeg8VPhbKOB3dhdr6KqNeSWDMe4V54aPS+YAFaeTsdZBCzh6QBEqgsE54cxshZ2T/VTlnouKZxJc//Ki8dNEau/cceVF/+KE7XV3j6W/GYr3esLVhYGTFT9p7gfq7CulDAn+p0FgiOh4VPWa/ZlV6ij7+mRM92iGN0+99X0qXgQxyvnMywvXvj1hp1sNiSQgMn4JmIRzjKtaD7/LvC1noaJPOa0AnpstuBNmk1Ivi/NFcJpXdC7T3oMIho4kDWSDXA0LDq5Tv7x6pQdpyqwRPhVmgECV0vsdOhHYeifUzXE7VOIo/0BJy7Vl3hg+0phHiqd6VZOrdrb8Kf5zTXNBcSJfh3Zp+XyoMXi5xKZGy4Rj+mM3tx3oCs9hFvxV4jCisln1R86YnTdLKdcfyCEJJK4I0DUUYC8ba6wX6vkFhBL+dMnDFQ0cPTGq3dYZSrOcySXznP083Ucay+mnLXxXIpOsk+YCyPtOEA9v8s3YrSr375gHzRD6w74pIZBbIjnsprteQL76b1pEfVLApwBqbdewqcOLy3NlaW2bzDlqJPkzDJV2jvGhFa8dML0DMsVm8zhD1rekhHbMzOYrgDOVNywkineKbW7NV5pW+GDrA7XAd75Cu0QbYUgitKDTBhDZhhaGabJiOffro5nMGPfQQJkqPKOHl+4JbMzDNeFj951I1/0Jq70j+onab0kT4stJr+GiZxT5xOJ1W0225/AM6EGsGN2hf3MU+SQ/AZ2J1G3CegmZgPk3YBkhxZdbcB1R9JOYs19Sa256JMxLehWgl9ROuLBD9EAt2QKp31vuvx7HGccPdcs4rpfuroVwWJuhlWRMljLRvBWLvCR//18NCCO0CCXQpIEQLmDqgTGd8StkIaWzPi/wBqzlMyYLOpRlfrUB4mAIyNnKoitcLqc8DI/4F9y4WWdRfjT7sCyQt8JgEekJXM0DsrPSNnGWVmU+tjBK0OHVFq4xgIz6r0pAVlxWo4DiG61oRLW0Z6XxKlZ3DAJ8a/XuMK8SaNemDNZs6/R3QlZSVYg7FHOz7CELirJ0X5ivZnXUKnSkuxGXNjfcsD93BSCGBv9aV/Z8bgvgXpw5QdXjoWyojHn3+Y/XprDcpGw4nDmT1P5bIr6iqZv59S3SlluUOisvKtzzXuD6lwdV5QWAsZ9MfmA9WKC0dr07SkaSKG0iO44Vb9+AQHsUOyupzxiuXIzyOcjsAXnSQkZcFFzUdl7w8xR7f6m5n5wP06cPlmZbf2wrEAUz2NL9WzB749fUIqNLQHHENTCXDtzFC3B5uk2wr97WzpA7nq4GeLzXYFGL4dx/Dg7uTRxfnkVwhItnVt9etTMkArozJMxsP2ccIYu8p8E0pfpAETa/q1V4/Ky729QNjyRyzlX7p1WRzTVAh8KFf6h/Wkj4L+Eiz8XyUWmVEAiXua0yUhwgdRvZplvkIBDpmT5pQssYdleogOqXTeqWUqn5pPADPn78EZ38kIKnEbVOnz43Fb0L7GSnyS/gwBeTMAoida07nXP0+g7kjUKyLh0Y8AV7W67kw+kA4Iv8i/ysA2+UH5W2B2Cdqq5xfKkcU8W/+n3GGIsqHuK+LieTF6wBxn6mkS0ZnTBKSClMgrlJcIXlHbpMtEP6e1Fez6VkwBQq3CQXaxp8mpeR/eYVvj2l+bX95Afq167CRQglie/4r3R2uJMeoIZo2S/nS7vNEhFSF6gO4yWy/HiX6OAd4OpkIV3W3Zy9pdzKTyAei6gIKlAnqwQThbBpUc/UWvJ0E3OKHIfRBe6LRgTP/VN+WkLT1kTVqKDgZyYS6AzY4Vl2jJU7jlHhLbbK9ODpPJrYjvihZ4KERLW0T8pQfq5uzbsj1y3Q5K4/KP4LKGfGZg0JZF8knxos1E+5ujiVt0D9a7aHcUKb27NnH+U78VBz09zsL55kQ0ujkRZpgSii9T4iBk9hPFS7sgQjBybhZkg/bxDv4r43AmYX09GehQ67QaV4VOO2h9tkSfvu626urinHtta+y1Zn8RGSr0BdlVHe54EYEwgHVNIK62e7qZxoYiMVcOdUUifVTM+8PnqLZ4plyy8ubjgtS53GcZN1W5man/Esd+62s2oU/z5GmlZizGU/3l7w7DhsgBF2MkQFLv9ikbhIuf25OYtkrCvhCtZBQntVowtCkGzxRhvHkcpGig4y4YEPzcBGp5MbZjwqWHUTHCkKHnG7hVDF4OVpOIUy6FLHEXAgsmQVSKBnOdZYoF6k5HeDSoif7O25xOZCaaHFpRsrcJ7R85oZqJimg6Wj9aOVxG18YwnaIdDgftoJXJoXzp2nJ8Xf3iU7qkdDKOP6JDCWrZ9VGj2stKKcy84PobnQU+kfWt8w+y/HK2EvtJKyJQof1Jp375zbQTnl8MczJXgzgdJCv/sOc2CJ0iQvdBxWlHeJVEBWyDy8xjOYBE1wWFvYb435v5QkDEh+x4B5SEhmwElZz6O0M1+DSBJFsjU41QEie+sfXU30uC8ZIRUAS6Ln3S7FPcg51jykQ01eYecqwSVMIC4HlJMDbLxP+APaHLYcdSsGROHIu0/BVugKN6mOO3ZH5CnTl0CcY2vYEF4WL4WnYKrT/x4pIeLAI1kKHPQefsUi8bfkjOSGzcXAcnv+Tbs4Fitt1XjB1+oULAXtBrsts6LGe73SnjcdSMxmbfhrFkDn3KKavsYnhfEUn3fP/D3w1woT9yrZrKNmoZC5nfagaAkv2k6jpqvoxU8aEVD2KHgqYENAM87NncrtiBOs4kWG2a9E/dxE0hVAqTvUcnIKmaQ28cvxI0xR2qYEHcV5Fbwt+lXiUhWCuCtOFfdoM8w2oKYcoe9vjQgIdTcAAoprO20yeR8x9KWjMxUNS6qc2b82m8NAVXt49wWFQuR5lBBJ8T7HIq7xmQ8M4nKcEmwcxRi9R+24XSuD4nWgdZUkm+f1w912UL6GbaG1LhXOe7As6HAd8gy3cNmpjfJvAJrK28S6yFDo9AMvc8t/U33uCRd2SHBKCWZZzuF+cmehbBNhFpEuwvk1TRKdSqQMoFdjloo4F3QYLE28OEsXmeX6k/HIhM590Mid0bQvJJi2SjwE/kmeXdodib1D9hRsSRC+GaBiFqIfYeKgmMPnhkoQyOVlsMthfcsqSwDlvIx9uMB1RVPmOZTCPTQfWvel6fcvZykniQl6Zu+1FcpSPeqEdZocFOKh91SH7tIg+GRU02+bRifTnRbFk2eNWXla0CCjDnNiWtlW0MoiSQfhUIRqnBCdzXSToAc52lMjwFZ2Sq2fo9KpSHdaFIcCqxuBHO8uv9rZcPt5Dtp4uhDGiFiTiqTppZRumeTTy/GbldWZKYodpcK6ww5QAoA3kPk7s9oENfCQGi0f2GV53qXJ/8FK9l7Ox1VmqQrgFy/+o3dHJalRnypZvDndx+5c8wNCTBnK0JYCfb1g0RrPwz4Hon16d7AATVfMpL8WqgjhDipWJwo7NWqEDPRObr44ctq/8Wj3ecsNLEEeqdZtdtUJ2ufpaxQQYlduWVa5wrBX41cg8NpRBm8bytg7eYJL5Obt+pJ33cc62xxGqAX1SuoqavSNk4d/GhORfBCFjxhJW1rLqpyK+0vWgxG8yEo15MWLQKLSnekqQjeXZhs/VEjNFAmN8DGSmfzcGQiuCiKVfyizAZ7bn1zZnIUnSIVkVI7mkswLkeptYgfeAji4sKfOku9g7O1Mh/sSXuwmfFxU4ZxwOtrHC+yib6b+igbA6+ZtnB00IW/ffUNYUELgKz4qrpYymUXsDeTBIxoq9ivWLwt/iXgkrjSvl7NqFHvdIz5sacaSPw4jQYbUeaqW2ZCiSLNHTamhZ5QQGJXFxoDsgWOjervFBI0KVOa5X8cr1keAfL9Er9NaMeb4vRrRgvzxJefqYMq/GM7WgVKA/amZkYuDgIoB3K2Y7/fqVIDkHqA4W7LZHy3sp6GMXHzXz2hHsrT8n1CWo/rpsisDpmqzBICysVr8bBNZx2Cz1aTkgkH5FpGQSHgwRInBSbiWjtIk8SdnrEkvifOINYEfu8h3qXGkT+CZLu1TA/BjBb6XLOYwE2f8menQdKzzq177ZKrv3H32OAIBFA7jEZBSDci5VarBAKH236s2IJlud+riRcG0i6wYKWVV2bc83MuxGIBqgEl61JwzkmBPyw7NWcK0O7KbHdYF3hduy4v8kVgwHYjDF0OiSAA6WMwUWdNz3R3y1cI+zNRM52yBVmVC1htKkUy5f5X1e8KtqkdhZiBssUs+cnLJxP/RKuUpZaCQqHB/gPFdOp0RHLK9AflIgMjmHr30OhYXP+ci2FlcoqI52r7LCj9UbsxBEiGWocPiPmnGFoTuAhOuNTHbCMFQ1EOYN8wupBuDc6cT9Q/XAa8wB/fdKPxOSMPXdByZmMH9PjGTNTT/EjyzdW2INCsXeDNLUFdOyf6Vt8sqJbPnOmg5OtjbI8mb7kA+Mh2r3m5aM7MwpiqaCIBY8UllnVLc6iwm3eq3tYomzARz4e4du5gPUtPUbFKx0Y2xWboY2BhBbdtuKqQG8FDoCRa4YiZjXfIQ/4TH7Yy4XdPWJ0rExlVsCL9w6atyP24jS+OpoIoNR92CaeBuHDgvW/ubA8zXfDNimYo9CQ86N4QJkF4jrpYkb9jsosXKNOL9N2gfSkM6uGgSG6TlAIRHzddGSem55HR5Es9fmyxX5/0FgjMsayoIUl+1BJwD7ru3kd9m6OHj39RnP2mR8qBqF/KbgKXAUdQXg75kbefwEmy+W0XUWi1wfkg6Z+dDRS+GRd+sw+6csKLxVT+1CXVdegC2SJfYR4J87kHbUd6f1tZB3S3F3VjuVlpDLEM/4pHt/+NErh/jCUz9HPMCX++kdgSoBhtjPbxG7jjexm7GteMRXdqWp11jxEzA3bRX7homhqqxaV+CyI2HPh5u2S9p7q2IFfv3dyqhcw/AMKIrfv4Md+Ps4wPAf12m4ejuNevGxDAlDve9xAbkj0UwVuk5VFyvqMHRkonQzpRsB0kDPcJ2KlUDVzE1r09AIVSI8Hxy49+tDMUskT7z+iPPwj6VTIN621Khgclc3lBLXoogUV43arUC5chInctCV8ju+lTZvUpOZvyRHQr4twq7GHD8U9kHyo2xE1gJkX62ekfK3AHbXX434xGrmVKuy/HTYsxo/wd3SK0sC84cuk1r+4Bfseut4ZiTQUnO3saP/n8GHs8hX9anhWhrHyhpwXX4UglijPcIZ+JjaxINyBgA7ePQhI/hoDq2kH+coZqrMIe3v+YxDuxHfZ2JiBvao792SyNyUVYkqjNi4pf6ZzurUAj8fO3gQ9XlZG1tAPHQxe6hDI6juBSHQI2Rw2KVrFPD4Jdq30+c0XMXD77A7nxdqZptX2JfEFiez5KcKSQtnN3urvuZbOn6Krc2rHOW/9g9znfM4mUw3OgAnqD0AwPLluityPpdosuv5gKoEakX6lu4wcgyhCRklOAHnn8nlYqDFguIZOV23l1bfPs94/JAo5YbWOBsXodcK2ZnPiBaK6v4DWeLBG2RKGP03TeIz39eVQp9DNC/hLLzMHi6dQWZb4u+VJ5iWAGdWZApq3+Qw37GGEfHnv1BRCXE5Sg1VbY7GJMbrHsGFjObgxWnv903c3n8Hlz8NrljGi6eAu/dGWa3+7Hr1iAIO8xrR4kXtYNX3MMj1JM3AHAOoV859VT64XIETvmD1Oitnt4hVXxG+QrNmBjSlN5pqs2m/QyEJlm9aGblzG8RKOvYBG/VrydiQ0v2X1PnfUCjsghfVobmBL9rP/qg/n9RKJHpOdNbsEwkAF5q5iB/YNebPv5SHJCb2xFeqJaXCHEryRcsAqxkUq3lqUgmTRHTKI+TFUbl+b/aih6DCYPyAyk/NgqVzMbwQsjL5d4GRhWTvJsiVeB0Os5rUHh/YXLE8PFd2tFLoTNaqUzCNWQnF9DzWi3Z0Bw4IrmKigVSlGtDS7kwKIP9zfsGbQt2xSyrITFxJ3K0gvWt7m0YC88f9hB+IlTGmlyi9o9SiQd+3x0+Dj9uAdJw1+Gx0bjhYbJUmhJSQvtdeKL3Mw8ECGBbUay0i5UlvOWvtY1AwlrJKHuneD+okc5BPyIpIW1LFTluxapGpvZADk2c5PmPC7hVuS6Jj6qDtYKClMMgtsUhLd54AFakcVi9gYRyZef6DhphEBeGQsuUuwxKZ4YkIFEsXSWciHbGKRYHW7+lO5ZVEkeSJE2eBF7PWsnvUkfNBkVMXV8+X1ZhKFcT/1VCcn8iQSWrk9fcfjJ9lv8sNC2A35OheW5em0m8v3w0axApKN6jOGzJpiY4wRQTtVBNXn+HP/Il2saaiby7gMwcWMTkZq4YTekvjrzFATtzAiTuCA2mH+wUFaKjQMXeSUhuBZlE0kfjK697aiV53LDpEog6PAAZ5qd74FyHTrOMe8gNf4N/BLZ89IX0SS6aAXH0/Avad9VXOW1cRbrAVM97trHcEkFQ/KZZTyY67Xj6SN3rALmMXIQPCe68v7gfGJORRJD6yJzoTqugRy+tJBae9+IHammzArqRsageeYPAPXBTiK8pyyJotp3AWzfYTRoRq5g0jFUzBJodmQViG0gw4+jLCZ3b8cVviAVRoDMvqcsokxN9x8HGOQQFdKN75q8Fn071P8PqiwUd2Zen+zqsGO9B/2M6r6zD3AHmE/Du4BDdEnx0SmNoWaKq7B8kHXTP2EcCUGRERaDbeBevfvxF2Vp7SOYsIervunP6gMEa54OevE/wbuBafHRrNafMC112bdzUpzxDss2cQBWuDQFrqTRVHuTmnfsdbEgzPIbdMrkbSl+Panl2gXR5ca8MYrpi8XrHj65MItTTJMSPqKr0aZe8hqIOXB0e2YxDhwCRo3QdGYADmzCi6oiPzZ+Fg4wCvN9vLOwlINHyeDOweJGn6/fz3/dqFF4mmfypZ8WCVlJTvSIt8favkPaLlnPFKJmqR5jhYL8Y96w6eRCTSIhdl3HGbVWCFGwdEvMvotwncZj5o67zLr7nE4uH7FRCfisKzt5vQ1Gs5V/chRAuzNQCwjzt1T68VD2C41RVw+3fz+0o+mhQcLeseidbo8DWf546g62MfTPx0Oto1eGJEdxswiklZuwGKnv2c2DVwVIRgicBsoXlURLev+7utqa+h1dhbWP4xOxShOPA3rbi1Vyaybi1c0IIOnxbB0tuTwzSiYoQYqY7tGTIjXCmVC+fITr+ICjRQkkGYP3487enc787wA+zshTS27+2NuzBdbFbyPKhEtPlgaHvceyNHqXjPb2I781Rs0zQwNb7dOHf577fuEuJp32V9jY7qOhJmvKhQzy2gtHPLtAtDxt8/jwjodXwlQiMoKmiSN2CgxirzEaosGCWsmve2hGa38QpLdkPPdcuvQnUysu6pRMoF3mUfd+aOG2qq8vZ9wOqQv6IKf07dMwIz+tuQM+j/SI3hxo+QLq00WTp3/9O9Ai3DmUa9aMqme9Fr+ZrwQBvt8oVDyvY19SY5h9WAFNyT6wEo9YvgSxncbzFeGLCVvay8wJfPWrzNyLEV+irhfo+uoKC1Vivx0oo1X6MwBqiW58ZXiHldE6OFMqPPSP/5rNpbseCOSJdcIr2mtol4P3v+3eVFF90LcoeJsKBTl7RtzjxZYuH/RmR1L7CGKSghBEZR7vnrRummoIqyG9Gbj+uCRh0Iy1pYl2FxIOQjZmnUFsRrs/8l2xNiPZIfSkBDexCdNiWkv0w+7LXZzTis//l9BRqyECSDL+KcIxu8HMbnl37qOMSTjd25sZ6ftGH/klWQJ2YyQHYmoGZ2P6Rqk+2D1xbHMAtsyJ3nwlT9UrLnhx8ODmkujnHrU/J946P/CTpSQaWo/4QiIjPPHUUtEedrAAu0ki20Lor5+jLI8pNVryFGYE+2QrRDS5afy4/D9FejkHiyZUARRtJGWBtvriuyrZzaaVF05fbwjQVr7NS1pwPgri/Xt6KKeoiTt5v+/LypDzQLaKa92iAJSkwyLZhifQmQAHz6wkyNHbDFGxQKOvF+OYkuusg5I4a/IZ94W4vdVThCYkNsygieKpt9I7ON+hhws3liUohgr6wYfq2EqKUCNixd4y1YxMBCQYB1b9Byk3tu1l6+4NvXrC8GChci2kteNcgMWjjojV+xbdl0sIDmHDqlznBP+BWxhsyrlPXfCJUVN3d0GmEBqzsYmS3pAOH7HQEgQH5e1mEynKPF2M5IqAFr0QLs+cke+DhsNTXLKsureRE6U4g6+ZApHPvWp8Ze8tXAhJxocfNrwmVSflh/u2ilUaciwtuPyrJhauZo6GtPSQWqwugHZ2oZPjBp3lhYzlJ5DEaRS8rBD6lL6ISq7B8RmkTBV7NRxxtu1RwfseYt7kXDwl+XBU5pq5jsF5/+zl0VBzudc5ZREPzE/zSc9icT02XJ6ASz7XgrZK2HXFSYM3DlIM1mwZJkfs7ywKMGRnSSGEGQFWuJjzPr0K+7EU0Wim/XmbiqTOGrYh0o7FCIa6h02pTaTq9rubkQ5NEGFG6zMDOY+8Tsz2DvYeUEq8m3t9gNt312DjGU7VPO6GbzXXX+PSJu6lsmJaIXdKGhAwDDJenA90Y7oaj7CinCZbJJDDVJH6a+p4GHYAIpF7MNvx54I22aT/9Y9P4S7X53IqJBeO//KiFWANe8bnzN4LMBUoNqocglCC+YE5jkqzrdIw0msYx+pMJ/nYs2JFEdmeBt97HFl3KdKPHjRin4PfolZJFIsCXfScKZQL0bHGM9fEDHszz9DPAslT2lP8pjZ9pOcWj8w4nPSHG4KBQC6VBbA4IOZBL0xsc/3TTmWT/h5UfFYQNpenLn9elrzwCoAE3zEmZ/9oaqEGuoKmJtbZjx19F7utLI5nwdr2/qt8Zs3lsyqjYYSA34aBPGCmv6cwJsY76Z7eRj9YcTyQuVjprL7FVlCqgPlmB+4VxVdMaYCjc8TF06OnIM62ox6Pfmz/5G9ePqfWgruenz7dq9dcWr1zQP4pteleTYDInp+B3XWcgzHKV0XZMdyMRttTtE9+XJjDFRjQNkgXwyHahP8kTAbUWGnULKHBaO0W0s2n2SCDOYBsUCcuH0fVRLkvpgVI0FcJYGX01SqNsEoIZzqO0UOWfiHo7AmaEsqw93GO3QQm2REiFPr7Fr9+LYI7hzT6Uh9IiWd/SPLRqJCW26tJHbyMTEEzAXOD4TIBLgFiru6Fv84rCPvCvSE0ePc8VAh1YjHwyukdTcEPVDBgDCFduHNuNAOJN311WtzFyz8VlqKosZHf5MVMG7B7hn0KhqGcTJZAdGeyZRGb+tu8h5VyacA5+InsYlyTk48dXqv15vAcGYPQ2TMLiEcqCBWOkJaFM1oV257+ZO/SDMDLGBlHIw3xoBYn74qTcoVJajAsPNJvPDieqEIvJq2P+XTcWXjtu27dw8+/G6FfK6gEJ9QmIhQ0nw9MHXBLU72sFyqC74xxamzrhl2IuYkSQi2ICTDU83x7iWeruJSMjyycFptaXngNzPWbP8v0/iE+6w+kBYxRDB+epw/bYqjUu2apD6CbHOaw3ZRHQ+PaRA0EW8TFOSgmhH/4RZKQX+WHs8f6/y+LOdiHk+iNxgCfwtBpfF8ASH+dsk/jqLXWJdaV3KZtU2T7dG5LjJEB5AEiRMW8lIHwej1RkuxykSBAGCVcbAd4UiUpgM1ROfaSNzxoIxA/Ih+IY6cWWu2yuu+A1/7xkLO0wPdtuTPtqzC43iw4G63pEI7eoApFfdbx04+erXVhq+8mHppAefizB0HNj+V/Ta7sj/GQ0KaJPqkLceetI9MYt/gElGwqKbtF8jx2NYxwrCDT/huibmHHz/M7Fa5ADhks+q5s+FEB8KD9RhUuqaehwG3RDhmqDDvzIBn/CEVHOTGI8SUGw1vYu2kx6npjTGAPJ554BhlI9dPlh6bvXlmXHl2Ivz/liMM8V+n80uEtAo5FbbUmwHGNAynsRk6pDDr+GXYwKRsBEJ7wwiNiUWmUP/A3MXtLSoSG7cSsh8RT0Z2rUPx528M+O+r0JgWGwn2AMIeb7oqcyfMopoMaBcRziMpl1qJy/jLj7/RnkVbOLMJYIB0/vbQnVwjXQhzouf2nZQ1bwFK5kkjLcX8XFaqvunQ7vKW+hiLkMfuNaUG+vwL1mHkWLvwb1rm+OjJpydorDtW06N9/8GMT4S31L9hWrjiFU/Y5yVmGJ6trguhq+Qs+QoT5uniasnGgV0DEnz64cR1tH1oxU11fFDHZF2uRvwoFa2cHMBBx5myI30RBjTuyACl7zj2cShywDE3apUR2tB4JZiPIJd71nqF28XzIBYfAroJv1Zv+y4/+wOXXuiPZaFn/X/bJLpOnN93KViRZFZLSoawU+ILsc84sRORwrXKDqZdP4fQI73QqjbAyprjYgcJHXb2TNeta4e06inXCZW8dWRQF5k81iOGAj7huvu450Y8lkSyzzGxgITS5BoWnskSc+Wz1zk7cR64WsEcNAPEcAydYMksOTGB7dV759jkyONXPE8mHffs4NGB0upVHesdI7PeQrbRzbz3mU8ON5yXFqlZlIQdjNPFxV0aGTJmlSWvdL3dVrnrDzQQyRaXGr1E6El83Ea87LydVDAli1cM21VEpKMRzrlCANrS4wuLEPD9nXIy5lTeRBPIm7pq84WXTmH5CMBnjKXU8Be1ImpBaUIBJc3fgUkUSnmQn3TDTLiQuCixvSwUWF4yDVaWWUhs5hjOeflIVqCkLmeQVujjag24yXoTc/rXIKdgdraEiL4XvMfHvSS4DLvaM9aeledtxpcFlQC3S7i1dRJHpmz/e2rN5xhkaIh9MZ5y95P5x1oCIuFfMqmCgHyuklDKqDdEPbN1d94eQDHiHxH7yowGcp0mjG5V/C8877xwjABFaAxzQrZwypLFHC9+SwrQpSjVMHWn/qTf4u2UojDuUbHN09NoPxr5VLMKFgz0lvjrqwp2Cv2reHcPzsEVrhnOyCHh5y2nMvxOZKr/C7v18ljQXpIeGvmDRrlo0J7uVlAwrH3cN0vKMFCDoWpYXDMg9DsCCc16cNXq9RBWujZEuqlvIIZ4hJyMWtf4pyYRIeqSjFrvBQLGo013fuCq5dCgkohrVTHIC7E2yNRQ7HAgUVbc3WjEIX2tvnLTuqUouRLojzIEMwpXli/VSHI5NMr9sV4e6IgbmJL693H2VqLltY1cXPA/kqInZhFEk3x/2p3dMoCqNTXSZjmOM13XFLYWeu62RfCCuk3GpIT2Yvuv9AveLeJxaKsq/L6KLbp1U5II519KT8dL63PmegMIiMZdYvTcSzWXAO4/P3RM8e7rNeK1jz8oajtxVOaQvH8sfsXV9hc4sSaOPzzxZ8HfGqMtQBouR2lIUbM49/QtmhXnonMAOOuxtk+LNIBeEsgpgD+99E6WX7LBTb+aG81J/gzHdDabRVUEAPdFfkwyYSp2pYKBd7BZZgZR2cdwOwgbWdr3P8ZBDdqyVGbR1mjPO+NtYUHSeoNntvfLMqxfWxOrQx92npc7hrusAd6V0LqCWGJJwxzJakNH11W4AxQs7YSLIzjjD7EyJSWTZ+NTwlxgw0PKjwLVzQ3m0seUnEpps+gRNZe56jDpQqHUtOV8c7kBj2SKZgyyUFY8TOHSCFDO91bBXNfxI+g1GIYkG30v3JtA1CtCJgMrIPETfMh2HcKnQHCABPF6IhmmRkoI8ZQlYw1bKH2GAti+5VbQ8vS2j2FT7vWBVQ7RotPh9SIvSt5rpveJw+eWCaIt75UQRjVgjWNWxK0VGng7LItwPhFelw2mjPrOziGKj3p8fQb5k55gP2rwmFUJfAp3pt4DuOhb5E3fTuErFeoInYMFhxK0WtFOMjL25zxv8E7LSukUMwUBmTCtKHhqTgh12Or15QZg5uWGrAHHjcKw7Gtr1Lm5NviyfVhozFvZLlgTZg9XVm5709ziZakae75s1qLRpAN38sT33ELcOlSKBNN7eeH+DJz7BPvuNfuaV7MUuJc7eQxWl2pPIkKZCV4y19PRd1vZBrgLyXjLC1bYt4rl5WjO/K1RV14yYxFfVU/llRdFxvVyh2bCXYfWmLOwlkGtstJ0U655yaO2NMjpc4MRL5FQiUAHRCTjxzsciysPtm6P4A9hDBIPJ2s5UXWrx78FX8J+KJ98Wg4xk4RYuCszAjvCdvdKjKH4PPbbhn+nAvKPOzwfIBODgtB+YAC94dupetMRavzMU3dc+Lwye8hEvNBeNXKb/ad7NXffRTt4MN3ivmKz+cRb+Uv1z07JLDEwZdThFPLEUEORiWvpxct6r4xKNTgOBNDp5+pucdLCSZ7aN8733xZxjUQ4ZWm62C78L7TDIcKCKtgOk9DVyk575Camkgiyo+jnD+Am5Lc2dQUZiUbilsMWiH25hhK2lmLNmmSfAFAGv/t5nOfZXPnHXmFl/yJGOip31KqozGfD9w0BNoDIT3XGuHllvu3AaUDQ+w0lkjxtP0z3euHQ876EVtsgz3OY942XBe1YbyRMhra6piS32dzBwry9FLLbHDJOjOJKub5bDj3qoGSEKUico/K3s03HkO9AZBofdz5JkkdQVQdjTEREX31Tf8F1M/tglyC0BO6RCA0FPK+bwM6/yn1tYiP5x/3TAfT81wslm5xCyrTbIxMCtMtMvU/CVk8PNb5+/Jjre/m3mpNH5oInHmZrUjgGwy9muBrHVxvyAucxzY94VSS/+IIA/OkzTeiO+UDsQ8NvdnVd6lWVkzpeN2x8nocvMk0TsHxl3/M+ouF+2u1ZO4RvGjD+5XD+hSGdEu2x8o28nPY+yZ3ceWlNMO3TW5Tw5zRzRGWbRqWJkRkfGcoN4ESTruqDV6HOb0hckxbZQ0UIXP4KtJZNnjliwMWfiHdhimYLTL/CQK4VNtNG5mfjyzNklw0brrDAFcpjvJOXMq0qYFf2rNNI7Dnn5fPyOvMekOOlKGxnwLjPEBiQcwQ6WFw0jq9xUeG9k5mCR/C4ezUQJUGdaIrQU+J7+qa6I9lETJt5ZErXXFDFEQ1dno8TmjrPDF0hupv75qDFKb7H8zfGhpm5bW6qBVNk1FQP08xWsNn9mJtBXIsZwjQTKMD+Ap6rkIDqtK8Cp7nmIkQavH9B+weewFYyBmoAic6xyMcmLsbq+Q6qmvVoOOHbUjPzFHM8kpDWdaajomwH9x2Zm52gnMVEYB8G3tYeUr0CumlhP0QqpKkhHFeTtH2jd+MIAAgrxkFpR8XptErm0y+NZsHnNqbef3UTBuoTSp4s88Fgm10UsSlqIsMC6aM2rcQos2IgXJfn2NAHNGSEhXsvWfrudhlHbgwJGAelw2Mx0909+mltToPpfwfQm9c89bHEgf/9h3RH4cpM7m5SbuP+iRbsXVz9ifyr9ZSWK302Nt21tkw1TGq88PMFn6nohlfwIV5JJdUI7EgWNoDDrpfzaWiAwn0HKlaW3gjOwQ68pL5CigqDWAraXvckt0V/tGJR35onEVMoJxc3Ltb73SRLmnrxsyq9tCh+a6ZAMswMWHK3aGp5pu3kilwj5h6hlW1PHh1hg1MmXu2zcCdTyg50xJD/Rofqbee8kEnWjuhXgezrnnHZzbxvQCrhbpbydNqGiUZeVVO0O+wO5zMOIZ73EKwiRRNgYS8G5Rx2lxJhspDhn0Keacwlahh5GAB323Jo2ocvdUFq0ePHvSBwNxBMqUCHXdZI+xzYbWFBFi5vXhdbcQES2ij4vNiCdDN+dpiqHxN6rq3rssVU0B+B/l/DRCzOgvrAzJGRzxx4Vv+Cs0JBOW9OEP7KxJ+HmGpOskwQF4MkBuZk6HhlzBeWM5HK9KI/jYTqo5U1wQ761kg3bRk56NJgCGb4Lzj6az2ESqYWvDRvD5hFTDm8zeLQDQEwYo8QTMH/UY97VXRsqO2HQzGPkbcv2C6GpZ0NPzaWc8AjqjCWGk7/dwID1UGRgYQgQYr154FnKS5OOY5jAlK0BT0GHaWBnPJeJfa4AxDMNn0gV+zSSC1YyI2hlpyZAz37gdJKr5f6WvOmRkJFS9cbY6ep2dJuauEh/htM8ZSMPPbJiTgw4j2Xr1drwr/ZAf1q7roYsj571RaM606gAzcWtycf1iA44o7jGmODyFvL5T7sOqE0Wjyxm8bFADaxFWg4EMiRfSDt1QeOlbYedAaLmed5Gz+06PydcZrk3bwYRIUpom9qWbHIBpE9hnrAauHmscQ3cvMyVT/EpyTpIOr7Fk5WrPa9SKyD8Kes/QNVN+dW8wt0+wiDjOxZ43CkhKYCCpc9FzZBouEat79AbDkepPhfs/Wuje2a0tj1DU0L1Ge6iFsF+60i7a0kndul8j8tZUFnJc8RKh8Ykf960blCjkb9nrUS4tRtnO+MUuaWcHLwbsZFpTT/7FnTL8Bo9hwrdPdB9pcPJ9jOsqIjY1krHMIk1FR6qE0bstGgwZFGo+UrwOiIoN00Isyxzv8Sk8cNju5JzLfTp0rlAhOv2YILdUZh1JxvzaIQPK+blOuFDvzIAeF5yl2iJHb6Ud45ROJ7XS4wBK9QtnKfQyLW32aCikhxf9tnQJi0IilNn6aPF613diVnVJS+sh5ojZBG2RslDl+jmtWvspe2nB8FFIUhd077tuPEhctlxpZuL8fMMaHMlWhZqcHvU86uAQmLEAsNPMafhin3pvQnNCSzlEQm02wXA4AOCNb6SWSW7jl3DaUNVSVn/60rTGkeLxv/38LOyEVWqA/Shzc0ZSfataZlDFKoSY6AQ2mP+zGFIUaXarGCfkdRgVJC1R50HB/8k/+gOjDXBJgI7M2VmJnJ8+udVzPWqiawMFEpS75VqsQSVVgQE1m0y7kbpRBGjXiTNUaJY/JQSEYY7l1h6wgmMYff+i91TnWUfrmF+9u3reJ9CzTSw64B6OCCiSCwo90VhPKy4ZZVXKHDD0zDNuv11ZWRq8oYJdXXohrr5wXu3rIB4twfd3rxjXpqbjsMi3zqNHDh8nRWC0iCrMDZkh8hRYaciihCTRxQE+6UMiRplu3nsF1CgO51qVOc2ihetbCZNaKPPmkpL29GD0tkLJ5DoCxJTItE3+TlbOG9ahM2W6F03OdbO6tE9RGjvvjylqx2pXsWwTHTQSgYyzrxWSBgtkTN4yWMxEhSbRXsPfBG+yJxuFKqtnIZ+1wJ59yU8YoODzgv0Lj2K4EgZakn0eNIcHt51kJBIOWFJ1YWyJ9qPz0NIVZpG8UcxrNrOSNhX3JKX+KLN0A9xVXpVo8LEoKr/9mChuZPcn3ROf433febVpoq4qtw2w0rCAphD/raj70wlC061h7p38NxavoKQDCs+Q15VbEw7e3+1VQ5aTdfhaBfVS+wBjKGVemP4nrNWg2jQvxBbRI9deqIV4VnHilVIscFPw8lUm74NjCjS+xW/aK2Zwi1Xw21C1tkjKdTxm5reHHy7SZEVlMq6OQQ1UFBn3YLiG2rAVcY8QrUzi8QqlMLOpFYtTFC4eNBd9jExEfMG5qFt6dv3S8zxfJlGaiNDygZ3Q/8vupbJqVnlk1kw2OuZsHY5E7JIifPq2SzQTu6ETyF9TyGhYq8P+IOc6xrtBpawxsFcJQkUzWKcJTGZxltRkkEpKreCBAhz/0RVkq9Pcrrse8YH9gxbhgcZYKf3++XfYePsxr7KC0H7RStHibZ8HyzXr2edop2F6f+s+//BLZVbMr5PYO6/0LCkByWxsF5t7wd66aqwIiDSiKq8kPzb3m5d+PNJ6osNk6cAoie+r7T6WdLGmrNoePmvXer94OFZFNaYp5GQgab+NaVa+mz91SGl0qXZ8y5FQLng5H4+ROYw3T0F5fiyFuZeOwx1vccVff7nmnEgo00zFMVKYGc+qQWB+WnpdH7f4w6GJ7lI3MUJPWFwvwI8C2qRYrC51j9KrYJax+6gzV9HPm8/PdTZavan/9yxRkTLuESsTymwwCsrGHwguO1ZjsEXi7TFURy9CqLn8ahk7AnWTGqUqRiESq3vOUCwq6RLpITH3fV3KD1FB727fwgix3WvWyz75GuNxaXUQcuE2r/EcXmJv9OvL5tOUHLDb/30RzBKAcR0tQoqcOuiNM8TaTqjT99Emot7U5wXjd2BKftSG9H8/mcUWOXg5DDY7QU12i++Fuvht+X0SHYJPp/g+mZ2Vncj9JOA1FlOt9oAL9RZoo/EVykCWabUx2lcOo2PiK+qs89lDGFZVuHZSaiVNPNzikR6m5eWulvGRTawBlnmjH/OxqYYAC/ABHQ0SETdgcqXh2RxCMpbjrWnDOmRwMmQp/Cu4pJJMMa0cG9oeMJ9JG5OgcYbTRC9pWEuVUeRH/i+dzoFeXCJlihXBivL0hnyofv33jK6hKiEx0lqfeguS/spH+mSlB7NRlQkwsIshR4qM1VAuAWnjFvSJ8bTZ5Va69l/1nLBqAU3Tu5mGRUnAwK2y+NvqhPOY063YZO0SnaURLcC9wKiWERCjpX85EhVWU37Oh2C/NsdLzqM3Qv96w3VYPZ5aBv6nGxyPqmxh5jScAt5YROcgQwUHB6R/dIaawFQW2QqlRyj8Hx3yXVj4LwjiBEjz6Fg5vCfB8ydgr39KzOBKNsP8xAgo9Y9K+83/D468sa4+fT6KcPjYtf9lBVjKoGBbcF9c22/UiOD8sPvxiQg+vgedNlGyRjcxXz3JO+QipHeqT0XPgFcfT2LgZJsGkw45fvMSwpTzw56Ltoql2hjHm/ehJ6XhpF77qVA5O/B2+R6Fva4Px7qbJFo80QPsb+aMgDGIAya/s5I5z3Y4OiguKZ6LGdNYIKuGrIY45zOD8OuqdZkiTYhT9kIeFu4kiO54UqlbD5TPMIAl/zpreWX5zGFL/t46jnbWySzTCkl41/A9V8U7jCWiyK0RHL+krS0dpupzjlXWRKG40TWU6zlWTMyihsGzIqSsNO4ZVyFewO8n4isZ7cWOOeta4HtQxv1pns66dxzcpQ4lVUNm+bO7Vo4gjHs046H2jbI/+EoHu19KfB0VMJx6Ra277QvgSpWqXwb7NHTLZFqvrwjmWvmKtBZxEHcmvX6RHc5Ns+OKqeBRdnrD6hZ4JEXOr6JV/LPNslkZ1eGHQ3sXoZUmdITPrhrm8n5SS+OJDioJgbayHV3RDaNivpnJtk3IZv5rEXzRUCAR9VRBq0FGPOD7t92SSoA9ebTt/kbtJ7A2dYJGuiWrE7F6RyshRIMsLY5gbFIgzKf4y1H2KGKEz6jvTao5MNd2WijlDRxz7iXwxfDssTTyWUdZdKYFLUuuy+5mNALuUiXx8pqKgbyeEs6PZVjr+3VASfogZ9+E4w+VV2ZhaZigi6zTi/gXauGCESLLdvKEqER0uC21P/B7kRmHhEfm7dquThKjnFZtQ+7GUg7Fx4ku1o0uK31u3hkjcDwn+gQ4TftoIJnC+0Ow2KCra/3DkE3whENtdpPSNcZ+cSmn+Vct09vZLqMRftnixrxqI2HDHON1aDcjKUGNTK9SED2dx8gpkH0+Uu3SflMjQl/L5uin8TnwldUlyrLnECy9v+8cpse3u+E+cq/D/Noa9nRDV3aL7S58SNNGCC++v4UK/KyAh8a70KS4m+fk4PTkVfKpisKi2Y852LvbJh11AWfUAhfbhAvxdSstvPywaxaLA+1+AfHKnJ33vK3Ml/Qu26jUnWSaapJF88OvQd8vNNNy7+3NWNxqvPEShqcExVBMq2MYwsl6EbLg/11t/lASu94rruUnaKkLwXvImjeE3OcojRTpb3DNRkeBnwYU9IOlL8RvbIV43Syg6U0Psx+FK++xe9CaZJIPLQaFAkbawrBEStkU1pETlzc6k0nDAaaYrYTkx92hJ4ov0li8HCo8Lb2oAEPboydH/lF0TRTqEgjf5nmBCQS/RDbvDVJzt6X3/EOy2WglDKPWvzWR8asmXd7Ohgnw5CXJY9Ddp7l10p5ZIaumpQ/md6H3wDMX1Nvmv9haQbqsbbA3Lx3bsHS6KnrB8CwQYF7as8UcMJzN1o1H98oIUOwSGU+VAfwvIKti432goDgi/dohbSA/Tr8LaeetZ9TW0hoO90r7bTn7YwPcS8dctUKLAm+zyXQJjjMRHP0LEIWo2suZ5RBGowqO7KYZrCG4kHrXrHFufM5i5YJYeT/36KZp1JMYZSyfI+USIbzk/YP01/FiqleMpqLsOplJLV0lfLKmyYGgz05z65FU82vuOS+t6cm7rkS8HIZrzn54a1yk8nAyWj8ysXpSjw0yp6jumz6RUSmgVcg+y0dR0v0i7ZeOpoFV5tifknmH66Bv1NZw7chYRWWeHseIV+w30LA7zS2kHTus4ox7jAGidasnOSkvdvPd5WQviTyUtnOulodfxampkV4q+jVwNAORGwah+bdUIJ/SJ/BXsVuwrgejwTCKNgPsia5MEmybW0l/TtsSNuL1MJBwgeTxFa0+4x3VtmUWqx3DTOYXuAadbtUWGt548rKTtJy7I7jiiEKVaahlc4faiPCX+avHDsY40gGZfwhSa2oCrFgraZkH13h4wbmbWKF7ZRNgHZ8tribIh1L3V1sJnOvsfO5OIcStXnAr2d75tw8F6TXlc7hPl+hRL+oNWz7ACzQtsxi1B7skf5yhPNMn+tCi3aOTjxAwLWCW2AL293thyptRHCuGt9pH4h+zdKox+06l99W86397nQzlb0YT1HqvqK6+/3/4XdwE03mqmIfoH4YuO5XSJvsOsd5zAHV02KiAAk/XAk7glrcrocgvlOkSysXxDQ1U5UROiM7uifBsyw2pYx79TU0ayAzvRcMg7jZqS0RlRpYZ8E2yq9LNGXxHhFUFy/6Nwy8Zej2CKgRxNSWClNQKTBjKkX/dumxMFo6EjZygA8apltmS3nIYaW6gAhC/XLTjkqKdfyn3NLsDdB/BfYUWiryBE8JfmQPVF0DcgKKZBoiNPjLJP0Q8pVjN2lhZeULO562himXdVeQ8/fv8GhIr+k5A6bCNj/52YmGVtjH1wdSrhemzedPGJ0t53GMnKy1ep5T3AAbyS2oVN2iNniCamFO5YU9gNWjie6DbrSkvhNApJ3MILJQT+LFUKeC7LseL7Zn7ayuIV5oPQxGTtJsbETT456Moo8JwmxH3KIjLrQ9RpMU3WA8SW7D8sfm+L7oGA/VOQqcuecSXZHqHvyvIWrtX3SozuvFa/vGmpbWBeyMLqa1kcdCZQ8bfG3nGN2T01N9ObCmlJa3n8w8B0Pb6iSJajnVBq+LTVpaATbOHIQcPm16KiIYiUUtvf1utdP3LyvsoDRWRKYY35E0P5zQ9ITOMHKOWmTR0NSq2KY+I+i+9MfBfKa7amhZ6/dA3WjTLv45SPMwmKBt6ZKLB5/G7H01T57AV3pSsW9RHEQlVOZhyNbg3y6ypPerFPIdN3DE24hE/47pttiVzvFAbK1J8uAop+sk7adgmxZsVXfSXTDvrvn7MyVmYASlosnWAMtwVNm/Bk3ren7Vxbp8agPlj2swOUiw9HxswWhFdPiF5nIzyKkDoX8Fp+EbixxhepaY5iX3PABvXf0cpJ0p/E54IOxY3haJ8KDisDAT5VclPmDObeLz953mRvA+G8onbxXdRxIk5vPyqu7F+iob8L0TJmBYmylHo0ZZ7EO0OeLgx+H9CfBjYgqRYF6OlkvKF28yiYK68TwLL4k+iYjDMvp5msUxjo5a8HedwMoq5/7LpFBUKYAycX5yvlK8paSjjte5+mfTlvb7n2MItF3VMybwNV4u6aDs4xQxPqA7A1KUE+WYxT5n2So4Lck341BLlWO1xR1VfZbMClf1KN5e/avZsrU2O0C97Mir2UsnNk26zaTw/z8+KMP0mYhgHhlMwVGcF1JXWMzKsZ8cS2VF8HU8Z23HWkE0+r1Ots9s7OjdilVvZEF3TSzPZEPcSvOkb4iRXRcD6zxH9uAWf62XXWbiKQg6razoyLUMvH0brlct1ZI8wkLMt/o0aFl6Nv3iDs3/uYBxFvXP1ngspNbQ/YtCJPqI7LtbviP53cAdfS2u3y5ifnO+lKNDwFe0PmYwhHpPCNmUEz49xIBHg4NQzehES9WfQsdLxQo1INsWA9jq5aayp2g5PNy11eYlspum00cl+wgvXN6qO8UaLKIGovWM2gpst8wioTVaKvIlGggfJUR2kNv025t9/yN6OCLCtWXM81JcXZZ3r48FbAQG7Dn39fR56cbcawfTErJErpUIWhQqWziI+7J6mxwyrFb9BKrafnTl4XdYCInX0kfIr2h2BI8NUCZD/qAqZHFV1VUrkL840Yg3Zakp0HCI8R+UUCffXNtXlcBiMkbZAqeFcq86f+HFhJ/HhyaEOOHiBLfxUWhlgYmrSM5upNZTrwswjdIB0Ix6tTCmvWJ0Ts4/GyoC9ifumCQufug6BPy6STbsa9OT4gMglZkawXqPHMT48aIzdnX+7QvYb1u7G29sxpjjBZv1DpWt91/oS4WZ6Ewpe0FyCWQlbHEi7wNznZc+mQONx+7cn40bl3+pj/zLmT+CBp9svYhs17wLHa+U6vRrb1Aj50vZHDLSI6r2n9WOCI/gnaNKNyFn0zMkTSopNF6YIwNRk150kjujAcWRxdKlA/fQobCkwCjyX/yLg1gnUH6voLsUHUOKnz+J4oKWPDIBuGiW1lghjBsNtdNwS99I2rRVT4adiX0bA4txmUYyQ4nJPHRg7yy61riN5kk3W3ViIvJqBtabi8l6vZ3jXKgFyRmC1z+i2AECXUkx3xECrINfTTAUbdAdDlpQZhNrV8AzSKIUdRXPbyPV/7fiYTmpLCTparVr73tWGICjCpNiIcjLK+Kq/hxiyR8/i28I3mp0BvQjRfI5vzx5cFRAJgB6bg9mLk7CO2cdbtNJbxB/dx68F/0zfftg0b2S9Y/uapVtgyPiSYIjCQTDifnvo6K+6juH8zL6tK03RwqP5XwNp2gBfrjZt0XPfpE1xuGrSsbWT3Mi4XKxDS7T43j4Q1c819B926kfyQVLNYEBcD5Uu70+VirNZJFb+Q6rh+f0bWkO7bIXA8ezzMGYt7xiGJV46DnmDm9KVbpNd81PZX2Zp0xwa9YICnLjARlO9RDwnuNhClKdkyRRYYVcnrNLoZGG9GdJGgtMGusY0nH0WPu1aY8uWuZnN8PpKlMxqU8d2fxPEmnVNGbCdtSo5AksS0n5qqQQl04F2dcGf/xV6SXv/MK2U438x/CLboxhXpR74/5i7Csh8MPcbDcmo+UxZCVh6HRrV4kaAwkqDysE/21wd01XWpGDt9s3F4CcR+mNcSazMhCmEC+9kPVroIfBrTGIFaA8qJNwNLKIkRxlTC3kvjVE1IplvQCbPhhLtW0zd9oeeZnfuO1fn+wChfdQl0DbfSFhCSoiJv4RssheVqkfA6ThaZOvVDuiUbqr5DeDEE48bTRZcj6t+qLflgNSvPqzcA0FxoxrQwG/ddiTqc3ep4/e3oHygswPVra2cedRd4Jk7a4gseD750opD2zrGhAn2CdPr1ZvlZ2JTuBHAZBHRXsr2JZKvRyibBoK3Dn7mn167isxGlmOC6Bo0Pn1K8TzWzrc+wK848udFgJQRsHkgy2p08lWBU0nIdB3fG5gLqxaVK2MyWhc4Ct+5TYuFT/+MyCMH4uST6+Mx7eK6KAEQSqSj4WIRVlAOUiQOFcZcGWujhXz+ZqfDCbhtwyV8uDo36gAnKoIeKK8cMNpvqBsXXgJg6D72389Rcf7/7uV2ro82h21sf17C/IZH/eVZBpQ6vrUxhfYUp95tC2k+ZmGaweytjNR9QhKB4nmrBZN6KwDfX58dGxhEkeC//D0v2E7Rcgo/ZvjmRQPdmJfc8D0hyAOxg3FegQz+rLp3mohx1Izuzc6LbVMPn3knqP/UskJ5of2N7Cej9S/EPL210DMHf6vsyrj0PqYJC7ZAl8YE8Z23QM8NfAKUG7eVBeNfguD4iQj5y5aK7LgQmM7HeoOD2If6siG4xUlE0pk09m6UIRyPyWrrGpDEbjQNReSk/COdIyduoeQrxk1QA9mudz9QGDin0A/6JBQdurKQtE2S1mpkZnaWkZakIpOb2N84voMbDIDV6hfHNa0F7dJLf3zPopscztOLbmZrObYZQSwFtyIrlJU8tX6JSsX2VP8vWfgIv4JHf8QV+l6rBuMOdo8Xk+Vo9VWXM7nDBqAeJYXXKvR+hkh0XCm2ClPEX+nvzcyJ8gZCPgnYfMOp+QeN2zx9o2TWL2/JgR7Vof0ht7WeuLMvqMQmniBCr7as2BVb+F1UiSEUJn7oc+czegsdYS/CD6yAYElPSyTmD6morqZu4yYcX3EHdTlUfjVGONoZIAIGsf4s7W+x+uk7CDQFmj/mibULQLNN5sDbj91czVHKfpcU1th+Ne55PkZf4v+umhzlqaU7HkdlWyV/G410hq6dULy9INNkl84Bko0mRshD1IMujxMa5mLR4sunR6h0Mg0Y76TwzSIMu/07HQqJ5Eh/46e0JvkKcR8BLS/+31LHSPxu/5wxCEZy8RnuEqJ3jIbD7Idfe24H6fxY5Bpxa64gzSwmq4Z/t0/9x3j3wKb50Qm9wZR8j4jY5bhd7rfvDrS5OIIe0I/HQKWdMao3Mcsvf9LM4Cd6qjEJRq+/JCrVMAl1dsWXZ1l3tlhWKNN25CXIlDBavTS3bxzIEADWB6Gp7Q0Aas6tjJoUPsMWZBK5IRYV5daG0uAzl7Ojt5sb7dMh+yokxyg4qrUgCikV/LRb1HCFuywkuTMM5XEEKNT0HepJMX0xTcVRdQ+3EEcsarPyMkLA99D3J2Xkve4HAxk7snoL0KWyMOWJmBjuyG8C5Po38rv2YzLZ/5bKFM8U4BpSnBTjuca6MfvM3WeRa6h4X2UVpTd23LKf2so3g7qCjiDsqBDXMvaMwmbDGIJ5Apl8il+KksM+HnsunbcKGHsSsP3JkaIOqMoDNQdil0gWf3tDfh/JhrPFS10mEMLPulm1Ttd5oHYhvjPAkkIMzog53CZE+CCdG22srx7aWg7nWqtJ1cXu4ZENAMuUK0jy7vVgc4zpycHk5v+PFiHQ4ZpSHyjQh/S2IHeLgMZMZqF1hFBZ8bSnb4s6+k4MA4CCLC/2yhqcRK0ol3PztpyIiyHXLYAMv9sD2a6F7XqlVhPEyVVZqK6jE2lMFyiUFXfqaSFIb7oRPLHyXBVIj16DJ20mlhxrO9pDoUUPibFEPgjlZh5qo6eHYMEeTr4TsW5GaeiYnihVkGKhR1aTGvdNPxbilTB2GDQhw8lOAnncJdspG4oyim/+JZi0zILQFo+F6khP3j3697YkJpMc/TlF2uHcXZ1w/KeuYPSYsJ8MSfN2qmB3rzEdg8GtfU4H6l0OGmoUeb4tY9fdYARlkgF64xxbuuod6jZlzkPSZV8lw3XwrjuPfSYwAw+PDV6otZHKG8hWF4dZW4PgbewGC2K0JTfC+V1DSJnGEZowHcXky1HIRQ/o/cLPOy0Yg1XiDY5nrVZIz7nDIqn4ZA/JMvgwLUasRv18lcEqzUagn6R6N2C8gXz8VWkKuPL4JFS6gwJXcvW6NZ0fnKB/IZrlAs3wmCTFKhh6wub5UF/6+QVK/HSdpvmSqABYha7l7AZ2IWuqDO74HtsxCP6cMZSxb1+VopyLoaBBRujneO+hmzvt5pfPWE3ayEL19DKsUH8rlVQnoSvU4sZAM+FLJ8CpEjmFFog5jo1j0eIMEG3ZWFavYxX+bOXXgFj0LuWcPLaDE5VJ8CUYyRh9O+HEG5oIIqTDekfWex67XQm2QKYUVsHQqVV9UGL3LCOGDNufPpqsmLM0J7JiHP/n0wCgd5azEdjWLy7emJogJ3dmFZVKFPr5iaaKt3UtKp1ofz5nu0KBLM8jHwyBJaDMMsXwO/SyQPc2rej4qVtGQxF5hY/NQx3Pa98zdRWWR21sx4plyOCgvFYEp2KHx6bCQ9W5xOmUZVL/9va7Rv45s5mzPs4ccYGYM60v6cEWH6xZfg0PDtafwcjBTXTIZCvzK3VuLXA1NN+fGOksrez2oKrcXEnHQabhv6MEN/ZlYoyGCV/8NND53yKcAaDS+lCjh4SVMAppS2Cwa9JUT7pp2lZQLa0R7qceBpOkSdl45pgxOezZy2d8jqt9xRPMrpkGqjPe2hrh01oeIUYRjYHwELHYzAUZKqmS1/LNLsOQ6UuWu6Xni2wLahANpnRlpkPHqLURc6Y8WIB98OWvKIPTNdEd0q3qBXIzTLoiPddA2M+uNWobGhVEoTb+ipADU3e5WKPLQ+vdx7RJxmDlIIdxMLj55yXSSoo3A4jkk5ABPkOH3ogOnzEHOSWF3NlOqe/KCx2wl4pjzPO+vVNb+mjKTIxYWmuLVDhkJvV7WdhZcuzHR/a9dJc8w1c8qrGlFRBElbW0l0BaUlxWoIUOCKLmlgXyyXrA0fiol+JJaFvAG0j2yi2dEcp24fj2tlN+iJke62BXrh8mVyoHkNtrBb4Al6n5AUTQ+f07NGE/sivoF9/6H11OvfnuXJcBk2VmhihykAWeI+qmkJ7Ldq5h21zWwFm5Lkxof8nPBvgXMjqwC8/TnWfKZjI0H9GTz5f68oo+6wxvRFghkM5LNBz6auL5Jn7f3Vdj0Xdlg+dJ1UmCD1L3uNNSo2RePRAp0MOUKNOT6+qz/HyN080CsMPhiQJuxSsbwhMlYASzGan/CPiHZVKl89XrNwnlQzTLsVfpdtKPutIyYCU4ginIKWDenEaEoAOEUfDPDfq9zMT16Vm60lw5GXkp7H89fZzxBufkCytBWAIrVf+BIYy2b0dBFXgKMoWD/1FbhVnJkoFWixMXA6VprxlO8M33ZeLAlnpM3dMItzjcCWCFzlpn9bvcjkDTJQ/59rS1RPv9bWAm+qdyyNNOBh2zowvSAqnGLBccGZsjxm+/swUFZ3NdCEi8SdNd63eqx8s24qp1tOyIC4md7RkeuT7ByQUZFtKjl/DGlR+9Zc7vBaoKeDRxghTQ1PhWDRo1lPD9AhsyWSk6zssYEA372l2egDKkHojVbnrxNEtnjyv0JI9gZMxBsaTqrVSN27gKtugkSTqCBtaOnXGFt3GU8jMTneBZUT5z+O8TZQL/3n7SlqLzBNAfkC6zl7yZsASeRMNY+3TPP9KkxFiBkFxFcFS/iCCBkCFWKO0aJES4gWNmunlXDe9M2Mw6uGtr0LyKrz/F/wmXnfdlP3eRpjfSlWam9Yy22P8ihQnnf6mXDYU4Pj4k6jcv6HldzQB6oqD9DmfZepacRe1+4I3qKxbH5BDwKPdFQLkjj7rCTNq1iCN6lCQY907z/9Nqi0rUAfHHWM/ACyUqkuPn0ifId4yqZPeW61nmJ5rIDMwxkA4O3E5Yzk9tme5SkLFJe1dTLgOywSSVp+S0FTPSYTJIICkYz2ymW0JGYoWpn70+2fbcD8/GWswwzzofVmHiQfSOnyP9RfhGvrSxvlUCSuMds5WYoNGUnNHAfbxTsitA7q0aNXcghyCLf47UJNqFnPIF7vqBP1XzOYqj8hgi2pbX785ikM4OFkrljHJuunOTTL5LOQrFo+hgwGDssWBk4H3/iIE7z6zBsKFQiOm7qfYjLYH0vxvhCno+ho23jNCCzKvs0BXelXjNI44DwiKApvL+3FcLHk3fuSkfoPE+qEDZrzNjjjjYrjME0Vka44ikZxctj+NLWxtRr3mfj619PufechtDCqq+UdaTARDD08fnA4LXUqOB/+lWgOiMhG/620F7SNvqp7EdAzs2ZNE82Yz3+31POiP21HwMhJNcxn2CgeO0tnfQRZpxKl/9IOPqx90raZmq2NvYdfg9gIoT1hHl6/UXMuBcd9n8aCduj5S7ONrVc31o+D+cJQxVLJHRQJ/O+R2xRy/bnoxrVUdBz4of+3CUl4k7WzPQEuxuip7h+ZfRI3SdE7wqh+BWjx9ISEM6FSeTTR/Ju4DPIc9Kpizi8AuDuOfntODtqwNg2ZRHzs19l4p2/asXLNt49JoltoyRoLPF8/47dpvpeOAAbZWOYAN6E8nrvkwAw8v95/NfDbyrXMQxNp11e6ae51zbZB3/wTxnl8ljI3HtJywftLR8OZoYS7yKVWRB7rUmHo8meTiaA5PA1F0uskloIHdC37Yta5ANifPqFaz+nSly7cUro6CpkxgsZFg+c35MIL63noSdEgs2nEoSHM26T4z+5c2BzOyQvG6gWjudUs7FcDJxJqnSuITMv2Bkk31+iIkNZoOvTbtIkK8smWUmNuXVcqziYxNaBleFNy7BTsCCD5QWLY29vrc65ZPPwxja8tR0GAf/q6IQIUsD8cqrrzpkzEfquEVz9ByQ2U60okKSOmzqHy1sav/kw9gMnGXvNmYZzn96Z6qGPN6YntNyrIDmszN0epFgVzzsbo2F+i8FvZ4QNUdh0nBW/KcRtBvxzLn/hS3kqcMncghuzOAlcAeBAzKhiRvR3Z1hCqP1ukrYRtkFKRS9HuKJhPkscnkx5j3+JiWHyx1tRDDfpAo7NYYp5wZAwmdNtNraFGRe09YN9kkzbfKs6Wca3he+x3p2t8xAkaxG/p93Eqt3tfO8KU7cM9bCdZ8t1X/oz1HgwTGI3+CBFCIT2hATSjnAL7NaO7nxWHTjzoqsFPSmH0++SnDNU88fO0inARDTvG/ui3URXN5IrhMfg7dhw0AbY60Dudebb5Z/WXbKRLO/+s0vSuAAQRu2KSZAMXmpR6j/VcYx8p/pj0obNVpb/Lsi5QIs1WqB+PIu3zQ9VCEQFXqiyC5p69GjwiUA/al4i0LJbSJEw8xtWT/c+iGG9HqOtxdkc9rzNecgiY1w801zf2K13eFwaPJ0sQ2DwJuxYnWJ3Zx7XY7O7TiaP975aORHnxCHN2QSmmNK4uT2Kbi5Jp5ISbLQRdogjoWzSfyCWN6M2pqqEFMmsXAr7G8+8O/oxBRlXCx3o5zD7xnhHW50XJI0N592SuBbIE7Qm9HYYcHGes4uxY9YSJwNnzIfba359hiAp9dGlnQ1Ynw5Ah5I2xKIfPXCM9hEZ9gXHlhXAIEAVqkCO9+WFoyUzF8kqUjFfoW2rS+R08zn0lyFNVhd4+PPtALkZWtMCY8wDlUFVvFk1IC0VOmiRLCDScyG5IjU9iucbXaP6mEwXgGTKViOj8rZ8Xg/FNwv5qO1CxfCwwXL8asQ+Q0olt3PJK6t2UKlXBE3rqJwRGDq09LFtvxNG12K+OElodAAzDPv0m2d8BnPK1xUI6eF1pZ0FdRQ06g/Dv/P/BAhhbRZQ5S76Ko+Hzum6h015KH7Q3U4O7AVfKgbl+0Nr4i3AuYgOtJTnIomSE5XBK227vUNfytmLW7tzetFsL0GF8g5Pc5GViZsP2ZLRMdjbt156Lplj2VuRexlMHFysiN3pwDtZqZtIu9Y7PrxcVs45SYR8f54Ae0OZutmfE8jXp4SGYmSno8GtWZs76+q50Z+rMmEJEBRYN5Wq9ufUB5mjLDndZUkpFwSSvLDIjAQQHJacEaIbLVVeXNRCa60g5rfAL6+k2bNX9k4e8CIyvVbY74eEzOgjjkm9m2/ckgQ9l+GMzo8JlR2S6WYREffJYbPh73WBxPqkq2CixwZStTJdAD3FpzqmhLDrzLZEFsRZ+7ctUCdtJU3ZqMq2P9jf/wgr66u0FZctxOmteXUmEEQCnTN16qXNMzZxICh4uiQxt38A3Kt8EWXkM5NJMglXbyXyBo4jZZBY3qgYu1R4YW7v5hUFSKL1YdL8n1h63A9D38khU83+Enete4ZNFGpksJ79/pYVab1TCkgqw9g7o9h+LuWqkgFTckc5h+fK47YJZzQeukNCphNchi0XvWND/m/3ZITmSoXS8q2pGjwuNIfiFCIOKrY8vajiPrl4o+9mjumINUhS6NFVjHDfw14GcnoDUaJ5x+a2HrRcVWwrEOvSssiqLuCih41rVNEDlNeYvLN9lqxPnhgS2JqHUkpzezcn+FCleO2uv7PUVtzmBtBroTIDRPi83gr+b2/UqxkpsJrQFi2mpMjPh4l/ZlWNymggDOTLQncshZ/3mvxMRZVfbAnzFRhbx1kYzmh4n5tse4tEuEdS0u5ibnCW3w1oM5mUh3w4AIE7kPEcljvsSlcvZvezxy62gRH9ThFbkbTpRN6dmCrrt8Rst1HsFkyznu+QIUt0SPOhwPuf0iRN2aIzFTcv5GfYhKwuSMuvm0ejFO9i6FVB9SIjN+b5VjcSL1XwPO0rz0MGHNtMAUsPE+Asp/jCuG4oWzKKS8F9mcFWdCg86u0gvcZSNsFKppK3GWeQq4LkZaurPkIQ82g/XHHF87kbnkh6JVenQYSuDLivmOiKLhyWAZc8homHROrs4e+ugNWKbwBoDCsQWBoWVATc9/LtsIRGDc4+hWG/COlRzskoB/2WAlolIrwJ9WmXg4AbSN8JDr2txJY9MXZYoIW0Yp1Z6UYroFqimFpe8ERJ7Mnjlfp90vm4DGpvwHuRTY4eY3BUGDj+br2j2JpSXDFs1pySbn3Vnn2GWRH9/XV4DfSMcDe9bYBqyUkNzU1voZD86FbNUys3DIGzqssfWTfB0DG9ylwHEpdFK2HwXu2NAahcsHydgEJDnyOojmFmGLbn1zbeUPnlLa16VBfR7kQ6i7L1K2nIGbtZ7/kYMta3qEj7DKzX9ZdO04c+ZG7sbf839wDDBvmbUFxAPB4zeYFtCLBNlN/euiVxmRejPsKtEDZ15E7OGMFPCGH3Zougfw8kQ/yiaBU/gZ+CjAX9F6oGRRFrSk5SaBfWXNZPWBvS7+UXRAuUeTYLxk9kKaDqSn9L6z1bJl+x7qw2mlAbJyEHbRaFzHRAe5sAKKO5l7eOUr1mQjbRVEHi2LMwVhdMv//3I5uCPILr0j4cRwzPBxcwUWHtAHCP0RHrHjHlUABCKS3HzaUvjmL1jQD5A1kWSIahLFB6DFGIezIH7+zoVqz/NTUuw+8T9HzAp3suRsQdSQoDfbXnAAzDdabJY+NRCGeFmf2eheh+Kk58VX3yf4yo8lveOWAc0QSLxZnawbwY87+zmTlb/0LE7XIljKEqp4bBg8KOpDSpbGOOBe303x3hzd4+iQRnhL0S2UAILdXhjmRtN4mPUa16ZsmgrSJi3feDU4RreL4ry3n8heJM3LGBnnhkrG/j4UYcGlHM2mg9dKzAQ4ktP7BpPFj5LKLntvuzefJ6tpDSxiQELQD2tiw9gFOacLRhTLKwFnbPxx6qeRI+I+cBnnGLHceZbVH+MvhlIXT6LTC16Z+N2g+8eEmplpA1JtyzrNrMZ96SRUaYM8xYvMGze6u5g3Wt9io1ogsL50IOGyLUrSgGUTo5zV7o7QCYVkBN/x7vukXSFOIyqE40fMw/QLWUpYMRt3X7Gd8hfm68wYiJmKpDyATnE7ymFrNhMD7mqLT8JPsJeriHgHu4Q2NxZhNWLr2Kgp8zUpOzExITBqP66Mt3sLQ2GXd7tBGQPj8l1WAnBZQfH6725U3uV0PLxsXnDNOGSVO6mZkh7q7Mhph9/oR3VU9F5pv/IgdXq20BzLiqoaxL1p7l+0/kDFo152knXo1VrmthGTa7GVAxBJdV2//AZwyzr6RSjoG9VdN1pKdNz8a5c88ah3epxTKlh7PIZc+jRGftfzxjsvxor8pFSRWlz80pAgMDH0P4vURPplSuma1ipc4lLZJOwt42a1iNP8ECxHCr1PYJC27DFEvY7DOsTFQnF9PnMz0XiSbaBZR+Kb4WopBPLo3y3bs+CLrl6CIrcz2dNg4jy/2myeB8RH0E4mkLD3BHfmKXEodIg72lNph34MlH3dNqkjEy4BAe6CkDpaG88SMt2srAxDVDr2oskbz5X2wcreoKdPMV0L6ZeWv8DzxRNPA8YDn006NTykW5dLpirQqaiA2YPuOkSLCSH+0SByokb59XaNQZF5ew8fPvg0jPxI5XWy2Khxm1SAUmj5Uk8N77rYmTYZXcZ+Mnt0LCMGiiBOtXNLAPGekHr4TaWZyu9Z7+9dvLcpBG4A4pFYX78O4y2ipFgO/3+kgYh1qOd1ZsRIOsRrJtBgbIJeACI2etaAgLzh5fSA33DDKs5mmdrgFy5mIBTEjcNXxezywh6sxCo5Olnro2B98mBEyRMwQqEPW50VfgrAw3/pSo7B3cCQwSdQ7vxR5aZh/5amiH7I68S1nZAc318VPqDlWj5XPKIhnh/df932Orj7CqNI2a3UDfVTK+iUAM6mHn7dTkUfBfk0S5vB7nQPHKCbuzDMpBhco/mt7WoffcSM+osX0t4Ryt+1au9bV23sOnx8exF/R2O3QjrvnQkY05Pz0P1XfATFHwB/ICeoEQPrL3WfsuOIjHfRRC3xnj68t92u3KlMpH6QjB9jQfpetEVgMp3/wDdRp83hfMPbsKEqlTd7CGWVqZB0xXVYTM5BQTxG5j2oLld3NERpjP0S7E822YHDramdcs8rQ7tq7zAkVX9301xZyjgniR0VH/O2oB/9zLgLTJYtS58k4mONgMbvU39AwS/REmuO9wNUEpAM0E3IIDlARYsDCdpxwN0x+1ZBseQ6tDxUCXzNDuGTwr7M8iWarl24OIT22/8rhA/T3+kpa9Y4IxwJLYsA91+BKHW1iR6quFyijEEc7arejNMF33RvEgLwHhy+cR8K2hu1K+FyERztmwMp27Qov5mho+MPuSHbeA1qQMqyz/qkU9Ji+Od0gXviJE590ImlhKFy3xuTcon3Bk35jXWENLXX7QLvkGrAy9+i/2xDdDVeWeRl9APe7RgLx9Jl5bRxRCmeuDudD4SWMhrnTi4rEmUrjjyWKe1kr+lzpbHKGnY03uq3htQH18z2na4MziInY/cf6zI4P9IDIyJk8TK1LIeHk038FW7zfdW6UYsqnzSJjql3qMfrflNEpM68m6aqIZ1CYFV6hSxR4VT4edjnHtAKZVTYsykn0dh4LGnZWjnZlA9WZC+2yn9Fn22mcBpP6YmwvmMK54UfzYFX/5zlBXU1WgwccT38ZYt/McHc2bFvJmZAP3a/Pi8bSDrOIULG5A8+DPOu8WFEDNfnwcNsYzOvk0Mh1ZiKAWQvNxcoCEblmYdazQEZerZ2vtNPyszFP0t3JT0ShgKkphTj53lpZdNKWtrt9Z6JyCIPU4Aye4EIlqqPseQS04onUwgf8S1cmii8VCxj6+mbub9GHod9NxJCwHp2GrxOYPZKLQnDgl9iIS3YIa4O8yf4JSIDk8O5a5NsOvcmwb0jyvmIs5n1DfjX5fPX/d/7Dy47T0Lbw3x+E6kzp/ewvZDCCcZ800DHIW4czuRUnhnmPAP0Jc6tbQ1zQdqHHYvA6MqgFfuTiAloyil4Bm/Fd6pApvtG/tIDLx98dAm6gIJ09u+8xy18A8yVgNegqov15o21f6CXBmyKH6ZaEXcb0pR180PsVuCFmB7hposl8njjcflXzqL+xtGiORksoFXQ6wMLoRulS/Abv30jmeoyjwsq9fT4rEWdSR3n1KMOY/DcbQWJpauIZ9zvJHSdFT5T6uvRcp2JFBqTtZpnJZmFJKpP42hL+gniPh5VadBFd1rx5YnreoQzT7mx52L1E4MrdyRSmJdAOE/g1dgD1onYAKZyaSo9wN5TwOSy9lxYU8ZY4jRsyt48tGYKt5oWNUi5vChsrLgs3oRvE7EW2ZL+ifhGkYBQQG8N6SXq0dozSWp8bihM4FK5dcVfy34RPM2utk1w+kwgWn5AHVGjbvtFhug9AhFxbYPA9CeGfP0i3vPbUIUEKwOfkCFu8FKpYQaFGao5cLfJaCXyoQZimmAJo7eM5FdCaH4c/iygDmnS9JrPUSd9s0MXXcbnTX3SPxIHQ0b5qafh3VEh+UTes6r4pl0XeIuhUe7qi58xTAJi4Tk92nBfn61a20gGgGxKDAS0zHuzxigXmoZ7v27RHsNTasLHWynX/EZCl/ez7BgbEUMigmVFZTpDqovSDRhtrQcuREuiUgBukrHvfvB4ENuiuJjr0R0Ep3KCR958MmiQ/b62An7uRBqNFJHQN4+YdTCBOLK/pJFAdDncAOalvqjpWiQuov5aeOjO3rEzKLK5BUDtANEfc9vkxJEvhGW440pmUJLjUyLHuPqo1qxCglR38mH6PurSyArKl/F4hY50kFCm4dQ5ulkcl3ccSgpjTTly0Em4aE1QA3CMzK7slFaObF4n4bafLMDHUloqv5DxwE/MldFOZu384SnFk8My/H3pc+UhjWRTw3l50U+Dqm7LNHfQieSYbFAxq/V24n7ENhAfOk2ET6kr130LbpF5ycY0qPNmONYVmRoTPYBueIhrwyl07Eyq06frGaeTBfq2zRI92BVPCjtA/9sD0va09AUGMfDJsxpgZbeU3ANn3yFSsJHAnIEvsCb03BzCRTm1ay/cOaOitoUanB1Neeey5ooDTag7lXlQ1VHxfX84gEoouMCh3sWl4gawAoAa7vXgFPj0E8gj+QLlhxba62xpena77K2TjtiMiTI0Tio+kk5pwmYEIERAClTuorkdKrilbmpILIWr3y8nWvzDEKJHXWGRP/V8HjAk5PGvmVaQuZ9/S0j8nagxmYptFpKBBYfJKgD6eks6ni0do7Jm72JkqkgSkDzEiqLGeLrjcGgZcwhK+VK1DFyUB+3hVrttqP1l2eByCV55H2FkuNbPWM1flJPHkNoq4ZkSldOj4wPkZpCMUGVyYIaO0Xo4xABM+Y6XGpUt6ndAe4dgyuDM0Z+R+iSQQuDfO28htUEOMoEsRkvnFpDjovlDAVZvne38lnFd56T8Fr1BRnThe4xTY4ccbKcvGbGpCfcrxTcdQDz8+jQD78Y04eK65lOrMObgNNq8NyY/SVtO/w8NxGEoWhR0udQeu2o1L3Irp6FHe6tFigEKBlh//JdnE5mFmZrn6YH50lKcSkIV1c/YysPDDdLGWWmdcTll54KH5dgzB3rtQ/tqIko4aWPBtAYF+JtjUUb00OMJUC4h8IKNNLTKBFMPIVILLGhdGCa4ohpgi2sY7TnfRwL3dz4Amt+hroiyPTtY3mJFf85ZyWCu8eE5SRNLMvTDMMJHogCoJ71uaFWGfxDd/7cQ4yG9ri2XAlY6ov+gS4yOOIqHvGsWnRtwXJMIBYt6lO0IvjqFAemIEPdXqj0PgWsH2tq7YNMcEFe9unjxah3U5skINPe7kIrIDprAx1Xgl2/LJ2klaWjE2ntYLmnZ0oB4u7s97wjH9+a7D6tgMIRT10zAbhOHZWT9gSDsQ563tF/NIVFakuOiXABycYXAkFzEW58Z+zqIEWUbwMZy6Kqf3m8nU+3tx6TZjZbVgEL33Rx8IQUB571zYq4hEp9tnWPQ+wCuCZ/BGnykCdgSM2EHfqYrwSXT/xyNbrqcnD/jXQt4ffbO963jinmNWThUTqsAAUGurFhrclsFLIVoejjy/zjqnS8gbCLEwcgaxpt0DOfY6PKriG4QNpGVvEYa0RTP3/VV6Vq+IouHpzigL5/5bDw35RGIVPx0CeYToJgpaFIukTTyFgqH55DfeBgiXpAZLP+f53BvD/9Oi1vQqtP6xZrYW8t/3aZWEcHbmG/YTlLnzEpE9wjYCjSlEwctZ644PQQOaNseHhopAGiEagTmB0e/WL31bOuRp0l+yERnTWAdpbL/XVPD9MFxwtxZ5IP7TbgKlaPlJQHnsBzdkAIHzfmTzOoP/KKNAXWkMn3LYDo5ICTHH444okFO6zanlppy5RZvhQ9FIvO7tGzJzS1o9t6NItUSEWNwr8lJktByWoeq3nZppErk19Pn8R9kF9Zf0Kkutgb06HS75FkfGSookwlJQrQkWk6tU0xRAZwPFmiKHjP4AE9Wk28Qc0KR5xeLGDd2crVn00Km5N2XvScDU7TgdazBJCUW7BWf1FI8+SeYoPsE/GHHvgH7+dZk3sC58Y9uOKE4aorV86nbzLXf5XYi6BfAeVhiZYGZCdrH03lbjjU3sDIX0oNXQBrPtITaxYFqSghCW0py0LNED7ZUCW223SZ4uRFi2Mi8sJgZKYXBphlSeYtdLME3fx66Ck9rjoVxGCeIklb5e2DFCw6gzXLlbOsn6kt86NSIPm70wfWUVv6p+uVpTUk4+3NdM1TcxeJUnvCycIjPWYuiId5zRDhoucoIrSM44kiwRfhD91DtXFXrGmoZBIUoW8US3j3UW3u6SyPa3o0cuMeb+LoJPLOURoSmRx/kae81VF0mFjYKkl5gxOosaZeAWgAE6MpUxkEH3E0olB5gEUB6bJQ2or7635yiMhSirCcHszJiQREHmSjABhHPWEhnfSZMsBlpqNr7OBdbzLZMoJCiKOcZ3cvuC3yZfABuO+scN2y7UdwCqSSO8kARyMnVar7hD8mJjYlyL97Mq0SX+pQdm8tPZqQ6tk8XXjO3VzsoOk1uqzkwZDJWHuxGj/Fa/hLpICGGQHDtavZzY3eBer1Zo8b0tkEiIpO27KmPnsfUT7m2lwD3I+g12kBEAvEbGXZBxQ06iajEbJ3CuuRuxh2dX/+c/k2h49tHQvxfORWE0jF8NAWtTrmWf2vuhiXQEUdjbpC35JwJFO2kjEbdwGoGKWhSwRKAzhGdSq1A+pdHpDNsMViI7VfAc0Ff0yR5MRvRp2GTbq1BWaHDF/xwVrgVtlosGtJcgSDx751CrMvC6MglHitJFOWLiVT26MDLYRlY7shwYgc61gZVF2anP/LHr0z6XdTYf7+swgCYPgX2/cTmdvS73tRklHug/sMT7a/RKv5+4t9rPKmzafdWZtZc57GFxmvq8c6apm/Wby5niHq3Or4u6Mvs5VSRKOr701Z1Gtb+wdkx9XW+hZmIuPNu/+vRxmkZpihW0nG69/vQi4jszqYo9dtwewTSTNDQ0GKi7NEJuleyoylMs/0JEgkXGPl2atrDGut7alzT2fNwCIrpHD+qBmc/7Cg/sEonkZiI967xMa1Auv3nGAX6+dbMsz6k/gg6EP3rROZ1Cy+P66PeFqq8i28hXHd0TMi6DZV+++glXMtl+OmTeQBCAVVYt11GQ8f7kmxkXzHl+WWnsU8+DZxnlIHGOYd2sudd1pjwQLnJ9X8JIe/qQcEcKq0Gwr7winSq11cxikJNLTRf4jPo201sfQj3+ZEh5Zb8M/XCC7k5jNuG2hg0dwjg5cZyLT4ViqKOhx2NevsZODWf3wZ7xZHI8tQPOMeQqVjouG6r59mu5sbAutTPYO8z3rVSsammAVzavz+bBaJMhKY31o9I7V9uBAimeE/jxLuTZuG00/+IjTabM1fdFG21m7zdtSdwX2cUj23FLMFQUV7UWmiS4a6/K6Y//SU7QSC0i8oHWpjPlHVGKTGQ7tYZs3qwFsdDUz7EdEdVlMuLHkswuKsUgEtZUSn9Kr/ovXH41UOk/1CRUfUMI1ZuZmozv57+HGw6/liHqcE/sYAcciuBJ+PXR4A9jQEoG/ibf1fKNqcKSbH5IqRRa+EuK+7A4/OmqA/khASBs89bSCcjazqBkpfi7+Vncb7hmZESx1J9FE8A+5/oLPaSPmLq8FORrsJYo2oKKaDeNWKBFvHiZJnxDKxbDS6qAGpESgwGBKay4kQE9wHQLL8eeiKxlPh3Cy7Y7jMdRUhhmbwIt6iHBPpA1cyPyTNhRAey4EQdW5HOp9+y1n/fiCeZuyl9Q8C/X22K3NAq0RxQrCtJ6JQ+cOZT5Ywmm0Y7D5OqIKvl4W9zYkIoxS5cxKnD4IjK+SqGREo1wJiFKREwWgxMDfrkoLKsCN5NF2QTtRBmqiuIvciHD62WtiXZVDW+rGXq7K9Ms0RiqvJCLmwCB74ABWdCzXFTlLezSajtGCUKM+izLsT4y9M5/5nsTCFqXiBDwd1N3gQ9fPlEmYsukzhnJYtX6buK+1vAh39CQRMGmZIn/kvbaYHHbcUZj7OWNSSkxfUXaUgPSSHGnXgqlIYv4cvbZcMTdjJuWOH9ar+D3ar1tgQrkxtTbvuHJgGucJcGawiGBvuGdzrzH3R7q+8ROy2MY88Zk0GcYUOd/DH/vH/9CQ1pPViCGlAHDt3N1Jo67IZxfzEvLG/awoWeHxMJY7/IAIoYwxdEIMtT/sh95JqnB9y2t12eqqgNJLV5icS/Mli61oIs9wMqu2dMjL1dTJhrPMPB2kqGj8ZChc7TNGnJvU9QvSp6TNrF5LG+L1nWrraS0yUydgB08X3P4uA7SPQnXaNygKcgr0WYmaCmM3hOBxO8/JiDPUZ9qaSiCjIgmF4cjgXG5+iRuAqTyvH6yRbZJeXF/DzeJ/yaXqWzeVOVpDkVFsOIgmgBRautkQtI5YmmRB8FgJNnfVqxqVhU4Fli7xUTDW88HNOQpzVfP2//tSk0Zp3wveqEzAvv2+Ta1ru1gzx1sdHOqA7SZq10EYVNlV8PIXykLk8NqFDMbm/MljFxLJ9ZvM/YLi0KqbjHIwYLpob99g1tHxSRTjl8EwZyZ1ZpD1pXpquXGSIS5GIqUcygRzGhhDpqwt6jLLS0noJwthQnTuENrv2N8om4M2ZS0YIRcO2APGm9Yo2hBaHFuxccfz4gdyn0HrNoVyyEFMkpzz8jKJ2fE2iW5IXQyRUH3uXVxwQaZ3OARUFoGDxltKTjJR1l2p5CTa0OSYaXCqydwS1v8G1L1HpBQXkUKzWaibnhmuwCxPyYv8ip3dU5kdUHUB/nEWEem2JyslehVKO4DQ42LUMy1xHYGeXAQ/Ne3dYoyog3kBXAruNv+bnxV4T5ZvE1JLXIupFQ+ajNbLkR+A44SIh6qWBrKJGpe1LYaMvMAKxnt21q/FB7CBuQmUe6ADLNVhl1QjL+1FOWcy+lSSie8cyxstU2iYlwjQkjtqEJR3se5EuYo9imYU7ZCVSMeuYv0XrZipd1KPW/XI5cPB0tyxYk20HTnQRvaqYNRLLjU0HbQlVVUFjRb8DY1u7AroZQbxasUB8DR+hSg3yOXRbELATm8p9Z3paO570nCkwz0KWB89NApzLOSIjvr0ZJfGYst5gLKjGW9MZkrn+ruLdodiCmRyG2du6ZTwHSsyLHKjN5FojqeKlTJGCc+oJ+Ble1xF4s9V0e3+uTA+peY59CHFHE6KZarHbyIaRFo3rT34fs4ei9Pyg0G3xIoHZSeh7CGV6Nm2bKcr/qc48IRUZIhM6FSScawVBhW9HkoqymOe/kkZlwY40JZ/eJ3Oq9upmVL3VuyEZhGBr3hDDHXlMnsmC9H8PN9umy514eixA52b+UhrZSCdhX3fNLuJwwjl23dUEGjnfp0RfRjP51JMq2NINPZyAT+rb7tWbqw/4y9xmLOqCBbtGgjC05nAEkx/ZlKCHj09jBHqHEv497mPVWAZBNn60QsshPFNrVb6DLfLu4NpvsHDPosRy6WhSR6eDeDm6NwRxHtpTb7kUJKpvXJklk1ViqZMfTOfh80ZLyyfAH2EWj39ygBHxcsUOIn/uMX8N/ccR0AjtbVbeYLhW5iIwku5bMsLuYBKbLLDcYiPOlokGV3RxOOl17xOBFE++hFx2FM/2ip0zZNiOfQm+b+WtnnlDZ4RjQ5akOG1ZgjZoZdqWnGVvNhxpL9gi4r1rTI94hsPTpG/vL62kv4PpCNl0QrIhPT+X/lN8BaYypYSQuyf9QlUzl5v/RfNbyy+JgmoEi1lkqK1reP7gmSZQgeNoKEUgRw0VecKAwlLcuc5dER1kltrSudxSNBrR3DmyiuBGGcykXGG91LJrIzjnn/uGkQLHhgk470RZTNwWTlzQgoI/rpbBuyNC7BMzlAt89f1YXJqWwCgkdf8c2MRTsIHe5G+kvhpRej0tIyvaLzjPB5+kp5wF+RixmIeUoU9eXjtJRiOqtRoBc/KGsvxG3nDF7pqqf7RxtFUeaqTeUtt+XFGdjT6Ig2bBnD+r/PvhfHvMYGcczP8Pba/dXlTgzPco4cdmlq8Zrd4MmqS9U0QVAX04t6e1liSJTq0riWUtN9WfBHARQjRL2GydBmLHiCvjg73L+8w0qm2MOzKof2yGiqG7hebT7JHWaQZU+5S3VgmJ1a48RrJc335hgHjVUuDW4SELOuzKVU5Flzmtgo7xQ1ao6F7J26IahpPPJqh+pckDth2BG5Ox6dbwZCSN9rOhP6WZZK8eLEiNc68gdKxFgUs/83+YAUIGuSg8BplBQiQG4y5nmEk6v7H2PY7JRx2SO3oJrIfXLsZlMdZw8KR+nGqKTUuh4YrW9GkfCNMYEOgG+Mz3AD+ACO+um4VQqWhpRQ6pZDlyDEADnkwS/+iUf4RR4ev2qc2act+NuecQKfPPlAK1I79MLA+Bd01DWlvrdIiipC6aESBycDuz2yTpSb8fYJChe2wEBBk1saHUzGp1eWfrJ34EToAB/2Y3yt+IRKWJ6rhOZ3AhPkLRU1ldXrZbPHEftki01q1yqcGA3O3nsdFGD0FKBZ0uCmZlZz8mwvG1pzBZYR/1aCpJW4Mbjjpug7tYMqF1J0KNTmUqqcpKxKwLr4lUKi8H7kpwLMX1Uajtiz9qbyRtXSk8TYxUUF/q80OEbQBS9xrJEHJKyjGazKDIMUwbZkT8ekpwvtrQ/577bQllJEiYJta6U1Vg3DW3TsXrrysADkCIRoqHBbVHnWGtqq4Veb0BKn+G9I5gK8/HG4jSFV8rhMTcj5ds1Dj9DeR01m4R3jwz5MOZiIdRGVB6BwDmqpsyUfQX0vrR4Qt4+Qo/AxtSHL+WwgDrO+c7TBxzVUnpMgSSNQlgXFcclLv5DskXyQ0zTQDbBw+O8AIH7bDvCWx4jbcObYipXzYcqdGD/FWXleU+HpbxQmZvasL0bVSyZWDBYrvg1PyTSsKThvPlT2iU6BH22NeOOSdphhSen/lH53B+AI6TxUwomUr5kuEVwq/ZWMzMDrw7pUBxWMLYKr4yfOHUnX7Ogf/WrjKyLt7YVC/Ai9UjnrBPw3ZVLSmvkcjbCW8i21hvX/k5DXKB0cNhyE5gCm0f4WCl5qA1zBkquZUZzp8n/SryK69Z3GcjfHLTiekPE9HbBq/4fiu2eTaQ0uuZ1AWhS/+eFwFPz1b5Zm5toaecX2GbrR2PrugZhi+EYOtK1WfT59Wj/zKeRvy5galjb7IrCnHiQpT23pTukReN03tJGBJc24Z0UI+ItKZPzWpogpscS+74mhmJf2fBcrycvcRe7lTZwZMsA9L5fxC7PzK3WLMzCWQ8hqSbBvK25WRNe6I18Vg3z/KHlH/lMnrNhb3UJM7qw88Fa12tZkpsjBFrp6riAtw5UgIiOCLZva4j6BqLTLIGuYuEiEqeyLfiarxwQ92a/tXjHJ0YS4MQnUqnK9zY/SfnHmfNQdvaOTt4MiGGLjxV/kpnqLuNdYncpY8YoeSZkFfyAGexuBcZo6HcV/mGyndC3g+vC0fmFHK4hzHk5Bl1m2JkiNsajpnXJ3o4uBsEj1ZhpU33CfB5fMnsbDs52f3RxLdpfzssJLy5secXh8rmP/2I3qci9UHkMbXBU6tKKGM/+5y+YbOIBVyqC/ju7T4DetstlHHInTu9tuNQbKYgzhKmy/ySVpG75sNX7hKQCBEXaFl6ZKxDJ2k/PH4CffZlCzCXsmjdTPSrALo/JXbj0OEomtoy1hBm+McZbfe4cMPAFTTmZJcFjbU0PADJTTREgiBp98FElvOV0JX3gnJPa8iPEBRbGRiPMyuiUvZPG/Yy9bqUmtwj3VVqFpGslH/6ih9p20CZxvUlwyzTq6eoEivDaP0Gc76V3wZQjvaqVSyAc5iLjXSfM6C2DhD4</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
	   pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       logAuditEvent("export", `Exported JSON: ${a.download}`);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			clearSearchHighlight();
			return [];
		   }
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   highlightSearchResults(results, true);
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		// forgeTheTopology(); getting ready to implement new core canvas performance system
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${e.from}'); focusOnSelected()">${fromName}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${e.id}'); focusOnSelected()">${e.fromPort || "-"}</td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${e.to}'); focusOnSelected()">${toName}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${e.id}'); focusOnSelected()">${e.toPort || "-"}</td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${notes || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       pushUndo("clear all");
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       logAuditEvent("clear", "Cleared all data from canvas");
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>