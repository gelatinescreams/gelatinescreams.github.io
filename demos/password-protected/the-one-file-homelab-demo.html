<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-74.99705309342698 -7.395887697909075 4069.861183597212 3052.395887697909" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-74.99705309342698" y="-7.395887697909075" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">✕</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
		  this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '↔';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
	   pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       logAuditEvent("export", `Exported JSON: ${a.download}`);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			clearSearchHighlight();
			return [];
		   }
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   highlightSearchResults(results, true);
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		// forgeTheTopology(); getting ready to implement new core canvas performance system
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 8px;"></span><span style="cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</span></td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.fromPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')">${fromPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">↗</span></td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.toPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')">${toPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">↗</span></td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       pushUndo("clear all");
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       logAuditEvent("clear", "Cleared all data from canvas");
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>