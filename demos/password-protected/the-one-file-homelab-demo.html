<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
<style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
	  .toggle-switch{position:relative;display:inline-block;min-width:44px !important;height:24px;flex-shrink:0;vertical-align:middle;}
		.toggle-switch input{opacity:0;width:0;height:0;position:absolute;}
		.toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#475569;transition:.25s;border-radius:24px;}
		.toggle-slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:#e2e8f0;transition:.25s;border-radius:50%;}
		.toggle-switch input:checked+.toggle-slider{background:var(--accent);}
		.toggle-switch input:checked+.toggle-slider:before{transform:translateX(20px);}
		.anim-zone-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;}
		.anim-zone-row label{color:var(--text-main);font-size:14px;}
		.anim-zone-section{font-size:11px;color:var(--text-soft);margin:12px 0 6px;text-transform:uppercase;letter-spacing:0.05em;border-bottom:1px solid var(--edge-main);padding-bottom:4px;}
		.anim-zone-header{font-size:12px;color:var(--accent);margin-bottom:10px;text-transform:uppercase;letter-spacing:0.05em;font-weight:600;}
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
	  .fov-group {
        transition: opacity 0.3s ease;
      }
      g[data-node-id]:not(:hover) .fov-group {
        opacity: 0.7;
      }
      g[data-node-id]:hover .fov-group {
        opacity: 1;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block; 
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	  
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
	  .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 8px;
      fill: none;
      }
	  .minimap-wall {
      pointer-events: none;
      }
      .minimap-rect {
      pointer-events: none;
      }	  
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      pointer-events: auto;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
@keyframes edge-flow-arrow {
  0% { offset-distance: 0%; }
  100% { offset-distance: 100%; }
}
@keyframes edge-flow-arrow-reverse {
  0% { offset-distance: 100%; }
  100% { offset-distance: 0%; }
}
.edge-arrow-forward {
  offset-rotate: auto;
  animation: edge-flow-arrow 1.5s linear infinite;
}
.edge-arrow-backward {
  offset-rotate: auto 180deg;
  animation: edge-flow-arrow-reverse 1.5s linear infinite;
}
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      @keyframes done-pulse {
        0%, 100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 8px rgba(79, 209, 197, 0);
        }
      }
      .done-btn-active {
        animation: done-pulse 1.5s ease-in-out infinite;
        background: var(--accent) !important;
        color: var(--bg) !important;
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
.style-content {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px 12px;
  align-items: center;
  justify-items: end;
}
.style-content label {
  justify-self: start;
}
.style-row {
  display: contents;
}
#edge-panel .style-row,
#rect-panel .style-row,
#text-panel .style-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
#edge-panel .style-row label,
#rect-panel .style-row label,
#text-panel .style-row label {
  min-width: 80px;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
	  .fov-group {
  transition: opacity 0.3s ease;
}
g[data-node-id]:not(:hover) .fov-group {
  opacity: 0.6;
}
g[data-node-id]:hover .fov-group {
  opacity: 1;
}
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
}
	@media print {
	  @page {
		size: landscape;
		margin: 0.5cm;
	  }
	  html, body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
		overflow: visible !important;
	  }
	  body * {
		visibility: hidden;
	  }
	  #canvas-viewport,
	  #canvas-viewport *,
	  #map,
	  #map * {
		visibility: visible;
	  }
	  #canvas-viewport {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		right: 0 !important;
		bottom: 0 !important;
		width: 100vw !important;
		height: 100vh !important;
		overflow: visible !important;
	  }
	  #map {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		width: 100% !important;
		height: 100% !important;
		background: white !important;
		background-image: none !important;
	  }
	  #canvas-grid {
		display: none !important;
	  }
	  main, .topology-panel {
		display: block !important;
		position: static !important;
		overflow: visible !important;
	  }
	  #map circle[class*="node"],
	  #map .node-shape,
	  #map .node-group circle,
	  #map .node-group rect,
	  #map .node-group path,
	  #map .node-group polygon {
		fill: white !important;
		stroke: #000 !important;
		stroke-width: 2px !important;
	  }
	  #map text {
		fill: #000 !important;
		stroke: none !important;
	  }

	  #map .edge,
	  #map polyline,
	  #map line:not([class*="grid"]) {
		stroke: #333 !important;
	  }

  #map .rect-group rect {
    stroke: #333 !important;
  }
	  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
	  .draw-toolbar, .topology-toolbar, .legend-container,
	  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
	  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
		display: none !important;
	  }
	}
	#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Theme Preset</label>
              <div style="display:flex;gap:6px;flex:1;">
                <select id="theme-preset" style="flex:1;padding:4px 8px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:4px;">
                 <option value="defaulted">Default</option>
                 <option value="">Custom</option>
                  <optgroup label="Corporate">
                    <option value="slate">Slate</option>
                    <option value="graphite">Graphite</option>
                    <option value="frost">Frost (Light)</option>
                  </optgroup>
                  <optgroup label="Homelab">
                    <option value="synthwave">Synthwave</option>
                    <option value="terminal">Terminal</option>
                  </optgroup>
                  <optgroup label="Dev">
                    <option value="dracula">Dracula</option>
                    <option value="cobalt">Cobalt</option>
                    <option value="solarized">Solarized</option>
                  </optgroup>
                  <optgroup id="my-themes-group" label="My Themes"></optgroup>
                </select>
              </div>
            </div>
			<div class="style-row">
			 <label>  
			  <button onclick="saveCurrentTheme()" style="padding:4px 8px;background:var(--accent);color:var(--bg);border:none;border-radius:4px;cursor:pointer;font-size:12px;white-space:nowrap;">Save Custom Theme</button>
			 </label>
			  <button id="delete-theme-btn" onclick="deleteCurrentTheme()" style="padding: 4px 8px; background: var(--danger); color: rgb(255, 255, 255); border: none; border-radius: 4px; cursor: pointer; font-size: 12px; display: block;" disabled="">Delete Custom Theme</button>
			</div>	
            <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Sidebar / Mobile Footer</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
			<div class="style-row">
              <label>Tag(s) Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Tag(s) Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Tag(s) Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>			
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
			<label>Show Grid</label>
			<input type="checkbox" id="canvas-grid-enabled" checked="">
			</div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
			<div class="style-row">
			  <label>Show Grid</label>
			  <input type="checkbox" id="rack-grid-enabled" checked="">
			</div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90°)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Style</label>
              <select id="animation-style-select">
                <option value="arrows">Flowing Arrows</option>
                <option value="dots">Dot Arrows</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animate Directions</label>
              <select id="animation-direction-select">
                <option value="all">All Directions</option>
                <option value="forward">Forward Only</option>
                <option value="backward">Backward Only</option>
                <option value="both">Bidirectional Only</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Speed</label>
              <select id="animation-speed-select">
                <option value="0.5">Very Fast</option>
                <option value="1">Fast</option>
                <option value="1.5">Normal</option>
                <option value="2.5">Slow</option>
                <option value="4">Very Slow</option>
              </select>
            </div>
            <div class="style-row" style="grid-column: 1 / -1;">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Animations &amp; Zones</summary>
          <div class="style-content">
            <div class="style-row"><label>All Animations</label><label class="toggle-switch"><input type="checkbox" id="anim-master" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Type</div>
            <div class="style-row"><label>Sweep (Pan)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-sweep" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Pulse (Breathe)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-pulse" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Rings (Emanate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-rings" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Spin (Rotate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-spin" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Connections (Flow)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-connections" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Category</div>
            <div class="style-row"><label>Cameras</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-camera" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Doorbells</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-doorbell" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-motion" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-smoke" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-wifi" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sensor" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sprinkler" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Connections</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-connections" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:12px;color:var(--accent);text-transform:uppercase;letter-spacing:0.05em;font-weight:600;margin-top:16px;padding-top:12px;border-top:1px solid var(--edge-main);">Zone (Animation Cone) Setings</div>
            <div class="style-row"><label>All Zones</label><label class="toggle-switch"><input type="checkbox" id="zone-master" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Category</div>
            <div class="style-row"><label>Cameras</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-camera" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Doorbells</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-doorbell" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-motion" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-smoke" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-wifi" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sensor" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sprinkler" checked=""><span class="toggle-slider"></span></label></div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <div style="display:flex;align-items:center;gap:8px;">
                <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
                <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
              </div>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">107 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">16 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
	
	<div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON (Full Backup)</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">🔒</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-json-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-json-file" accept=".json" style="display:none">
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <span style="border-left: 1px solid var(--edge-main); height: 20px; margin: 0 4px;"></span>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-zone-copy" title="Copy zone style">📡 Copy Zone</button>
          <button id="bulk-zone-paste" title="Paste zone style">📡 Paste Zone</button>
          <button id="bulk-zone-toggle" title="Toggle zones on selected">📡 Toggle Zones</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--edge-main);">
            <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.05em;">Coverage Zones</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
              <button id="bulk-zone-copy-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;">Copy Zone</span></button>
              <button id="bulk-zone-paste-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;">Paste Zone</span></button>
              <button id="bulk-zone-toggle-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;">Toggle Zones</span></button>
            </div>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint" style="cursor: pointer;">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-191.26917538063572 -261.51832729948296 4570.339735330435 3427.7548014978265" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="-191.26917538063572" y="-261.51832729948296" width="4570.339735330435" height="3427.7548014978265"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">88%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Connection &amp; Zone Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Connection</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
		  
          <details id="fov-section" style="display: block; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Coverage Zone</summary>
            <div style="padding: 10px 0;">
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Preset:</label>
                <select id="fov-preset" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                  <option value="">-- Apply Preset --</option>
                  <option value="security-cam">Security Camera</option>
                  <option value="ptz-cam">PTZ Camera</option>
                  <option value="motion-detect">Motion Detector</option>
                  <option value="wifi-strong">WiFi</option>
                  <option value="wifi-extended">WiFi Extender</option>
                  <option value="smoke-alarm">Smoke Alarm</option>
                  <option value="sprinkler-arc">Sprinkler Arc</option>
                </select>
                <button id="fov-save-preset" title="Save as preset" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">💾</button>
                <button id="fov-copy-style" title="Copy zone style" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">📋</button>
                <button id="fov-paste-style" title="Paste zone style" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">📥</button>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Show Zone:</label>
                <input type="checkbox" id="fov-enabled" style="width: 18px; height: 18px; cursor: pointer;">
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Angle:</label>
                <input type="range" id="fov-angle" min="10" max="360" value="90" style="flex: 1;">
                <span id="fov-angle-value" style="min-width: 40px; text-align: right; color: var(--text-main);">360°</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Distance:</label>
                <input type="range" id="fov-distance" min="50" max="500" value="150" style="flex: 1;">
                <span id="fov-distance-value" style="min-width: 40px; text-align: right; color: var(--text-main);">200</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Inner Radius:</label>
                <input type="range" id="fov-inner-radius" min="0" max="200" value="0" style="flex: 1;">
                <span id="fov-inner-radius-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Rotation:</label>
                <input type="range" id="fov-rotation" min="0" max="360" value="0" style="flex: 1;">
                <span id="fov-rotation-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0°</span>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Fill</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Color:</label>
                  <input type="color" id="fov-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Opacity:</label>
                  <input type="range" id="fov-opacity" min="5" max="80" value="20" style="flex: 1;">
                  <span id="fov-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">20%</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Gradient:</label>
                  <input type="checkbox" id="fov-gradient" style="width: 18px; height: 18px; cursor: pointer;">
                  <span style="color: var(--text-soft); font-size: 12px; margin-left: 8px;">Fade toward edge</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Border</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Color:</label>
                  <input type="color" id="fov-border-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Width:</label>
                  <input type="range" id="fov-border-width" min="0" max="10" value="2" style="flex: 1;">
                  <span id="fov-border-width-value" style="min-width: 40px; text-align: right; color: var(--text-main);">2</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Style:</label>
                  <select id="fov-border-style" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Opacity:</label>
                  <input type="range" id="fov-border-opacity" min="0" max="100" value="100" style="flex: 1;">
                  <span id="fov-border-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">100%</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Label</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Text:</label>
                  <input type="text" id="fov-label" placeholder="e.g. Detection Zone" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Position:</label>
                  <select id="fov-label-position" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="center">Center</option>
                    <option value="edge">Edge</option>
                    <option value="outside">Outside</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Font Size:</label>
                  <input type="range" id="fov-label-size" min="8" max="32" value="14" style="flex: 1;">
                  <span id="fov-label-size-value" style="min-width: 40px; text-align: right; color: var(--text-main);">14px</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Font Color:</label>
                  <input type="color" id="fov-label-color" value="#ffffff" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Bold:</label>
                  <input type="checkbox" id="fov-label-bold" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Background:</label>
                  <input type="checkbox" id="fov-label-bg" style="width: 18px; height: 18px; cursor: pointer;">
                  <input type="color" id="fov-label-bg-color" value="#000000" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; margin-left: 8px;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Offset X:</label>
                  <input type="range" id="fov-label-offset-x" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-x-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Offset Y:</label>
                  <input type="range" id="fov-label-offset-y" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-y-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Animation</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Animate:</label>
                  <input type="checkbox" id="fov-animate" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Type:</label>
                  <select id="fov-animation-type" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="sweep">Sweep (Pan)</option>
                    <option value="pulse">Pulse (Breathe)</option>
                    <option value="rings">Rings (Emanate)</option>
                    <option value="spin">Spin (Rotate)</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Sweep:</label>
                  <input type="range" id="fov-sweep" min="30" max="360" value="120" style="flex: 1;">
                  <span id="fov-sweep-value" style="min-width: 40px; text-align: right; color: var(--text-main);">120°</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Speed:</label>
                  <input type="range" id="fov-speed" min="1" max="60" value="4" style="flex: 1;">
                  <span id="fov-speed-value" style="min-width: 40px; text-align: right; color: var(--text-main);">4s</span>
                </div>
              </div>
            </div>
          </details>
          <details id="node-connections-section" ...="" <details="" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <div class="size-controls">
            <label>Rotation:</label>
            <input type="range" id="rotation-slider" min="-360" max="360" value="0">
            <input type="number" id="rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
            <button id="reset-rotation">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90°)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row">
            <label>Animate:</label>
            <input type="checkbox" id="edge-animate">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="edge-animation-style">
              <option value="">Default</option>
              <option value="arrows">Flowing Arrows</option>
              <option value="dots">Dot Arrows</option>
            </select>
          </div>
          <div class="style-row">
            <label>Speed:</label>
            <select id="edge-animation-speed">
              <option value="">Default</option>
              <option value="0.5">Very Fast</option>
              <option value="1">Fast</option>
              <option value="1.5">Normal</option>
              <option value="2.5">Slow</option>
              <option value="4">Very Slow</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="rect-rotation" min="-360" max="360" value="0" style="flex: 1;">
            <input type="number" id="rect-rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="text-rotation" min="-360" max="360" value="0" style="flex: 1">
            <input type="number" id="text-rotation-val" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent);
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let savedStyleSets = [];
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
		  this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         zoneLegend: ZONE_LEGEND,
         zonePresets: ZONE_PRESETS,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
		 savedStyleSets: savedStyleSets,
		 selectedTheme: document.getElementById("theme-preset")?.value || "defaulted",
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
			ZONE_LEGEND = saved.zoneLegend || {};
            ZONE_PRESETS = saved.zonePresets || {};
            loadCustomPresets();
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.savedStyleSets) savedStyleSets = saved.savedStyleSets;
            if (saved.selectedTheme) {
              rebuildThemeDropdown();
              document.getElementById("theme-preset").value = saved.selectedTheme;
              updateDeleteButton();
            }
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
canvasGridEnabled: true,
rackFrameFill: "#0f172a",
rackGridEnabled: true,
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
	   animateConnections: false,
	   animationStyle: "arrows",
	   animationDirection: "all",
	   animationSpeed: 1.5,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  const FOV_ANIMATION_START = Date.now();
	  let ZONES_VISIBLE = true;
const ANIM_SETTINGS = {
  masterAnim: true,
  masterZones: true,
  animTypes: { sweep: true, pulse: true, rings: true, spin: true, connections: true },
  animCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true, connections: true },
  zoneCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true }
};
function getShapeCategory(shape) {
  const map = {
    "camera": "camera", "cctv": "camera", "ptz-cam": "camera",
    "doorbell": "doorbell",
    "motion-sensor": "motion", "motion-detect": "motion",
    "smoke-detector": "smoke", "smoke-alarm": "smoke",
    "access-point": "wifi", "wifi": "wifi", "router": "wifi", "wifi-strong": "wifi", "wifi-weak": "wifi",
    "sensor": "sensor", "iot": "sensor",
    "sprinkler": "sprinkler", "sprinkler-arc": "sprinkler"
  };
  return map[shape] || null;
}
function isAnimationAllowed(shape, animType) {
  if (!ANIM_SETTINGS.masterAnim) return false;
  if (!ANIM_SETTINGS.animTypes[animType]) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.animCategories[cat]) return false;
  return true;
}
function isZoneAllowed(shape) {
  if (!ANIM_SETTINGS.masterZones) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.zoneCategories[cat]) return false;
  return true;
}
function applyAnimZoneSettings() {
  document.querySelectorAll(".fov-group").forEach(g => {
    const nodeEl = g.closest("g[data-node-id]");
    if (!nodeEl) return;
    const nodeId = nodeEl.dataset.nodeId;
    const node = NODE_DATA[nodeId];
    if (!node) return;
    const cat = getShapeCategory(node.shape);
    const zoneVisible = ANIM_SETTINGS.masterZones && (!cat || ANIM_SETTINGS.zoneCategories[cat]);
    g.style.display = zoneVisible ? "" : "none";
    if (zoneVisible && node.fovAnimate) {
      const animType = node.fovAnimationType || "sweep";
      const animAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes[animType] && (!cat || ANIM_SETTINGS.animCategories[cat]);
      g.style.animationPlayState = animAllowed ? "running" : "paused";
      g.querySelectorAll("circle").forEach(c => c.style.animationPlayState = animAllowed ? "running" : "paused");
    }
  });
  const connAnimAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes.connections && ANIM_SETTINGS.animCategories.connections;
  document.querySelectorAll(".edge-arrow-forward, .edge-arrow-backward").forEach(a => {
    a.style.animationPlayState = connAnimAllowed ? "running" : "paused";
  });
}
let ZONE_LEGEND = {};
let ZONE_PRESETS = {};
let copiedZoneStyle = null;
	  function hasCoverageZone(shape) {
		  const supportedShapes = [
			"camera", "cctv", "doorbell",
			"motion-sensor", "smoke-detector",
			"access-point", "wifi", "router",
			"sensor", "iot", "sprinkler"
		  ];
		  return supportedShapes.includes(shape);
		}

		function getCoverageDefaults(shape) {
		  const defaults = {
			"camera": { angle: 90, distance: 150, animationType: "sweep" },
			"cctv": { angle: 90, distance: 150, animationType: "sweep" },
			"doorbell": { angle: 120, distance: 100, animationType: "sweep" },
			"motion-sensor": { angle: 120, distance: 100, animationType: "pulse" },
			"smoke-detector": { angle: 360, distance: 80, animationType: "pulse" },
			"access-point": { angle: 360, distance: 200, animationType: "rings" },
			"wifi": { angle: 360, distance: 200, animationType: "rings" },
			"router": { angle: 360, distance: 200, animationType: "rings" },
			"sensor": { angle: 90, distance: 100, animationType: "pulse" },
			"iot": { angle: 90, distance: 100, animationType: "pulse" },
			"sprinkler": { angle: 90, distance: 120, animationType: "spin" }
		  };
		  return defaults[shape] || { angle: 90, distance: 150, animationType: "sweep" };
		}
		function toggleAllZones() {
  ANIM_SETTINGS.masterZones = !ANIM_SETTINGS.masterZones;
  const masterCheckbox = document.getElementById("zone-master");
  if (masterCheckbox) masterCheckbox.checked = ANIM_SETTINGS.masterZones;
  applyAnimZoneSettings();
}

function copyZoneStyle(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node || !hasCoverageZone(node.shape)) return;
  copiedZoneStyle = {
    fovEnabled: node.fovEnabled,
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovRotation: node.fovRotation,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovLabel: node.fovLabel,
    fovLabelPosition: node.fovLabelPosition,
    fovLabelSize: node.fovLabelSize,
    fovLabelColor: node.fovLabelColor,
    fovLabelBold: node.fovLabelBold,
    fovLabelBg: node.fovLabelBg,
    fovLabelBgColor: node.fovLabelBgColor,
    fovLabelOffsetX: node.fovLabelOffsetX,
    fovLabelOffsetY: node.fovLabelOffsetY,
    fovAnimate: node.fovAnimate,
    fovAnimationType: node.fovAnimationType,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
}

function pasteZoneStyle(nodeId) {
  if (!copiedZoneStyle) return;
  const node = NODE_DATA[nodeId];
  if (!node || !hasCoverageZone(node.shape)) return;
  pushUndo("paste zone style");
  Object.assign(node, copiedZoneStyle);
  updateFovCone(nodeId);
  if (currentNodeId === nodeId) {
    claimTheImmortal(nodeId);
  }
}

function applyZonePreset(preset) {
  if (!currentNodeId) return;
  const presets = {
    "security-cam": { fovAngle: 90, fovDistance: 150, fovColor: "#f59e0b", fovOpacity: 20, fovAnimationType: "sweep", fovAnimate: false },
    "ptz-cam": { fovAngle: 60, fovDistance: 200, fovColor: "#f59e0b", fovOpacity: 25, fovAnimationType: "sweep", fovAnimate: true, fovSweep: 180, fovSpeed: 8 },
    "motion-detect": { fovAngle: 120, fovDistance: 100, fovColor: "#10b981", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: true, fovSpeed: 3 },
    "wifi-strong": { fovAngle: 360, fovDistance: 150, fovColor: "#3b82f6", fovOpacity: 10, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 4 },
    "wifi-weak": { fovAngle: 360, fovDistance: 250, fovColor: "#3b82f6", fovOpacity: 8, fovGradient: true, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 5 },
    "smoke-alarm": { fovAngle: 360, fovDistance: 80, fovColor: "#ef4444", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: false },
    "sprinkler-arc": { fovAngle: 90, fovDistance: 120, fovColor: "#06b6d4", fovOpacity: 20, fovAnimationType: "spin", fovAnimate: true, fovSpeed: 6 }
  };
  const allPresets = { ...presets, ...ZONE_PRESETS };
  const settings = allPresets[preset];
  if (!settings) return;
  
  pushUndo("apply zone preset");
  const node = NODE_DATA[currentNodeId];
  node.fovEnabled = true;
  Object.assign(node, settings);
  updateFovCone(currentNodeId);
  claimTheImmortal(currentNodeId);
}

function saveCustomZonePreset() {
  if (!currentNodeId) return;
  const node = NODE_DATA[currentNodeId];
  if (!node.fovEnabled) {
    alert("Enable the zone first before saving as preset");
    return;
  }
  const name = prompt("Enter preset name:");
  if (!name || !name.trim()) return;
  
  const presetId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
  ZONE_PRESETS[presetId] = {
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovAnimationType: node.fovAnimationType,
    fovAnimate: node.fovAnimate,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
  const select = document.getElementById("fov-preset");
  if (select && !select.querySelector(`option[value="${presetId}"]`)) {
    const opt = document.createElement("option");
    opt.value = presetId;
    opt.textContent = name.trim() + " (Custom)";
    select.appendChild(opt);
  }
  alert("Preset saved: " + name.trim());
}

function bulkCopyZoneStyle() {
  if (selectedNodes.size === 0) {
    alert("Select at least one node first");
    return;
  }
  const firstId = [...selectedNodes][0];
  if (copyZoneStyle(firstId)) {
    alert("Zone style copied from first selected node");
  }
}

function bulkPasteZoneStyle() {
  if (selectedNodes.size === 0) {
    alert("Select nodes first");
    return;
  }
  if (!copiedZoneStyle) {
    alert("Copy a zone style first");
    return;
  }
  pushUndo("bulk paste zone style");
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      Object.assign(node, copiedZoneStyle);
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  alert(`Zone style pasted to ${count} node(s)`);
}

function bulkToggleZones() {
  if (selectedNodes.size === 0) {
    alert("Select nodes first");
    return;
  }
  pushUndo("bulk toggle zones");
  const firstNode = NODE_DATA[[...selectedNodes][0]];
  const newState = !(firstNode?.fovEnabled);
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      node.fovEnabled = newState;
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  alert(`Toggled zones on ${count} node(s) to ${newState ? 'ON' : 'OFF'}`);
}

function loadCustomPresets() {
  const select = document.getElementById("fov-preset");
  if (!select) return;
  Object.keys(ZONE_PRESETS).forEach(id => {
    if (!select.querySelector(`option[value="${id}"]`)) {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = id.replace(/-/g, " ") + " ★";
      select.appendChild(opt);
    }
  });
}

function updateZoneLegend() {
  const container = document.getElementById("edge-legend");
  if (!container) return;
  container.querySelectorAll(".zone-legend-item").forEach(el => el.remove());
  container.querySelectorAll(".zone-legend-title").forEach(el => el.remove());
  const zoneColors = new Set();
  Object.values(NODE_DATA).forEach(node => {
    if (hasCoverageZone(node.shape) && node.fovEnabled && node.fovColor) {
      zoneColors.add(node.fovColor);
    }
  });
  
  if (zoneColors.size === 0) return;
  const zoneTitle = document.createElement("div");
  zoneTitle.className = "legend-title zone-legend-title";
  zoneTitle.textContent = "Zone Legend";
  zoneTitle.style.marginTop = "12px";
  zoneTitle.style.paddingTop = "8px";
  zoneTitle.style.borderTop = "1px solid var(--edge-main)";
  container.appendChild(zoneTitle);
  zoneColors.forEach(color => {
    if (!ZONE_LEGEND[color]) {
      ZONE_LEGEND[color] = "Coverage Zone";
    }
    const item = document.createElement("div");
    item.className = "legend-item zone-legend-item";
    item.addEventListener("mousedown", (e) => e.stopPropagation());
    item.addEventListener("click", (e) => e.stopPropagation());
    
    const swatch = document.createElement("span");
    swatch.className = "legend-swatch";
    swatch.style.backgroundColor = color;
    swatch.style.opacity = "0.5";
    swatch.style.cursor = "pointer";
    swatch.addEventListener("click", (e) => {
      e.stopPropagation();
      const nodeWithColor = Object.entries(NODE_DATA).find(([id, n]) => 
        hasCoverageZone(n.shape) && n.fovEnabled && n.fovColor === color
      );
      if (nodeWithColor) {
        claimTheImmortal(nodeWithColor[0]);
      }
    });
    
    const label = document.createElement("span");
    label.className = "legend-label";
    label.textContent = ZONE_LEGEND[color];
    label.contentEditable = true;
    label.addEventListener("focus", () => label.classList.add("editing"));
    label.addEventListener("blur", () => {
      label.classList.remove("editing");
      ZONE_LEGEND[color] = label.textContent.trim() || "Coverage Zone";
    });
    label.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        label.blur();
      }
    });
    
    item.append(swatch, label);
    container.appendChild(item);
  });
  
  updateLegendVisibility();
}
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
			const fovSection = document.getElementById("fov-section");
			if (fovSection) {
			  if (hasCoverageZone(data.shape)) {
				const defaults = getCoverageDefaults(data.shape);
				fovSection.style.display = "block";
				document.getElementById("fov-enabled").checked = data.fovEnabled || false;
				document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
				document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "°";
				document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
				document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
				document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
				document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
				document.getElementById("fov-rotation").value = data.fovRotation || 0;
				document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "°";
				document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
				document.getElementById("fov-opacity").value = data.fovOpacity || 20;
				document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
				document.getElementById("fov-gradient").checked = data.fovGradient || false;
				document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
				document.getElementById("fov-border-width").value = data.fovBorderWidth ?? 2;
				document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth ?? 2;
				document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
				document.getElementById("fov-border-opacity").value = data.fovBorderOpacity ?? 100;
				document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity ?? 100) + "%";
				document.getElementById("fov-label").value = data.fovLabel || "";
				document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
				document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
				document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
				document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
				document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
				document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
				document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
				document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
				document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
				document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
				document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
				document.getElementById("fov-animate").checked = data.fovAnimate || false;
				document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
				document.getElementById("fov-sweep").value = data.fovSweep || 120;
				document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "°";
				document.getElementById("fov-speed").value = data.fovSpeed || 4;
				document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
				document.getElementById("fov-opacity").value = data.fovOpacity || 20;
				document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
			  } else {
				fovSection.style.display = "none";
			  }
			}
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
function updateViewBox() {
  const svg = document.getElementById("map");
  const vb = getViewBox();
  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
  const zoomLevel = document.getElementById("zoom-level");
  if (zoomLevel) {
    zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
  }
  if (canvasState.zoom < 0.5) {
    svg.classList.add("low-zoom");
  } else {
    svg.classList.remove("low-zoom");
  }
  updateMinimap();
  populateRackDropdown();
}
	  
let lastMinimapRender = 0;
const MINIMAP_THROTTLE = 100;

function updateMinimap() {
  const now = performance.now();
  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
  lastMinimapRender = now;
  
  const minimapViewport = document.getElementById("minimap-viewport");
  const minimapSvg = document.getElementById("minimap");
  if (!minimapViewport || !minimapSvg) return;
  const vb = getViewBox();
  minimapViewport.setAttribute("x", vb.x);
  minimapViewport.setAttribute("y", vb.y);
  minimapViewport.setAttribute("width", vb.width);
  minimapViewport.setAttribute("height", vb.height);
  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge, .minimap-wall, .minimap-rect").forEach(el => el.remove());
  const frag = document.createDocumentFragment();
  const ns = "http://www.w3.org/2000/svg";
  const dotColor = PAGE_STATE.minimapDots || "#94a3b8";

  if (RECT_DATA && RECT_DATA.list && currentView.mode !== "rack") {
    RECT_DATA.list.forEach((rect) => {
      if (rect.lineStyle === "wall") {
        const wallRect = document.createElementNS(ns, "rect");
        wallRect.setAttribute("x", rect.x);
        wallRect.setAttribute("y", rect.y);
        wallRect.setAttribute("width", rect.width);
        wallRect.setAttribute("height", rect.height);
        wallRect.style.fill = rect.color || "#666";
        wallRect.style.fillOpacity = "0.6";
        wallRect.style.stroke = rect.borderColor || rect.color || "#666";
        wallRect.style.strokeWidth = "4";
        wallRect.classList.add("minimap-wall");
        frag.appendChild(wallRect);
      }
    });
  }

  EDGE_DATA.list.forEach((edge) => {
    if (edge.type === "custom") {
      if (Array.isArray(edge.points) && edge.points.length >= 2) {
        const polyline = document.createElementNS(ns, "polyline");
        polyline.setAttribute("points", edge.points.map(p => `${p.x},${p.y}`).join(" "));
        polyline.classList.add("minimap-edge");
        frag.appendChild(polyline);
      }
      return;
    }
    const fromNode = NODE_DATA[edge.from];
    const toNode = NODE_DATA[edge.to];
    if (!fromNode || !toNode) return;
    if (currentView.mode === "rack") {
      if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
    } else {
      if (fromNode.assignedRack || toNode.assignedRack) return;
    }
    const p1 = savedPositions[edge.from];
    const p2 = savedPositions[edge.to];
    if (!p1 || !p2) return;
    const routing = edge.routing || PAGE_STATE.defaultEdgeRouting || "curved";
    
    if (routing === "orthogonal") {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const polyline = document.createElementNS(ns, "polyline");
      let points;
      if (Math.abs(dx) > Math.abs(dy)) {
        const midX = p1.x + dx / 2;
        points = `${p1.x},${p1.y} ${midX},${p1.y} ${midX},${p2.y} ${p2.x},${p2.y}`;
      } else {
        const midY = p1.y + dy / 2;
        points = `${p1.x},${p1.y} ${p1.x},${midY} ${p2.x},${midY} ${p2.x},${p2.y}`;
      }
      polyline.setAttribute("points", points);
      polyline.classList.add("minimap-edge");
      frag.appendChild(polyline);
    } else {
      const line = document.createElementNS(ns, "line");
      line.setAttribute("x1", p1.x);
      line.setAttribute("y1", p1.y);
      line.setAttribute("x2", p2.x);
      line.setAttribute("y2", p2.y);
      line.classList.add("minimap-edge");
      frag.appendChild(line);
    }
  });

  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode === "rack") {
      if (node.assignedRack !== currentView.rackId) return;
    } else {
      if (node.assignedRack) return;
    }
    const nodeSize = savedSizes[id] || 55;
    const s = nodeSize * 0.5;
    
    if (node.isRack) {
      const rect = document.createElementNS(ns, "rect");
      rect.setAttribute("x", pos.x - s);
      rect.setAttribute("y", pos.y - s);
      rect.setAttribute("width", s * 2);
      rect.setAttribute("height", s * 2);
      rect.style.fill = dotColor;
      rect.classList.add("minimap-node");
      frag.appendChild(rect);
    } else if (hasCoverageZone(node.shape)) {
      const diamond = document.createElementNS(ns, "polygon");
      const points = `${pos.x},${pos.y - s} ${pos.x + s},${pos.y} ${pos.x},${pos.y + s} ${pos.x - s},${pos.y}`;
      diamond.setAttribute("points", points);
      diamond.style.fill = "none";
      diamond.style.stroke = dotColor;
      diamond.style.strokeWidth = "6";
      diamond.classList.add("minimap-node");
      frag.appendChild(diamond);
    } else {
      const circle = document.createElementNS(ns, "circle");
      circle.setAttribute("cx", pos.x);
      circle.setAttribute("cy", pos.y);
      circle.setAttribute("r", s);
      circle.style.fill = dotColor;
      circle.classList.add("minimap-node");
      frag.appendChild(circle);
    }
  });

  minimapSvg.insertBefore(frag, minimapViewport);
}

      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom));
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX));
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY));
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.textContent = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh");
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")");
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.");
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.");
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page);
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0]);
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p));
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`);
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45);
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45);
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `);
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }

       if (shape === "thermostat") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.75);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const temp = document.createElementNS(ns, "text");
        temp.setAttribute("x", 0);
        temp.setAttribute("y", size * 0.15);
        temp.setAttribute("font-size", size * 0.5);
        temp.setAttribute("fill", "#4ade80");
        temp.setAttribute("text-anchor", "middle");
        temp.setAttribute("font-family", "monospace");
        temp.textContent = "72°";
        g.appendChild(temp);
        return g;
       }
       if (shape === "doorbell") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.25);
        g.appendChild(body);
        const lens = document.createElementNS(ns, "circle");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.35);
        lens.setAttribute("r", size * 0.3);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const lensDot = document.createElementNS(ns, "circle");
        lensDot.setAttribute("cx", 0);
        lensDot.setAttribute("cy", -size * 0.35);
        lensDot.setAttribute("r", size * 0.12);
        lensDot.style.fill = "#3b82f6";
        g.appendChild(lensDot);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.5);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#f59e0b";
        g.appendChild(btn);
        return g;
       }
       if (shape === "smart-lock") {
        const g = document.createElementNS(ns, "g");
        const shackle = document.createElementNS(ns, "path");
        shackle.setAttribute("d", `M ${-size * 0.4} ${-size * 0.1} L ${-size * 0.4} ${-size * 0.6} A ${size * 0.4} ${size * 0.4} 0 1 1 ${size * 0.4} ${-size * 0.6} L ${size * 0.4} ${-size * 0.1}`);
        shackle.style.fill = "none";
        shackle.style.strokeWidth = size * 0.2;
        g.appendChild(shackle);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.6);
        body.setAttribute("y", -size * 0.15);
        body.setAttribute("width", size * 1.2);
        body.setAttribute("height", size * 1);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const keyhole = document.createElementNS(ns, "circle");
        keyhole.setAttribute("cx", 0);
        keyhole.setAttribute("cy", size * 0.3);
        keyhole.setAttribute("r", size * 0.15);
        keyhole.style.fill = "#4ade80";
        g.appendChild(keyhole);
        return g;
       }
       if (shape === "smart-bulb") {
        const g = document.createElementNS(ns, "g");
        const bulb = document.createElementNS(ns, "path");
        bulb.setAttribute("d", `M ${-size * 0.5} ${size * 0.2} Q ${-size * 0.8} ${-size * 0.3} ${-size * 0.5} ${-size * 0.7} Q 0 ${-size * 1.1} ${size * 0.5} ${-size * 0.7} Q ${size * 0.8} ${-size * 0.3} ${size * 0.5} ${size * 0.2} Z`);
        g.appendChild(bulb);
        const base1 = document.createElementNS(ns, "rect");
        base1.setAttribute("x", -size * 0.35);
        base1.setAttribute("y", size * 0.2);
        base1.setAttribute("width", size * 0.7);
        base1.setAttribute("height", size * 0.15);
        base1.style.fill = "#94a3b8";
        g.appendChild(base1);
        const base2 = document.createElementNS(ns, "rect");
        base2.setAttribute("x", -size * 0.3);
        base2.setAttribute("y", size * 0.35);
        base2.setAttribute("width", size * 0.6);
        base2.setAttribute("height", size * 0.15);
        base2.style.fill = "#64748b";
        g.appendChild(base2);
        const base3 = document.createElementNS(ns, "rect");
        base3.setAttribute("x", -size * 0.25);
        base3.setAttribute("y", size * 0.5);
        base3.setAttribute("width", size * 0.5);
        base3.setAttribute("height", size * 0.2);
        base3.setAttribute("rx", 2);
        base3.style.fill = "#475569";
        g.appendChild(base3);
        return g;
       }
       if (shape === "smart-plug") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const hole1 = document.createElementNS(ns, "rect");
        hole1.setAttribute("x", -size * 0.35);
        hole1.setAttribute("y", -size * 0.3);
        hole1.setAttribute("width", size * 0.15);
        hole1.setAttribute("height", size * 0.4);
        hole1.setAttribute("rx", 2);
        hole1.style.fill = "#1e293b";
        g.appendChild(hole1);
        const hole2 = document.createElementNS(ns, "rect");
        hole2.setAttribute("x", size * 0.2);
        hole2.setAttribute("y", -size * 0.3);
        hole2.setAttribute("width", size * 0.15);
        hole2.setAttribute("height", size * 0.4);
        hole2.setAttribute("rx", 2);
        hole2.style.fill = "#1e293b";
        g.appendChild(hole2);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.35);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "smart-speaker") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.6);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 1.2);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.3);
        g.appendChild(body);
        const mesh = document.createElementNS(ns, "rect");
        mesh.setAttribute("x", -size * 0.5);
        mesh.setAttribute("y", -size * 0.3);
        mesh.setAttribute("width", size);
        mesh.setAttribute("height", size * 1.1);
        mesh.setAttribute("rx", 4);
        mesh.style.fill = "#1e293b";
        g.appendChild(mesh);
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", 0);
        ring.setAttribute("cy", -size * 0.65);
        ring.setAttribute("r", size * 0.2);
        ring.style.fill = "#3b82f6";
        g.appendChild(ring);
        return g;
       }
       if (shape === "smart-tv") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size * 1.4);
        frame.setAttribute("y", -size * 0.85);
        frame.setAttribute("width", size * 2.8);
        frame.setAttribute("height", size * 1.6);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 1.3);
        screen.setAttribute("y", -size * 0.75);
        screen.setAttribute("width", size * 2.6);
        screen.setAttribute("height", size * 1.4);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const stand = document.createElementNS(ns, "rect");
        stand.setAttribute("x", -size * 0.8);
        stand.setAttribute("y", size * 0.75);
        stand.setAttribute("width", size * 1.6);
        stand.setAttribute("height", size * 0.12);
        stand.setAttribute("rx", 2);
        g.appendChild(stand);
        return g;
       }
       if (shape === "hub") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.5 + i * size * 0.35);
         led.setAttribute("cy", 0);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#3b82f6", "#f59e0b", "#ef4444"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "smoke-detector") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.6);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 6; i++) {
         const slot = document.createElementNS(ns, "rect");
         const angle = (i * 60 - 90) * Math.PI / 180;
         slot.setAttribute("x", Math.cos(angle) * size * 0.35 - size * 0.08);
         slot.setAttribute("y", Math.sin(angle) * size * 0.35 - size * 0.03);
         slot.setAttribute("width", size * 0.16);
         slot.setAttribute("height", size * 0.06);
         slot.setAttribute("rx", 1);
         slot.style.fill = "#475569";
         slot.setAttribute("transform", `rotate(${i * 60}, ${Math.cos(angle) * size * 0.35}, ${Math.sin(angle) * size * 0.35})`);
         g.appendChild(slot);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "motion-sensor") {
        const g = document.createElementNS(ns, "g");
        const dome = document.createElementNS(ns, "path");
        dome.setAttribute("d", `M ${-size * 0.8} ${size * 0.3} Q ${-size * 0.8} ${-size * 0.8} 0 ${-size * 0.8} Q ${size * 0.8} ${-size * 0.8} ${size * 0.8} ${size * 0.3} Z`);
        g.appendChild(dome);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.8);
        base.setAttribute("y", size * 0.3);
        base.setAttribute("width", size * 1.6);
        base.setAttribute("height", size * 0.35);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        const lens = document.createElementNS(ns, "ellipse");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.15);
        lens.setAttribute("rx", size * 0.35);
        lens.setAttribute("ry", size * 0.25);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.45);
        led.setAttribute("r", size * 0.08);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "garage") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size);
        frame.setAttribute("y", -size * 0.9);
        frame.setAttribute("width", size * 2);
        frame.setAttribute("height", size * 1.8);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        for (let i = 0; i < 4; i++) {
         const panel = document.createElementNS(ns, "rect");
         panel.setAttribute("x", -size * 0.9);
         panel.setAttribute("y", -size * 0.8 + i * size * 0.42);
         panel.setAttribute("width", size * 1.8);
         panel.setAttribute("height", size * 0.35);
         panel.setAttribute("rx", 2);
         panel.style.fill = "#1e293b";
         g.appendChild(panel);
        }
        return g;
       }
       if (shape === "sprinkler") {
        const g = document.createElementNS(ns, "g");
        const head = document.createElementNS(ns, "circle");
        head.setAttribute("r", size * 0.5);
        g.appendChild(head);
        const nozzle = document.createElementNS(ns, "rect");
        nozzle.setAttribute("x", -size * 0.15);
        nozzle.setAttribute("y", size * 0.3);
        nozzle.setAttribute("width", size * 0.3);
        nozzle.setAttribute("height", size * 0.5);
        g.appendChild(nozzle);
        for (let i = 0; i < 5; i++) {
         const spray = document.createElementNS(ns, "line");
         const angle = (-60 + i * 30) * Math.PI / 180;
         spray.setAttribute("x1", 0);
         spray.setAttribute("y1", -size * 0.3);
         spray.setAttribute("x2", Math.cos(angle) * size * 0.8);
         spray.setAttribute("y2", Math.sin(angle) * size * 0.8 - size * 0.3);
         spray.style.stroke = "#3b82f6";
         spray.style.strokeWidth = "2";
         spray.style.strokeDasharray = "3,3";
         g.appendChild(spray);
        }
        return g;
       }
       if (shape === "vacuum") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("r", size);
        g.appendChild(body);
        const top = document.createElementNS(ns, "circle");
        top.setAttribute("r", size * 0.7);
        top.style.fill = "#1e293b";
        g.appendChild(top);
        const bumper = document.createElementNS(ns, "path");
        bumper.setAttribute("d", `M ${-size * 0.7} ${-size * 0.4} A ${size * 0.8} ${size * 0.8} 0 0 1 ${size * 0.7} ${-size * 0.4}`);
        bumper.style.fill = "none";
        bumper.style.strokeWidth = size * 0.15;
        g.appendChild(bumper);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.1);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#4ade80";
        g.appendChild(btn);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
function updateFovCone(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node) return;
  
  const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
  if (!nodeGroup) return;
  const existingFov = nodeGroup.querySelector(".fov-group");
  if (existingFov) existingFov.remove();
  if (!hasCoverageZone(node.shape) || !node.fovEnabled) return;
  
  const ns = "http://www.w3.org/2000/svg";
  const defaults = getCoverageDefaults(node.shape);
  const fovAngle = node.fovAngle || defaults.angle;
  const fovDistance = node.fovDistance || defaults.distance;
  const fovInnerRadius = node.fovInnerRadius || 0;
  const fovRotation = node.fovRotation || 0;
  const fovColor = node.fovColor || "#f59e0b";
  const fovOpacity = node.fovOpacity || 20;
  const fovGradient = node.fovGradient || false;
  const fovBorderColor = node.fovBorderColor || "#f59e0b";
  const fovBorderWidth = node.fovBorderWidth ?? 2;
  const fovBorderStyle = node.fovBorderStyle || "solid";
  const fovBorderOpacity = node.fovBorderOpacity ?? 100;
  const fovLabel = node.fovLabel || "";
  const fovAnimate = node.fovAnimate || false;
  const fovAnimationType = node.fovAnimationType || defaults.animationType;
  const fovSweep = node.fovSweep || 120;
  const fovSpeed = node.fovSpeed || 4;
  
  const fovGroup = document.createElementNS(ns, "g");
  fovGroup.classList.add("fov-group");
  
  if (fovGradient) {
    const gradientId = `fov-gradient-${nodeId}`;
    const defs = document.createElementNS(ns, "defs");
    const gradient = document.createElementNS(ns, "radialGradient");
    gradient.id = gradientId;
    gradient.setAttribute("cx", "0");
    gradient.setAttribute("cy", "0");
    gradient.setAttribute("r", fovDistance);
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    
    const stop1 = document.createElementNS(ns, "stop");
    stop1.setAttribute("offset", fovInnerRadius / fovDistance);
    stop1.setAttribute("stop-color", fovColor);
    stop1.setAttribute("stop-opacity", fovOpacity / 100);
    
    const stop2 = document.createElementNS(ns, "stop");
    stop2.setAttribute("offset", "1");
    stop2.setAttribute("stop-color", fovColor);
    stop2.setAttribute("stop-opacity", "0");
    
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
    fovGroup.appendChild(defs);
  }
  
  const fovPath = document.createElementNS(ns, "path");
  
  if (fovAngle >= 360) {
    if (fovInnerRadius > 0) {
      fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
      fovPath.setAttribute("fill-rule", "evenodd");
    } else {
      fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
    }
  } else {
    const angleRad = (fovAngle * Math.PI) / 180;
    const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
    
    const startAngle = rotationRad - angleRad / 2;
    const endAngle = rotationRad + angleRad / 2;
    
    const x1 = Math.cos(startAngle) * fovDistance;
    const y1 = Math.sin(startAngle) * fovDistance;
    const x2 = Math.cos(endAngle) * fovDistance;
    const y2 = Math.sin(endAngle) * fovDistance;
    
    const largeArc = fovAngle > 180 ? 1 : 0;
    
    if (fovInnerRadius > 0) {
      const ix1 = Math.cos(startAngle) * fovInnerRadius;
      const iy1 = Math.sin(startAngle) * fovInnerRadius;
      const ix2 = Math.cos(endAngle) * fovInnerRadius;
      const iy2 = Math.sin(endAngle) * fovInnerRadius;
      fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
    } else {
      fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
    }
  }
  
  if (fovGradient) {
    fovPath.style.fill = `url(#fov-gradient-${nodeId})`;
  } else {
    const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
    fovPath.style.fill = fovColor + opacityHex;
  }
  
  const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
  fovPath.style.stroke = fovBorderColor + borderOpacityHex;
  fovPath.style.strokeWidth = fovBorderWidth;
  if (fovBorderStyle === "dashed") {
    fovPath.style.strokeDasharray = "10,5";
  } else if (fovBorderStyle === "dotted") {
    fovPath.style.strokeDasharray = "3,3";
  }
  fovPath.style.pointerEvents = "none";
  fovPath.classList.add("fov-cone");
  
  fovGroup.appendChild(fovPath);
  
  if (fovLabel) {
    const fovLabelPosition = node.fovLabelPosition || "center";
    const fovLabelSize = node.fovLabelSize || 14;
    const fovLabelColor = node.fovLabelColor || "#ffffff";
    const fovLabelBold = node.fovLabelBold || false;
    const fovLabelBg = node.fovLabelBg || false;
    const fovLabelBgColor = node.fovLabelBgColor || "#000000";
    
    let labelDistance;
    if (fovLabelPosition === "center") {
      labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
    } else if (fovLabelPosition === "edge") {
      labelDistance = fovDistance * 0.75;
    } else {
      labelDistance = fovDistance + fovLabelSize + 8;
    }
    
    const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
    const fovLabelOffsetX = node.fovLabelOffsetX || 0;
    const fovLabelOffsetY = node.fovLabelOffsetY || 0;
    const labelX = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance) + fovLabelOffsetX;
    const labelY = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance) + fovLabelOffsetY;
    
    if (fovLabelBg) {
      const bgRect = document.createElementNS(ns, "rect");
      const textWidth = fovLabel.length * fovLabelSize * 0.6;
      const textHeight = fovLabelSize * 1.4;
      bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
      bgRect.setAttribute("y", labelY - textHeight / 2);
      bgRect.setAttribute("width", textWidth + 12);
      bgRect.setAttribute("height", textHeight);
      bgRect.setAttribute("rx", "4");
      bgRect.style.fill = fovLabelBgColor;
      bgRect.style.opacity = "0.8";
      bgRect.style.pointerEvents = "none";
      fovGroup.appendChild(bgRect);
    }
    
    const labelEl = document.createElementNS(ns, "text");
    labelEl.setAttribute("x", labelX);
    labelEl.setAttribute("y", labelY);
    labelEl.setAttribute("text-anchor", "middle");
    labelEl.setAttribute("dominant-baseline", "middle");
    labelEl.style.fill = fovLabelColor;
    labelEl.style.fontSize = fovLabelSize + "px";
    labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
    labelEl.style.fontFamily = "system-ui, sans-serif";
    labelEl.style.pointerEvents = "none";
    labelEl.textContent = fovLabel;
    fovGroup.appendChild(labelEl);
  }
  
  if (fovAnimate) {
    const animationName = `fov-anim-${nodeId}`;
    const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
    
    if (fovAnimationType === "sweep" && fovAngle < 360) {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: rotate(0deg); }
          50% { transform: rotate(${fovSweep}deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "pulse") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.1); opacity: 0.7; }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "rings") {

      for (let i = 1; i <= 3; i++) {
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", "0");
        ring.setAttribute("cy", "0");
        ring.setAttribute("r", fovDistance * 0.3 * i);
        ring.style.fill = "none";
        ring.style.stroke = fovBorderColor;
        ring.style.strokeWidth = "2";
        ring.style.opacity = "0";
        const ringAnimName = `${animationName}-ring-${i}`;
        const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
        ringStyle.textContent = `
          @keyframes ${ringAnimName} {
            0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
            100% { r: ${fovDistance}; opacity: 0; }
          }
        `;
        ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
        ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
        fovGroup.appendChild(ringStyle);
        fovGroup.appendChild(ring);
      }
    } else if (fovAnimationType === "spin") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
      fovGroup.style.transformOrigin = "0 0";
    }
    
    if (fovAnimationType !== "rings") {
      fovGroup.appendChild(styleEl);
      const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
      const animationOffset = elapsedSeconds % fovSpeed;
      fovGroup.style.animationDelay = `-${animationOffset}s`;
    }
  }
  
  nodeGroup.insertBefore(fovGroup, nodeGroup.firstChild);
}
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const flowArrowBig = document.createElementNS(ns, "path");
       flowArrowBig.id = "flow-arrow-big";
       flowArrowBig.setAttribute("d", "M-6,-4 L6,0 L-6,4 L-3,0 Z");
       defs.appendChild(flowArrowBig);
       const flowArrowSmall = document.createElementNS(ns, "path");
       flowArrowSmall.id = "flow-arrow-small";
       flowArrowSmall.setAttribute("d", "M-4,-3 L4,0 L-4,3 Z");
       defs.appendChild(flowArrowSmall);
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
defs.appendChild(markerBackward);
const wallPattern = document.createElementNS(ns, "pattern");
wallPattern.id = "wall-hatch";
wallPattern.setAttribute("patternUnits", "userSpaceOnUse");
wallPattern.setAttribute("width", "8");
wallPattern.setAttribute("height", "8");
wallPattern.setAttribute("patternTransform", "rotate(45)");
const wallLine = document.createElementNS(ns, "line");
wallLine.setAttribute("x1", "0");
wallLine.setAttribute("y1", "0");
wallLine.setAttribute("x2", "0");
wallLine.setAttribute("y2", "8");
wallLine.setAttribute("stroke", "#666");
wallLine.setAttribute("stroke-width", "2");
wallPattern.appendChild(wallLine);
defs.appendChild(wallPattern);

svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack" && PAGE_STATE.canvasGridEnabled !== false) {
const gridGroup = document.createElementNS(ns, "g");
 gridGroup.id = "canvas-grid";
 const gridSize = PAGE_STATE.canvasGridSize || 50;
 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", x);
  line.setAttribute("y1", CANVAS_PADDING);
  line.setAttribute("x2", x);
  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", CANVAS_PADDING);
  line.setAttribute("y1", y);
  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
  line.setAttribute("y2", y);
  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 svg.appendChild(gridGroup);
}
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
 const y = RACK_START_Y + u * rackUHeight;
 if (PAGE_STATE.rackGridEnabled !== false) {
 const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
 }
 if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
else if (rect.lineStyle === "wall") {
  rectEl.style.fill = rect.color;
  rectEl.style.fillOpacity = "0.5";
  rectEl.style.stroke = rect.borderColor || rect.color;
  rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
  const hatchGroup = document.createElementNS(ns, "g");
  hatchGroup.classList.add("wall-hatch-lines");
  hatchGroup.style.pointerEvents = "none";
  const spacing = 12;
  const hatchColor = rect.borderColor || rect.color;
  for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
    const line = document.createElementNS(ns, "line");
    line.setAttribute("x1", rect.x + i);
    line.setAttribute("y1", rect.y);
    line.setAttribute("x2", rect.x + i - rect.height);
    line.setAttribute("y2", rect.y + rect.height);
    line.style.stroke = hatchColor;
    line.style.strokeWidth = "2";
    hatchGroup.appendChild(line);
  }
  const clipId = "clip-" + rect.id;
  const clipPath = document.createElementNS(ns, "clipPath");
  clipPath.id = clipId;
  const clipRect = document.createElementNS(ns, "rect");
  clipRect.setAttribute("x", rect.x);
  clipRect.setAttribute("y", rect.y);
  clipRect.setAttribute("width", rect.width);
  clipRect.setAttribute("height", rect.height);
  clipPath.appendChild(clipRect);
  defs.appendChild(clipPath);
  hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
  g.appendChild(hatchGroup);
}
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
      handle.setAttribute("r", handleSize);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x));
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y));
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
if (lineStyle === "dashed") {
 poly.style.strokeDasharray = "10,5";
} else if (lineStyle === "dotted") {
 poly.style.strokeDasharray = "2,4";
} else if (lineStyle === "wall") {
 poly.style.stroke = "url(#wall-hatch)";
 poly.style.strokeWidth = (edge.width || 4) * 3;
 poly.style.strokeDasharray = "none";
} else {
 poly.style.strokeDasharray = "none";
}
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const animDir = PAGE_STATE.animationDirection || "all";
         const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && direction !== "none" && edge.points.length >= 2 && (animDir === "all" || animDir === direction);
         if (shouldAnimate) {
          poly.style.opacity = "0.25";
          const polyPathD = "M " + edge.points.map(p => `${p.x} ${p.y}`).join(" L ");
          const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
          const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
          const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
          const arrowCount = 3;
          const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
          if (direction === "forward" || direction === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${polyPathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
            arrow.classList.add("edge-arrow-forward");
            svg.appendChild(arrow);
           }
          }
          if (direction === "backward" || direction === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${polyPathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (direction === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
            arrow.classList.add("edge-arrow-backward");
            svg.appendChild(arrow);
           }
          }
         }
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const routing = edge.routing || "curved";
        let pathD;
        if (routing === "straight") {
         pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
        }
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", pathD);
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const edgeDirection = edge.direction || "none";
        const edgeLineStyle = edge.lineStyle || "solid";
        if (edgeLineStyle === "dashed") { path.style.strokeDasharray = "10,5"; }
        else if (edgeLineStyle === "dotted") { path.style.strokeDasharray = "2,4"; }
        if (edgeDirection === "forward") {
         path.setAttribute("marker-end", "url(#arrow-forward)");
        } else if (edgeDirection === "backward") {
         path.setAttribute("marker-start", "url(#arrow-backward)");
        } else if (edgeDirection === "both") {
         path.setAttribute("marker-start", "url(#arrow-backward)");
         path.setAttribute("marker-end", "url(#arrow-forward)");
        }
        const animDir = PAGE_STATE.animationDirection || "all";
        const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && edgeDirection !== "none" && (animDir === "all" || animDir === edgeDirection);
        if (shouldAnimate) {
         path.style.opacity = "0.25";
         const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
         const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
         const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
         const arrowCount = 3;
         const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
         if (edgeDirection === "forward" || edgeDirection === "both") {
          for (let i = 0; i < arrowCount; i++) {
           const arrow = document.createElementNS(ns, "use");
           arrow.setAttribute("href", arrowId);
           arrow.style.fill = arrowColor;
           arrow.style.offsetPath = `path('${pathD}')`;
           arrow.style.animationDuration = animDuration + "s";
           arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
           arrow.classList.add("edge-arrow-forward");
           svg.appendChild(arrow);
          }
         }
         if (edgeDirection === "backward" || edgeDirection === "both") {
          for (let i = 0; i < arrowCount; i++) {
           const arrow = document.createElementNS(ns, "use");
           arrow.setAttribute("href", arrowId);
           arrow.style.fill = arrowColor;
           arrow.style.offsetPath = `path('${pathD}')`;
           arrow.style.animationDuration = animDuration + "s";
           arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (edgeDirection === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
           arrow.classList.add("edge-arrow-backward");
           svg.appendChild(arrow);
          }
         }
        }
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", pathD);
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        const nodeRotation = NODE_DATA[id].rotation || 0;
        g.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${nodeRotation})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text");
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
if (hasCoverageZone(node.shape) && node.fovEnabled) {
  const defaults = getCoverageDefaults(node.shape);
  const fovAngle = node.fovAngle || defaults.angle;
  const fovDistance = node.fovDistance || defaults.distance;
  const fovInnerRadius = node.fovInnerRadius || 0;
  const fovRotation = node.fovRotation || 0;
  const fovColor = node.fovColor || "#f59e0b";
  const fovOpacity = node.fovOpacity || 20;
  const fovGradient = node.fovGradient || false;
  const fovBorderColor = node.fovBorderColor || "#f59e0b";
  const fovBorderWidth = node.fovBorderWidth ?? 2;
  const fovBorderStyle = node.fovBorderStyle || "solid";
  const fovBorderOpacity = node.fovBorderOpacity ?? 100;
  const fovLabel = node.fovLabel || "";
  const fovAnimate = node.fovAnimate || false;
  const fovAnimationType = node.fovAnimationType || defaults.animationType;
  const fovSweep = node.fovSweep || 120;
  const fovSpeed = node.fovSpeed || 4;
  
  const fovGroup = document.createElementNS(ns, "g");
  fovGroup.classList.add("fov-group");
  
  if (fovGradient) {
    const gradientId = `fov-gradient-${id}`;
    const defs = document.createElementNS(ns, "defs");
    const gradient = document.createElementNS(ns, "radialGradient");
    gradient.id = gradientId;
    gradient.setAttribute("cx", "0");
    gradient.setAttribute("cy", "0");
    gradient.setAttribute("r", fovDistance);
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    const stop1 = document.createElementNS(ns, "stop");
    stop1.setAttribute("offset", fovInnerRadius / fovDistance);
    stop1.setAttribute("stop-color", fovColor);
    stop1.setAttribute("stop-opacity", fovOpacity / 100);
    const stop2 = document.createElementNS(ns, "stop");
    stop2.setAttribute("offset", "1");
    stop2.setAttribute("stop-color", fovColor);
    stop2.setAttribute("stop-opacity", "0");
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
    fovGroup.appendChild(defs);
  }
  
  const fovPath = document.createElementNS(ns, "path");
  
  if (fovAngle >= 360) {
    if (fovInnerRadius > 0) {
      fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
      fovPath.setAttribute("fill-rule", "evenodd");
    } else {
      fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
    }
  } else {
    const angleRad = (fovAngle * Math.PI) / 180;
    const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
    const startAngle = rotationRad - angleRad / 2;
    const endAngle = rotationRad + angleRad / 2;
    const x1 = Math.cos(startAngle) * fovDistance;
    const y1 = Math.sin(startAngle) * fovDistance;
    const x2 = Math.cos(endAngle) * fovDistance;
    const y2 = Math.sin(endAngle) * fovDistance;
    const largeArc = fovAngle > 180 ? 1 : 0;
    
    if (fovInnerRadius > 0) {
      const ix1 = Math.cos(startAngle) * fovInnerRadius;
      const iy1 = Math.sin(startAngle) * fovInnerRadius;
      const ix2 = Math.cos(endAngle) * fovInnerRadius;
      const iy2 = Math.sin(endAngle) * fovInnerRadius;
      fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
    } else {
      fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
    }
  }
  
  if (fovGradient) {
    fovPath.style.fill = `url(#fov-gradient-${id})`;
  } else {
    const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
    fovPath.style.fill = fovColor + opacityHex;
  }
  
  const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
  fovPath.style.stroke = fovBorderColor + borderOpacityHex;
  fovPath.style.strokeWidth = fovBorderWidth;
  if (fovBorderStyle === "dashed") {
    fovPath.style.strokeDasharray = "10,5";
  } else if (fovBorderStyle === "dotted") {
    fovPath.style.strokeDasharray = "3,3";
  }
  fovPath.style.pointerEvents = "none";
  fovPath.classList.add("fov-cone");
  
  fovGroup.appendChild(fovPath);
  
  if (fovLabel) {
    const fovLabelPosition = node.fovLabelPosition || "center";
    const fovLabelSize = node.fovLabelSize || 14;
    const fovLabelColor = node.fovLabelColor || "#ffffff";
    const fovLabelBold = node.fovLabelBold || false;
    const fovLabelBg = node.fovLabelBg || false;
    const fovLabelBgColor = node.fovLabelBgColor || "#000000";
    
    let labelDistance;
    if (fovLabelPosition === "center") {
      labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
    } else if (fovLabelPosition === "edge") {
      labelDistance = fovDistance * 0.75;
    } else {
      labelDistance = fovDistance + fovLabelSize + 8;
    }
    
    const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
    const labelX = fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance;
    const labelY = fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance;
    
    if (fovLabelBg) {
      const bgRect = document.createElementNS(ns, "rect");
      const textWidth = fovLabel.length * fovLabelSize * 0.6;
      const textHeight = fovLabelSize * 1.4;
      bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
      bgRect.setAttribute("y", labelY - textHeight / 2);
      bgRect.setAttribute("width", textWidth + 12);
      bgRect.setAttribute("height", textHeight);
      bgRect.setAttribute("rx", "4");
      bgRect.style.fill = fovLabelBgColor;
      bgRect.style.opacity = "0.8";
      bgRect.style.pointerEvents = "none";
      fovGroup.appendChild(bgRect);
    }
    
    const labelEl = document.createElementNS(ns, "text");
    labelEl.setAttribute("x", labelX);
    labelEl.setAttribute("y", labelY);
    labelEl.setAttribute("text-anchor", "middle");
    labelEl.setAttribute("dominant-baseline", "middle");
    labelEl.style.fill = fovLabelColor;
    labelEl.style.fontSize = fovLabelSize + "px";
    labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
    labelEl.style.fontFamily = "system-ui, sans-serif";
    labelEl.style.pointerEvents = "none";
    labelEl.textContent = fovLabel;
    fovGroup.appendChild(labelEl);
  }
  
  if (fovAnimate) {
    const animationName = `fov-anim-${id}`;
    const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
    
    if (fovAnimationType === "sweep" && fovAngle < 360) {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: rotate(0deg); }
          50% { transform: rotate(${fovSweep}deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "pulse") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.1); opacity: 0.7; }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "rings") {
      for (let i = 1; i <= 3; i++) {
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", "0");
        ring.setAttribute("cy", "0");
        ring.setAttribute("r", fovDistance * 0.3 * i);
        ring.style.fill = "none";
        ring.style.stroke = fovBorderColor;
        ring.style.strokeWidth = "2";
        ring.style.opacity = "0";
        const ringAnimName = `${animationName}-ring-${i}`;
        const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
        ringStyle.textContent = `
          @keyframes ${ringAnimName} {
            0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
            100% { r: ${fovDistance}; opacity: 0; }
          }
        `;
        ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
        ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
        fovGroup.appendChild(ringStyle);
        fovGroup.appendChild(ring);
      }
    } else if (fovAnimationType === "spin") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
      fovGroup.style.transformOrigin = "0 0";
    }
    
    if (fovAnimationType !== "rings") {
      fovGroup.appendChild(styleEl);
      const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
      const animationOffset = elapsedSeconds % fovSpeed;
      fovGroup.style.animationDelay = `-${animationOffset}s`;
    }
  }
  
  g.appendChild(fovGroup);
}
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId);
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         });
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId);
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
else if (rect.lineStyle === "wall") {
  rectEl.style.fill = rect.color;
  rectEl.style.fillOpacity = "0.5";
  rectEl.style.stroke = rect.borderColor || rect.color;
  rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
  const hatchGroup = document.createElementNS(ns, "g");
  hatchGroup.classList.add("wall-hatch-lines");
  hatchGroup.style.pointerEvents = "none";
  const spacing = 12;
  const hatchColor = rect.borderColor || rect.color;
  for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
    const line = document.createElementNS(ns, "line");
    line.setAttribute("x1", rect.x + i);
    line.setAttribute("y1", rect.y);
    line.setAttribute("x2", rect.x + i - rect.height);
    line.setAttribute("y2", rect.y + rect.height);
    line.style.stroke = hatchColor;
    line.style.strokeWidth = "2";
    hatchGroup.appendChild(line);
  }
  const clipId = "clip-" + rect.id;
  const clipPath = document.createElementNS(ns, "clipPath");
  clipPath.id = clipId;
  const clipRect = document.createElementNS(ns, "rect");
  clipRect.setAttribute("x", rect.x);
  clipRect.setAttribute("y", rect.y);
  clipRect.setAttribute("width", rect.width);
  clipRect.setAttribute("height", rect.height);
  clipPath.appendChild(clipRect);
  defs.appendChild(clipPath);
  hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
  g.appendChild(hatchGroup);
}
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner, idx) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
               const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 3;
               const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
               handle.setAttribute("r", handleSize);
               handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
                 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          const textRotation = textItem.rotation || 0;
          if (textRotation !== 0) {
            g.setAttribute("transform", `rotate(${textRotation}, ${textItem.x}, ${textItem.y})`);
          }
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateZoneLegend();
       updateMinimap();
       populateRackDropdown();
       if (currentSearchQuery && currentSearchResults.length > 0) {
        highlightSearchResults(currentSearchResults, true);
       }
      }
      const _forgeTheTopologyImpl = forgeTheTopology;
      forgeTheTopology = function(immediate = false) {
       if (immediate || forgeImmediate) {
        forgeImmediate = false;
        clearTimeout(forgeDebounceTimer);
        _forgeTheTopologyImpl();
        return;
       }
       clearTimeout(forgeDebounceTimer);
       forgeDebounceTimer = setTimeout(() => {
        _forgeTheTopologyImpl();
       }, 16);
      };
      function forgeTheTopologyImmediate() {
       forgeImmediate = true;
       forgeTheTopology();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         });
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
const fovSection = document.getElementById("fov-section");
if (fovSection) {
  if (hasCoverageZone(data.shape)) {
    const defaults = getCoverageDefaults(data.shape);
    fovSection.style.display = "block";
    document.getElementById("fov-enabled").checked = data.fovEnabled || false;
    document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
    document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "°";
    document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
    document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
    document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
    document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
    document.getElementById("fov-rotation").value = data.fovRotation || 0;
    document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "°";
    document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
    document.getElementById("fov-opacity").value = data.fovOpacity || 20;
    document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
    document.getElementById("fov-gradient").checked = data.fovGradient || false;
    document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
    document.getElementById("fov-border-width").value = data.fovBorderWidth ?? 2;
    document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth ?? 2;
    document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
    document.getElementById("fov-border-opacity").value = data.fovBorderOpacity ?? 100;
    document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity ?? 100) + "%";
    document.getElementById("fov-label").value = data.fovLabel || "";
    document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
    document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
    document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
    document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
    document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
    document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
    document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
    document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
    document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
    document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
    document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
    document.getElementById("fov-animate").checked = data.fovAnimate || false;
    document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
    document.getElementById("fov-sweep").value = data.fovSweep || 120;
    document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "°";
    document.getElementById("fov-speed").value = data.fovSpeed || 4;
    document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
  } else {
    fovSection.style.display = "none";
  }
}
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '↔';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
document.getElementById("fov-enabled").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage zone");
  NODE_DATA[currentNodeId].fovEnabled = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-angle").oninput = function() {
  document.getElementById("fov-angle-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovAngle = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-distance").oninput = function() {
  document.getElementById("fov-distance-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovDistance = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-inner-radius").oninput = function() {
  document.getElementById("fov-inner-radius-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovInnerRadius = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-rotation").oninput = function() {
  document.getElementById("fov-rotation-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovRotation = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-color").oninput = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage color");
  NODE_DATA[currentNodeId].fovColor = this.value;
  updateFovCone(currentNodeId);
  updateZoneLegend();
};
document.getElementById("fov-opacity").oninput = function() {
  document.getElementById("fov-opacity-value").textContent = this.value + "%";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovOpacity = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-gradient").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage gradient");
  NODE_DATA[currentNodeId].fovGradient = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-color").oninput = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage border color");
  NODE_DATA[currentNodeId].fovBorderColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-width").oninput = function() {
  document.getElementById("fov-border-width-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovBorderWidth = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-style").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage border style");
  NODE_DATA[currentNodeId].fovBorderStyle = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-opacity").oninput = function() {
  document.getElementById("fov-border-opacity-value").textContent = this.value + "%";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovBorderOpacity = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabel = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-position").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelPosition = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-size").oninput = function() {
  document.getElementById("fov-label-size-value").textContent = this.value + "px";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelSize = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-color").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bold").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBold = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bg").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBg = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bg-color").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBgColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-offset-x").oninput = function() {
  document.getElementById("fov-label-offset-x-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelOffsetX = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-offset-y").oninput = function() {
  document.getElementById("fov-label-offset-y-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelOffsetY = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-preset").addEventListener("change", function() {
  if (this.value) {
    applyZonePreset(this.value);
    this.value = "";
  }
});
document.getElementById("fov-save-preset").addEventListener("click", saveCustomZonePreset);
document.getElementById("fov-copy-style").addEventListener("click", function() {
  if (currentNodeId && copyZoneStyle(currentNodeId)) {
    alert("Zone style copied!");
  }
});
document.getElementById("fov-paste-style").addEventListener("click", function() {
  if (currentNodeId && pasteZoneStyle(currentNodeId)) {
    claimTheImmortal(currentNodeId);
  }
});
document.getElementById("bulk-zone-copy").addEventListener("click", bulkCopyZoneStyle);
document.getElementById("bulk-zone-paste").addEventListener("click", bulkPasteZoneStyle);
document.getElementById("bulk-zone-toggle").addEventListener("click", bulkToggleZones);
document.getElementById("bulk-zone-copy-mobile").addEventListener("click", bulkCopyZoneStyle);
document.getElementById("bulk-zone-paste-mobile").addEventListener("click", bulkPasteZoneStyle);
document.getElementById("bulk-zone-toggle-mobile").addEventListener("click", bulkToggleZones);
document.getElementById("fov-animate").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage animation");
  NODE_DATA[currentNodeId].fovAnimate = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-animation-type").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("change animation type");
  NODE_DATA[currentNodeId].fovAnimationType = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-sweep").oninput = function() {
  document.getElementById("fov-sweep-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovSweep = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-speed").oninput = function() {
  document.getElementById("fov-speed-value").textContent = this.value + "s";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovSpeed = parseInt(this.value);
  updateFovCone(currentNodeId);
};
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const currentRotation = NODE_DATA[id].rotation || 0;
       document.getElementById("rotation-slider").value = Math.max(-360, Math.min(360, currentRotation));
       document.getElementById("rotation-value").value = currentRotation;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p));
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         });
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          });
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       const routingSelect = document.getElementById("edge-routing");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       routingSelect.value = edge.routing || "curved";
       document.getElementById("edge-animate").checked = edge.animate === true;
       document.getElementById("edge-animation-style").value = edge.animationStyle || "";
       document.getElementById("edge-animation-speed").value = edge.animationSpeed || "";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       hint.style.cursor = "pointer";
       let hintDismissed = false;
       const dismissHint = () => { hintDismissed = true; hint.classList.remove("visible"); };
       hint.addEventListener("click", dismissHint);
       hint.addEventListener("touchend", (e) => { e.preventDefault(); dismissHint(); });
       setTimeout(() => {
        if (hintDismissed) return;
        hint.classList.add("visible");
        setTimeout(() => { if (!hintDismissed) hint.classList.remove("visible"); }, 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        });
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       let threeFingerTapStart = 0;
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 3) {
          e.preventDefault();
          threeFingerTapStart = Date.now();
         }
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        });
       viewport.addEventListener("touchend", (e) => {
        if (e.touches.length === 0 && threeFingerTapStart > 0) {
         const duration = Date.now() - threeFingerTapStart;
         if (duration < 500) {
          e.preventDefault();
          undo();
          if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
         }
         threeFingerTapStart = 0;
        }
       }, { passive: false });
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        });
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        });
       let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        });
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
       updateMinimap();
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
       updateMinimap();
      });
      const rotationSlider = document.getElementById("rotation-slider");
      const rotationInput = document.getElementById("rotation-value");
      const resetRotationBtn = document.getElementById("reset-rotation");
      rotationSlider.addEventListener("input", () => {
        const newRotation = parseInt(rotationSlider.value, 10);
        rotationInput.value = newRotation;
        pushUndo("rotate node");
        NODE_DATA[currentNodeId].rotation = newRotation;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
        }
      });
      rotationInput.addEventListener("input", () => {
        const newRotation = parseInt(rotationInput.value, 10) || 0;
        rotationSlider.value = Math.max(-360, Math.min(360, newRotation));
        pushUndo("rotate node");
        NODE_DATA[currentNodeId].rotation = newRotation;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
        }
      });
      resetRotationBtn.addEventListener("click", () => {
        pushUndo("reset rotation");
        NODE_DATA[currentNodeId].rotation = 0;
        rotationSlider.value = 0;
        rotationInput.value = 0;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(0)`);
        }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value));
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value));
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value));
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value));
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)));
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value));
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value));
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)));
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
const fovSection = document.getElementById("fov-section");
if (fovSection) {
  if (hasCoverageZone(shape)) {
    const defaults = getCoverageDefaults(shape);
    fovSection.style.display = "block";
    document.getElementById("fov-angle").value = defaults.angle;
    document.getElementById("fov-angle-value").textContent = defaults.angle + "°";
    document.getElementById("fov-distance").value = defaults.distance;
    document.getElementById("fov-distance-value").textContent = defaults.distance;
    document.getElementById("fov-animation-type").value = defaults.animationType;
  } else {
    fovSection.style.display = "none";
  }
}
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-routing").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge routing");
       edge.routing = document.getElementById("edge-routing").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-animate").addEventListener("change", (e) => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge animate");
       edge.animate = e.target.checked;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-animation-speed").addEventListener("change", (e) => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge animation speed");
       edge.animationSpeed = e.target.value || "";
       if (PAGE_STATE.animateConnections && edge.animate !== false) forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
	  document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, rect.rotation || 0));
      document.getElementById("rect-rotation-value").value = rect.rotation || 0;
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
document.getElementById("rect-rotation").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        rect.rotation = parseInt(document.getElementById("rect-rotation").value) || 0;
        document.getElementById("rect-rotation-value").value = rect.rotation;
        forgeTheTopology();
      });
      document.getElementById("rect-rotation-value").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        const val = parseInt(document.getElementById("rect-rotation-value").value) || 0;
        rect.rotation = val;
        document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, val));
        forgeTheTopology();
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId);
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        });
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const routingSelect = document.getElementById("add-line-routing");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        routing: routing,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else if (lineStyle === "wall") {
  freeDrawPolylineEl.style.stroke = "url(#wall-hatch)";
  freeDrawPolylineEl.style.strokeWidth = "12";
  freeDrawPolylineEl.style.strokeDasharray = "none"; 
  } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler);
           document.removeEventListener("touchend", touchUpHandler);
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         });
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawToggleBtn.classList.add("done-btn-active");
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       drawToggleBtn.classList.remove("done-btn-active");
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       });
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectToggleBtn.classList.add("done-btn-active");
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        rectToggleBtn.classList.remove("done-btn-active");
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.classList.add("done-btn-active");
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.classList.remove("done-btn-active");
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, textItem.rotation || 0));
       document.getElementById("text-rotation-val").value = textItem.rotation || 0;
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-rotation").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
          pushUndo("rotate text");
          textItem.rotation = parseInt(e.target.value) || 0;
          document.getElementById("text-rotation-val").value = textItem.rotation;
          forgeTheTopology();
        }
      });
      document.getElementById("text-rotation-val").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
          pushUndo("rotate text");
          const val = parseInt(e.target.value) || 0;
          textItem.rotation = val;
          document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, val));
          forgeTheTopology();
        }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("add-line-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "curved";
	   document.getElementById("anim-master").addEventListener("change", e => { ANIM_SETTINGS.masterAnim = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-sweep").addEventListener("change", e => { ANIM_SETTINGS.animTypes.sweep = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-pulse").addEventListener("change", e => { ANIM_SETTINGS.animTypes.pulse = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-rings").addEventListener("change", e => { ANIM_SETTINGS.animTypes.rings = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-spin").addEventListener("change", e => { ANIM_SETTINGS.animTypes.spin = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-connections").addEventListener("change", e => { ANIM_SETTINGS.animTypes.connections = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.animCategories.camera = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.animCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.animCategories.motion = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.animCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.animCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-connections").addEventListener("change", e => { ANIM_SETTINGS.animCategories.connections = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-master").addEventListener("change", e => { ANIM_SETTINGS.masterZones = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.camera = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.motion = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });

      document.getElementById("animation-style-select").value = PAGE_STATE.animationStyle || "arrows";
      document.getElementById("animation-direction-select").value = PAGE_STATE.animationDirection || "all";
      document.getElementById("animation-speed-select").value = PAGE_STATE.animationSpeed || 1.5;

      document.getElementById("animation-style-select").addEventListener("change", (e) => {
       PAGE_STATE.animationStyle = e.target.value;
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
      document.getElementById("animation-direction-select").addEventListener("change", (e) => {
       PAGE_STATE.animationDirection = e.target.value;
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
      document.getElementById("animation-speed-select").addEventListener("change", (e) => {
       PAGE_STATE.animationSpeed = parseFloat(e.target.value);
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
	   document.getElementById("canvas-grid-enabled").checked = PAGE_STATE.canvasGridEnabled !== false;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
	   document.getElementById("rack-grid-enabled").checked = PAGE_STATE.rackGridEnabled !== false;
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       rebuildThemeDropdown();
       updateDeleteButton();
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
const THEME_PRESETS = {
  defaulted: { panel:"#0b0e13",panelAlt:"#10141b",sidebarBg:"#10141b",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"rgba(9,12,20,0.9)",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#0f172a",toolbarBorder:"#1f2937",toolbarText:"#94a3b8",toolbarBtnBg:"#0b0e13",toolbarBtnText:"#e2e8f0",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#94a3b8",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#475569",canvasGrid:"#475569",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  slate: { panel:"#1e293b",panelAlt:"#334155",sidebarBg:"#1e293b",btnBg:"#334155",btnText:"#f1f5f9",accent:"#3b82f6",danger:"#ef4444",textMain:"#f1f5f9",textSoft:"#94a3b8",topbarBg:"#0f172a",topbarBorder:"#334155",nodeFill:"#334155",nodeStroke:"#3b82f6",nodeTitle:"#f1f5f9",nodeSub:"#94a3b8",defaultEdge:"#64748b",canvasGradientTop:"#1e293b",canvasGradientBottom:"#0f172a",tagFill:"#1e3a5f",tagText:"#93c5fd",tagBorder:"#3b82f6",inputBg:"#0f172a",inputText:"#f1f5f9",inputBorder:"#475569",toolbarBg:"#2563eb",toolbarBorder:"#3b82f6",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#f59e0b",groupIndicator:"#22d3ee",minimapDots:"#64748b",canvasHintBg:"#1e293b",canvasHintColor:"#94a3b8",canvasBorder:"#334155",canvasGrid:"#334155",rackFrameFill:"#1e293b",rackFrameStroke:"#3b82f6",rackLineColor:"#475569",rackTextColor:"#3b82f6" },
  graphite: { panel:"#1f2937",panelAlt:"#374151",sidebarBg:"#111827",btnBg:"#374151",btnText:"#f9fafb",accent:"#f59e0b",danger:"#ef4444",textMain:"#f9fafb",textSoft:"#9ca3af",topbarBg:"#111827",topbarBorder:"#4b5563",nodeFill:"#374151",nodeStroke:"#f59e0b",nodeTitle:"#f9fafb",nodeSub:"#9ca3af",defaultEdge:"#6b7280",canvasGradientTop:"#1f2937",canvasGradientBottom:"#111827",tagFill:"#44403c",tagText:"#fbbf24",tagBorder:"#f59e0b",inputBg:"#111827",inputText:"#f9fafb",inputBorder:"#4b5563",toolbarBg:"#b45309",toolbarBorder:"#f59e0b",toolbarText:"#ffffff",toolbarBtnBg:"#f59e0b",toolbarBtnText:"#000000",selectionHandle:"#10b981",groupIndicator:"#06b6d4",minimapDots:"#6b7280",canvasHintBg:"#1f2937",canvasHintColor:"#9ca3af",canvasBorder:"#4b5563",canvasGrid:"#374151",rackFrameFill:"#1f2937",rackFrameStroke:"#f59e0b",rackLineColor:"#4b5563",rackTextColor:"#fbbf24" },
  frost: { panel:"#f8fafc",panelAlt:"#e2e8f0",sidebarBg:"#f1f5f9",btnBg:"#e2e8f0",btnText:"#1e293b",accent:"#1e40af",danger:"#dc2626",textMain:"#0f172a",textSoft:"#475569",topbarBg:"#1e40af",topbarBorder:"#1e3a8a",nodeFill:"#ffffff",nodeStroke:"#1e40af",nodeTitle:"#0f172a",nodeSub:"#475569",defaultEdge:"#64748b",canvasGradientTop:"#e0e7ef",canvasGradientBottom:"#f8fafc",tagFill:"#dbeafe",tagText:"#1e40af",tagBorder:"#3b82f6",inputBg:"#ffffff",inputText:"#0f172a",inputBorder:"#cbd5e1",toolbarBg:"#1e40af",toolbarBorder:"#1e3a8a",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#ea580c",groupIndicator:"#059669",minimapDots:"#64748b",canvasHintBg:"#e2e8f0",canvasHintColor:"#475569",canvasBorder:"#cbd5e1",canvasGrid:"#cbd5e1",rackFrameFill:"#f1f5f9",rackFrameStroke:"#1e40af",rackLineColor:"#94a3b8",rackTextColor:"#1e40af" },
  synthwave: { panel:"#87366d",panelAlt:"#10141b",sidebarBg:"#340934",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"#781c67",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#b95aed",toolbarBorder:"#b800eb",toolbarText:"#000000",toolbarBtnBg:"#ed01fe",toolbarBtnText:"#000000",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#000000",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#000000",canvasGrid:"#000000",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  terminal: { panel:"#000000",panelAlt:"#0a0a0a",sidebarBg:"#050505",btnBg:"#0a0a0a",btnText:"#33ff33",accent:"#33ff33",danger:"#ffaa00",textMain:"#33ff33",textSoft:"#1a9a1a",topbarBg:"#000000",topbarBorder:"#33ff33",nodeFill:"#0a0a0a",nodeStroke:"#33ff33",nodeTitle:"#33ff33",nodeSub:"#1a9a1a",defaultEdge:"#1a9a1a",canvasGradientTop:"#0a0f0a",canvasGradientBottom:"#000000",tagFill:"#0a1a0a",tagText:"#33ff33",tagBorder:"#33ff33",inputBg:"#000000",inputText:"#33ff33",inputBorder:"#1a9a1a",toolbarBg:"#1a9a1a",toolbarBorder:"#33ff33",toolbarText:"#000000",toolbarBtnBg:"#33ff33",toolbarBtnText:"#000000",selectionHandle:"#ffaa00",groupIndicator:"#00ffff",minimapDots:"#33ff33",canvasHintBg:"#0a0a0a",canvasHintColor:"#1a9a1a",canvasBorder:"#1a9a1a",canvasGrid:"#0f1f0f",rackFrameFill:"#050505",rackFrameStroke:"#33ff33",rackLineColor:"#1a9a1a",rackTextColor:"#33ff33" },
  dracula: { panel:"#282a36",panelAlt:"#44475a",sidebarBg:"#21222c",btnBg:"#44475a",btnText:"#f8f8f2",accent:"#bd93f9",danger:"#ff5555",textMain:"#f8f8f2",textSoft:"#6272a4",topbarBg:"#21222c",topbarBorder:"#6272a4",nodeFill:"#44475a",nodeStroke:"#ff79c6",nodeTitle:"#f8f8f2",nodeSub:"#8be9fd",defaultEdge:"#bd93f9",canvasGradientTop:"#282a36",canvasGradientBottom:"#1a1b23",tagFill:"#3d3f4a",tagText:"#50fa7b",tagBorder:"#50fa7b",inputBg:"#21222c",inputText:"#f8f8f2",inputBorder:"#6272a4",toolbarBg:"#6272a4",toolbarBorder:"#bd93f9",toolbarText:"#f8f8f2",toolbarBtnBg:"#bd93f9",toolbarBtnText:"#282a36",selectionHandle:"#f1fa8c",groupIndicator:"#ff79c6",minimapDots:"#bd93f9",canvasHintBg:"#282a36",canvasHintColor:"#6272a4",canvasBorder:"#44475a",canvasGrid:"#44475a",rackFrameFill:"#282a36",rackFrameStroke:"#ff79c6",rackLineColor:"#6272a4",rackTextColor:"#8be9fd" },
  cobalt: { panel:"#002240",panelAlt:"#003366",sidebarBg:"#001b33",btnBg:"#003366",btnText:"#ffffff",accent:"#ffc600",danger:"#ff628c",textMain:"#ffffff",textSoft:"#8090a0",topbarBg:"#001525",topbarBorder:"#0088ff",nodeFill:"#003366",nodeStroke:"#0088ff",nodeTitle:"#ffffff",nodeSub:"#80ffbb",defaultEdge:"#0088ff",canvasGradientTop:"#002240",canvasGradientBottom:"#00111f",tagFill:"#004080",tagText:"#ffc600",tagBorder:"#0088ff",inputBg:"#001525",inputText:"#ffffff",inputBorder:"#0066cc",toolbarBg:"#0066cc",toolbarBorder:"#0088ff",toolbarText:"#ffffff",toolbarBtnBg:"#0088ff",toolbarBtnText:"#ffffff",selectionHandle:"#ffc600",groupIndicator:"#3ad900",minimapDots:"#0088ff",canvasHintBg:"#002240",canvasHintColor:"#8090a0",canvasBorder:"#0066cc",canvasGrid:"#003366",rackFrameFill:"#002240",rackFrameStroke:"#0088ff",rackLineColor:"#0066cc",rackTextColor:"#80ffbb" },
  solarized: { panel:"#073642",panelAlt:"#002b36",sidebarBg:"#002b36",btnBg:"#073642",btnText:"#93a1a1",accent:"#268bd2",danger:"#dc322f",textMain:"#93a1a1",textSoft:"#657b83",topbarBg:"#002b36",topbarBorder:"#586e75",nodeFill:"#073642",nodeStroke:"#2aa198",nodeTitle:"#93a1a1",nodeSub:"#839496",defaultEdge:"#657b83",canvasGradientTop:"#073642",canvasGradientBottom:"#002b36",tagFill:"#0a4050",tagText:"#b58900",tagBorder:"#b58900",inputBg:"#002b36",inputText:"#93a1a1",inputBorder:"#586e75",toolbarBg:"#268bd2",toolbarBorder:"#2aa198",toolbarText:"#fdf6e3",toolbarBtnBg:"#2aa198",toolbarBtnText:"#002b36",selectionHandle:"#cb4b16",groupIndicator:"#d33682",minimapDots:"#657b83",canvasHintBg:"#073642",canvasHintColor:"#657b83",canvasBorder:"#586e75",canvasGrid:"#094050",rackFrameFill:"#002b36",rackFrameStroke:"#2aa198",rackLineColor:"#586e75",rackTextColor:"#859900" }
};
document.getElementById("theme-preset").addEventListener("change", function() {
  updateDeleteButton();
  var p = THEME_PRESETS[this.value];
  if (!p && this.value.startsWith("mytheme-")) {
    var found = savedStyleSets.find(function(s) { return s.id === document.getElementById("theme-preset").value; });
    if (found) p = found.styles;
  }
  if (!p) return;
  Object.assign(PAGE_STATE, p);
  document.getElementById("panel-color").value = p.panel;
  document.getElementById("panel-alt-color").value = p.panelAlt;
  document.getElementById("sidebar-bg-color").value = p.sidebarBg;
  document.getElementById("btn-bg-color").value = p.btnBg;
  document.getElementById("btn-text-color").value = p.btnText;
  document.getElementById("accent-color").value = p.accent;
  document.getElementById("danger-color").value = p.danger;
  document.getElementById("text-main-color").value = p.textMain;
  document.getElementById("text-soft-color").value = p.textSoft;
  document.getElementById("topbar-border-color").value = p.topbarBorder;
  document.getElementById("node-fill-color").value = p.nodeFill;
  document.getElementById("node-stroke-color").value = p.nodeStroke;
  document.getElementById("node-title-color").value = p.nodeTitle;
  document.getElementById("node-sub-color").value = p.nodeSub;
  document.getElementById("default-edge-color").value = p.defaultEdge;
  document.getElementById("canvas-gradient-top").value = p.canvasGradientTop;
  document.getElementById("canvas-gradient-bottom").value = p.canvasGradientBottom;
  document.getElementById("tag-fill-color").value = p.tagFill;
  document.getElementById("tag-text-color").value = p.tagText;
  document.getElementById("tag-border-color").value = p.tagBorder;
  document.getElementById("input-bg-color").value = p.inputBg;
  document.getElementById("input-text-color").value = p.inputText;
  document.getElementById("input-border-color").value = p.inputBorder;
  document.getElementById("toolbar-bg-color").value = p.toolbarBg;
  document.getElementById("toolbar-border-color").value = p.toolbarBorder;
  document.getElementById("toolbar-text-color").value = p.toolbarText;
  document.getElementById("toolbar-btn-bg-color").value = p.toolbarBtnBg;
  document.getElementById("toolbar-btn-text-color").value = p.toolbarBtnText;
  document.getElementById("selection-handle-color").value = p.selectionHandle;
  document.getElementById("group-indicator-color").value = p.groupIndicator;
  document.getElementById("minimap-dots-color").value = p.minimapDots;
  document.getElementById("canvas-hint-bg-color").value = p.canvasHintBg;
  document.getElementById("canvas-hint-text-color").value = p.canvasHintColor;
  document.getElementById("canvas-border-color").value = p.canvasBorder;
  document.getElementById("canvas-grid-color").value = p.canvasGrid;
  document.getElementById("rack-frame-fill").value = p.rackFrameFill;
  document.getElementById("rack-frame-stroke").value = p.rackFrameStroke;
  document.getElementById("rack-line-color").value = p.rackLineColor;
  document.getElementById("rack-text-color").value = p.rackTextColor;
  wieldThePower();
  forgeTheTopology();
});
document.querySelectorAll('#settings-modal .style-content input, #settings-modal .style-content select').forEach(el => {
  if (el.id === 'theme-preset') return;
  el.addEventListener('input', () => document.getElementById('theme-preset').value = '');
  el.addEventListener('change', () => document.getElementById('theme-preset').value = '');
});
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       document.getElementById("add-line-color").value = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
	  document.getElementById("canvas-grid-enabled").addEventListener("change", (e) => {
 PAGE_STATE.canvasGridEnabled = e.target.checked;
 forgeTheTopology();
});
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("rack-grid-enabled").addEventListener("change", (e) => {
 PAGE_STATE.rackGridEnabled = e.target.checked;
 forgeTheTopology();
});
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
		pushUndo('import json');
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.savedStyleSets) {
          savedStyleSets = data.savedStyleSets;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        if (typeof forgeTheLegend === 'function') forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
		savedStyleSets: savedStyleSets,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2);
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)");
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState(scope = "all") {
       const clone = typeof structuredClone === 'function' 
         ? (o) => structuredClone(o)
         : (o) => JSON.parse(JSON.stringify(o));
       
       if (scope === "all") {
        return {
         scope: "all",
         nodes: clone(NODE_DATA),
         edges: clone(EDGE_DATA),
         positions: clone(savedPositions),
         sizes: clone(savedSizes),
         styles: clone(savedStyles),
         legend: clone(EDGE_LEGEND),
         rects: clone(RECT_DATA),
         texts: clone(TEXT_DATA)
        };
       }
       
       const state = { scope };
       if (scope.includes("nodes")) state.nodes = clone(NODE_DATA);
       if (scope.includes("edges")) state.edges = clone(EDGE_DATA);
       if (scope.includes("positions")) state.positions = clone(savedPositions);
       if (scope.includes("sizes")) state.sizes = clone(savedSizes);
       if (scope.includes("styles")) state.styles = clone(savedStyles);
       if (scope.includes("legend")) state.legend = clone(EDGE_LEGEND);
       if (scope.includes("rects")) state.rects = clone(RECT_DATA);
       if (scope.includes("texts")) state.texts = clone(TEXT_DATA);
       return state;
      }
      let lastUndoPush = 0;
	  function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	     return;
    	 }
	   lastUndoPush = now;
       const actionScopes = {
        "move nodes": "positions",
        "nudge": "positions",
        "align nodes": "positions",
        "distribute nodes": "positions",
        "snap to grid": "positions",
        "resize node": "sizes",
        "reset size": "sizes",
        "style change": "styles",
        "edit edge": "edges",
        "edit edge routing": "edges",
        "edit edge point": "edges",
        "add edge": "edges,positions",
        "delete edge": "edges",
        "add edge note": "edges",
        "edit edge note": "edges",
        "delete edge note": "edges",
        "draw zone": "rects",
        "delete zone": "rects",
        "resize zone": "rects",
        "edit zone": "rects",
        "add zone note": "rects",
        "delete zone note": "rects",
        "change zone line style": "rects",
        "add text": "texts",
        "edit text": "texts",
        "delete text": "texts",
       };
       const scope = actionScopes[action] || "all";
       const state = captureState(scope);
	   undoStack.push(state);
        if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      if (state.nodes) NODE_DATA = state.nodes;
      if (state.edges) EDGE_DATA = state.edges;
      if (state.positions) savedPositions = state.positions;
      if (state.sizes) savedSizes = state.sizes;
      if (state.styles) savedStyles = state.styles;
      if (state.legend) EDGE_LEGEND = state.legend;
      if (state.rects) RECT_DATA = state.rects;
      if (state.texts) TEXT_DATA = state.texts;
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
		NODE_DATA[newId] = {
		 shape: source.shape,
		 name: newName,
		 ip: source.ip,
		 role: source.role,
		 tags: [...source.tags],
		 notes: [...source.notes],
		 mac: source.mac || "",
		 rackUnit: source.rackUnit || "",
		 uHeight: source.uHeight || "1",
		 layer: source.layer || "physical",
		 assignedRack: source.assignedRack || "",
		 rackCapacity: source.rackCapacity || "42",
		 isRack: source.isRack || false,
fovEnabled: source.fovEnabled || false,
 fovAngle: source.fovAngle || 90,
 fovDistance: source.fovDistance || 150,
 fovInnerRadius: source.fovInnerRadius || 0,
 fovRotation: source.fovRotation || 0,
 fovColor: source.fovColor || "#f59e0b",
 fovOpacity: source.fovOpacity || 20,
 fovGradient: source.fovGradient || false,
 fovBorderColor: source.fovBorderColor || "#f59e0b",
 fovBorderWidth: source.fovBorderWidth ?? 2,
 fovBorderStyle: source.fovBorderStyle || "solid",
 fovBorderOpacity: source.fovBorderOpacity ?? 100,
 fovLabel: source.fovLabel || "",
 fovLabelPosition: source.fovLabelPosition || "center",
 fovLabelSize: source.fovLabelSize || 14,
 fovLabelColor: source.fovLabelColor || "#ffffff",
 fovLabelBold: source.fovLabelBold || false,
 fovLabelBg: source.fovLabelBg || false,
 fovLabelBgColor: source.fovLabelBgColor || "#000000",
 fovLabelOffsetX: source.fovLabelOffsetX || 0,
 fovLabelOffsetY: source.fovLabelOffsetY || 0,
 fovAnimate: source.fovAnimate || false,
 fovAnimationType: source.fovAnimationType || "sweep",
 fovSweep: source.fovSweep || 120,
 fovSpeed: source.fovSpeed || 4
		};
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
		    focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function saveCurrentTheme() {
        const name = prompt("Enter a name for this theme:", "My Theme " + (savedStyleSets.length + 1));
        if (!name || !name.trim()) return;
        const existingIndex = savedStyleSets.findIndex(s => s.name.toLowerCase() === name.trim().toLowerCase());
        if (existingIndex !== -1) {
          if (!confirm("A theme named \"" + name + "\" already exists. Replace it?")) return;
          savedStyleSets.splice(existingIndex, 1);
        }
        const styleSet = {
          id: "mytheme-" + Date.now(),
          name: name.trim(),
          styles: JSON.parse(JSON.stringify(PAGE_STATE))
        };
        delete styleSet.styles.title;
        delete styleSet.styles.viewOnly;
        savedStyleSets.push(styleSet);
        rebuildThemeDropdown();
        document.getElementById("theme-preset").value = styleSet.id;
        updateDeleteButton();
        logAuditEvent("style", "Saved theme: " + name);
      }
      function deleteCurrentTheme() {
        const select = document.getElementById("theme-preset");
        const val = select.value;
        if (!val.startsWith("mytheme-")) return;
        const index = savedStyleSets.findIndex(s => s.id === val);
        if (index === -1) return;
        if (!confirm("Delete theme \"" + savedStyleSets[index].name + "\"?")) return;
        savedStyleSets.splice(index, 1);
        rebuildThemeDropdown();
        select.value = "defaulted";
        updateDeleteButton();
        logAuditEvent("style", "Deleted theme");
      }
      function rebuildThemeDropdown() {
        const group = document.getElementById("my-themes-group");
        if (!group) return;
        const select = document.getElementById("theme-preset");
        const currentValue = select ? select.value : "";
        group.innerHTML = "";
        savedStyleSets.forEach(function(s) {
          const opt = document.createElement("option");
          opt.value = s.id;
          opt.textContent = s.name;
          group.appendChild(opt);
        });
        if (select && currentValue) {
          select.value = currentValue;
        }
      }
      function updateDeleteButton() {
        const select = document.getElementById("theme-preset");
        const btn = document.getElementById("delete-theme-btn");
        if (!btn) return;
		btn.style.display = "block";
		btn.disabled = !select.value.startsWith("mytheme-");
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 8px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 6px;"></span><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(fromName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')" style="background: ${e.fromPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.fromPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${fromPortDisplay}</button></td><td style="padding: 8px;"><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(toName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')" style="background: ${e.toPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.toPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${toPortDisplay}</button></td><td style="padding: 8px;"><button onclick="${goToEdge}" style="background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;" title="Go to connection">Go</button></td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from || "";
          const toName = NODE_DATA[e.to]?.name || e.to || "";
          const notes = (e.notes || []).join("; ");
          csv += `${csvEscape(fromName)},${csvEscape(e.fromPort || "")},${csvEscape(toName)},${csvEscape(e.toPort || "")},${csvEscape(notes)}\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       });
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);   
        clipboard = null;      
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
	document.addEventListener('DOMContentLoaded', () => {
	  document.querySelectorAll('.dropdown').forEach(dropdown => {
		const btn = dropdown.querySelector('.dropdown-btn');
		const menu = dropdown.querySelector('.dropdown-menu');
		if (!btn || !menu) return;
		btn.addEventListener('click', (e) => {
		  e.stopPropagation();
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => {
			if (m !== menu) m.classList.remove('open');
		  });
		  menu.classList.toggle('open');
		});
	  });
	  document.addEventListener('click', (e) => {
		if (!e.target.closest('.dropdown')) {
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		}
	  });
	  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
		btn.addEventListener('click', () => {
		  setTimeout(() => {
			document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		  }, 100);
		});
	  });
	  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
	function printTopology() {
	  const svg = document.getElementById('map');
	  if (!svg) { window.print(); return; }
	  const originalViewBox = svg.getAttribute('viewBox');
	  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	  
	  Object.values(savedPositions).forEach(pos => {
		minX = Math.min(minX, pos.x - 100);
		minY = Math.min(minY, pos.y - 100);
		maxX = Math.max(maxX, pos.x + 100);
		maxY = Math.max(maxY, pos.y + 100);
	  });
	  
	  RECT_DATA.list.forEach(rect => {
		minX = Math.min(minX, rect.x);
		minY = Math.min(minY, rect.y);
		maxX = Math.max(maxX, rect.x + rect.width);
		maxY = Math.max(maxY, rect.y + rect.height);
	  });
	  
	  TEXT_DATA.list.forEach(text => {
		minX = Math.min(minX, text.x - 50);
		minY = Math.min(minY, text.y - 50);
		maxX = Math.max(maxX, text.x + 200);
		maxY = Math.max(maxY, text.y + 50);
	  });

	  const padding = 50;
	  minX -= padding;
	  minY -= padding;
	  maxX += padding;
	  maxY += padding;

	  if (minX !== Infinity) {
		svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
	  }

	  window.print();

	  setTimeout(() => {
		svg.setAttribute('viewBox', originalViewBox);
	  }, 1000);
	}
	function exportJSONFile() {
	  const data = captureTheQuickening();
	  const jsonStr = JSON.stringify(data, null, 2);
	  const blob = new Blob([jsonStr], { type: "application/json" });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement("a");
	  a.href = url;
	  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
	  a.download = `${safeTitle}.json`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent("export", `Exported JSON: ${a.download}`);
	}
	function exportCSV() {
	  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
	  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
	  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
	  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
	  csv += `# Exported from The One File on ${timestamp}\n`;
	  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
	  csv += headers.join(',') + '\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
		const row = [
		  csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
		  node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
		  csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
		  node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
		  node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
		  size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
		];
		csv += row.join(',') + '\n';
	  });
	  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.csv`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported CSV: ${a.download}`);
	}
	function csvEscape(val) {
	  if (val === null || val === undefined) return '';
	  const str = String(val);
	  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
		return '"' + str.replace(/"/g, '""') + '"';
	  }
	  return str;
	}
	document.getElementById('import-csv-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  try {
		const text = await file.text();
		const lines = text.split(/\r?\n/);
		let config = null;
		let dataLines = [];
		let headers = null;
		for (const line of lines) {
		  const trimmed = line.trim();
		  if (!trimmed) continue;
		  if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
			try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
			continue;
		  }
		  if (trimmed.startsWith('#')) continue;
		  if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
		  dataLines.push(trimmed);
		}
		if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
		const nameIdx = headers.indexOf('name');
		if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
		const nodes = dataLines.map(line => {
		  const values = parseCSVLine(line);
		  const node = {};
		  headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
		  return node;
		});
		const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add'; 
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `• ${nodes.length} nodes in CSV data\n` +
        `• ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `• ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      if (typeof forgeTheLegend === 'function') forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
	
		if (hasConfig) {
		  Object.assign(PAGE_STATE, config.pageState || config.page);
		  if (config.canvasView || config.canvas) {
			canvasState.zoom = (config.canvasView || config.canvas).zoom || 1;
			canvasState.panX = (config.canvasView || config.canvas).panX || 0;
			canvasState.panY = (config.canvasView || config.canvas).panY || 0;
		  }
		  if (config.legend || config.edgeLegend) Object.assign(EDGE_LEGEND, config.legend || config.edgeLegend);
		  wieldThePower();
		}
		let gridX = 200, gridY = 200;
		const spacing = 150;
		const perRow = Math.ceil(Math.sqrt(nodes.length));
		let gridIndex = 0;
		nodes.forEach((n) => {
		  let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
		  if (!baseId) baseId = 'node';
		  let nodeId = baseId;
		  let counter = 1;
		  while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
		  NODE_DATA[nodeId] = {
			name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
			tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
			notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
			layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
			uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
			isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
		  };
		  const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
		  if (hasPosition) {
			savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
		  } else {
			const row = Math.floor(gridIndex / perRow);
			const col = gridIndex % perRow;
			savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
			gridIndex++;
		  }
		  if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
		  if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
		});
		forgeTheTopology();
		updateViewBox();
		logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
		alert(`Successfully imported ${nodes.length} nodes`);
	  } catch (err) {
		console.error('CSV import error:', err);
		alert('Failed to import CSV: ' + err.message);
	  }
	});
	function parseCSVLine(line) {
	  const result = [];
	  let current = '';
	  let inQuotes = false;
	  for (let i = 0; i < line.length; i++) {
		const char = line[i];
		if (char === '"') {
		  if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
		  else { inQuotes = !inQuotes; }
		} else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
		else { current += char; }
	  }
	  result.push(current);
	  return result;
	}
	function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
	  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
	  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
	  md += `## Legend\n\n`;
	  if (Object.keys(EDGE_LEGEND).length > 0) {
		Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
	  } else { md += `_No legend entries_\n`; }
	  md += '\n## Nodes\n\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] || null;
		md += `### ${id}\n`;
		md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
		md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
		md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
		md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
		md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
		md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
		md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
		if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
		md += '\n';
	  });
	  md += `## Connections\n\n`;
	  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
		EDGE_DATA.list.forEach(edge => {
		  const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
		  const toPort = edge.toPort ? ` (${edge.toPort})` : '';
		  md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
		  md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
		  md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
		  md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
		  md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
		  if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
		  if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No connections_\n\n`; }
	  md += `## Zones\n\n`;
	  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
		RECT_DATA.list.forEach(rect => {
		  md += `### ${rect.id}\n`;
		  md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
		  md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
		  md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
		  if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No zones_\n\n`; }
	  md += `## Text Labels\n\n`;
	  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
		TEXT_DATA.list.forEach(text => {
		  md += `### ${text.id}\n`;
		  md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
		  md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
		  md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
		  md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
		  md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
		  md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
		});
	  } else { md += `_No text labels_\n\n`; }
	  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.md`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported Markdown: ${a.download}`);
	}
		document.getElementById('import-markdown-file').addEventListener('change', async (e) => {
		  const file = e.target.files[0];
		  if (!file) return;
		  e.target.value = '';
		  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
         } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    let skippedEdges = 0;
    edges.forEach(edge => {
      if (!NODE_DATA[edge.from] || !NODE_DATA[edge.to]) {
        console.warn(`Skipping orphan edge: ${edge.from} -> ${edge.to}`);
        skippedEdges++;
        return;
      }
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    if (skippedEdges > 0) console.warn(`Total skipped orphan edges: ${skippedEdges}`);
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
     } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
     }
	});
	document.getElementById('import-json-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  const existingInput = document.getElementById('import-data-file');
	  if (existingInput) {
		const dt = new DataTransfer();
		dt.items.add(file);
		existingInput.files = dt.files;
		existingInput.dispatchEvent(new Event('change'));
	  }
	});
	document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-export-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-import-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
	});
	document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
	});
    </script>
  
</body></html>