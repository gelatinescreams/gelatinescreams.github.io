<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-74.99705309342698 -7.395887697909075 4069.861183597212 3052.395887697909" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-74.99705309342698" y="-7.395887697909075" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">✕</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
		  this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
	   pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       logAuditEvent("export", `Exported JSON: ${a.download}`);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			clearSearchHighlight();
			return [];
		   }
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   highlightSearchResults(results, true);
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		// forgeTheTopology(); getting ready to implement new core canvas performance system
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()">${escapeHtml(e.fromPort) || "-"}</td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()">${escapeHtml(e.toPort) || "-"}</td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       pushUndo("clear all");
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       logAuditEvent("clear", "Cleared all data from canvas");
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>